Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program_heading ; block .
Rule 2     program_heading -> PROGRAM ID ( id_list )
Rule 3     program_heading -> PROGRAM ID
Rule 4     block -> const_part procfunc_part var_part compound_statement
Rule 5     const_part -> <empty>
Rule 6     const_part -> CONST const_list
Rule 7     const_list -> const_def ;
Rule 8     const_list -> const_list const_def ;
Rule 9     const_def -> ID = constant
Rule 10    constant -> sign INT
Rule 11    constant -> INT
Rule 12    constant -> sign REAL
Rule 13    constant -> REAL
Rule 14    constant -> CHAR
Rule 15    constant -> STRING
Rule 16    constant -> ID
Rule 17    constant -> TRUE
Rule 18    constant -> FALSE
Rule 19    sign -> +
Rule 20    sign -> -
Rule 21    var_part -> <empty>
Rule 22    var_part -> VAR var_list
Rule 23    var_list -> var_dec ;
Rule 24    var_list -> var_list var_dec ;
Rule 25    var_dec -> id_list : tipo
Rule 26    id_list -> ID
Rule 27    id_list -> ID , id_list
Rule 28    tipo -> ID
Rule 29    tipo -> new_type
Rule 30    new_type -> enumerated_type
Rule 31    new_type -> subrange_type
Rule 32    new_type -> array_type
Rule 33    enumerated_type -> ( id_list )
Rule 34    subrange_type -> constant DOTDOT constant
Rule 35    array_type -> ARRAY [ ordinal_type_list ] OF tipo
Rule 36    ordinal_type -> enumerated_type
Rule 37    ordinal_type -> subrange_type
Rule 38    ordinal_type -> ID
Rule 39    ordinal_type_list -> ordinal_type
Rule 40    ordinal_type_list -> ordinal_type_list , ordinal_type
Rule 41    procfunc_part -> <empty>
Rule 42    procfunc_part -> procfunc_part proc_dec
Rule 43    procfunc_part -> procfunc_part func_dec
Rule 44    proc_dec -> proc_heading ; block ;
Rule 45    func_dec -> func_heading ; block ;
Rule 46    proc_heading -> PROCEDURE ID
Rule 47    proc_heading -> PROCEDURE ID ( param_list )
Rule 48    func_heading -> FUNCTION ID : ID
Rule 49    func_heading -> FUNCTION ID ( param_list ) : ID
Rule 50    param_list -> param
Rule 51    param_list -> param_list ; param
Rule 52    param -> id_list : ID
Rule 53    param -> VAR id_list : ID
Rule 54    var_access -> ID var_suffix
Rule 55    var_suffix -> <empty>
Rule 56    var_suffix -> [ expr_list ] var_suffix
Rule 57    expr_list -> expr
Rule 58    expr_list -> expr_list , expr
Rule 59    expr -> simple_expr
Rule 60    expr -> simple_expr relation_op simple_expr
Rule 61    simple_expr -> term term_sequence
Rule 62    simple_expr -> sign term term_sequence
Rule 63    term -> factor factor_sequence
Rule 64    term_sequence -> <empty>
Rule 65    term_sequence -> add_op term term_sequence
Rule 66    factor_sequence -> <empty>
Rule 67    factor_sequence -> mul_op factor factor_sequence
Rule 68    factor -> var_access
Rule 69    factor -> INT
Rule 70    factor -> REAL
Rule 71    factor -> CHAR
Rule 72    factor -> STRING
Rule 73    factor -> ID ( expr_list )
Rule 74    factor -> ( expr )
Rule 75    factor -> NOT factor
Rule 76    factor -> TRUE
Rule 77    factor -> FALSE
Rule 78    add_op -> +
Rule 79    add_op -> -
Rule 80    add_op -> OR
Rule 81    mul_op -> *
Rule 82    mul_op -> /
Rule 83    mul_op -> DIV
Rule 84    mul_op -> MOD
Rule 85    mul_op -> AND
Rule 86    relation_op -> =
Rule 87    relation_op -> NE
Rule 88    relation_op -> LT
Rule 89    relation_op -> GT
Rule 90    relation_op -> LE
Rule 91    relation_op -> GE
Rule 92    compound_statement -> BEGIN statement_list END
Rule 93    statement_list -> statement
Rule 94    statement_list -> statement_list ; statement
Rule 95    statement -> <empty>
Rule 96    statement -> assignment_statement
Rule 97    statement -> proc_statement
Rule 98    statement -> read_statement
Rule 99    statement -> write_statement
Rule 100   statement -> labeled_statement
Rule 101   statement -> compound_statement
Rule 102   statement -> if_statement
Rule 103   statement -> while_statement
Rule 104   statement -> for_statement
Rule 105   assignment_statement -> var_access ASSIGN expr
Rule 106   proc_statement -> ID
Rule 107   proc_statement -> ID ( expr_list )
Rule 108   labeled_statement -> INT : statement
Rule 109   read_statement -> READ ( var_access_list )
Rule 110   read_statement -> READLN
Rule 111   read_statement -> READLN ( var_access_list )
Rule 112   var_access_list -> var_access
Rule 113   var_access_list -> var_access_list , var_access
Rule 114   write_statement -> WRITE ( write_list )
Rule 115   write_statement -> WRITELN
Rule 116   write_statement -> WRITELN ( write_list )
Rule 117   write_list -> write_param
Rule 118   write_list -> write_list , write_param
Rule 119   write_param -> expr
Rule 120   write_param -> expr : expr
Rule 121   write_param -> expr : expr : expr
Rule 122   if_statement -> IF expr THEN statement
Rule 123   if_statement -> IF expr THEN statement ELSE statement
Rule 124   while_statement -> WHILE expr DO statement
Rule 125   for_statement -> FOR ID ASSIGN expr TO expr DO statement
Rule 126   for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement

Terminals, with rules where they appear

(                    : 2 33 47 49 73 74 107 109 111 114 116
)                    : 2 33 47 49 73 74 107 109 111 114 116
*                    : 81
+                    : 19 78
,                    : 27 40 58 113 118
-                    : 20 79
.                    : 1
/                    : 82
:                    : 25 48 49 52 53 108 120 121 121
;                    : 1 7 8 23 24 44 44 45 45 51 94
=                    : 9 86
AND                  : 85
ARRAY                : 35
ASSIGN               : 105 125 126
BEGIN                : 92
CHAR                 : 14 71
CONST                : 6
DIV                  : 83
DO                   : 124 125 126
DOTDOT               : 34
DOWNTO               : 126
ELSE                 : 123
END                  : 92
FALSE                : 18 77
FOR                  : 125 126
FUNCTION             : 48 49
GE                   : 91
GT                   : 89
ID                   : 2 3 9 16 26 27 28 38 46 47 48 48 49 49 52 53 54 73 106 107 125 126
IF                   : 122 123
INT                  : 10 11 69 108
LE                   : 90
LT                   : 88
MOD                  : 84
NE                   : 87
NOT                  : 75
OF                   : 35
OR                   : 80
PROCEDURE            : 46 47
PROGRAM              : 2 3
READ                 : 109
READLN               : 110 111
REAL                 : 12 13 70
STRING               : 15 72
THEN                 : 122 123
TO                   : 125
TRUE                 : 17 76
VAR                  : 22 53
WHILE                : 124
WRITE                : 114
WRITELN              : 115 116
[                    : 35 56
]                    : 35 56
error                : 

Nonterminals, with rules where they appear

add_op               : 65
array_type           : 32
assignment_statement : 96
block                : 1 44 45
compound_statement   : 4 101
const_def            : 7 8
const_list           : 6 8
const_part           : 4
constant             : 9 34 34
enumerated_type      : 30 36
expr                 : 57 58 74 105 119 120 120 121 121 121 122 123 124 125 125 126 126
expr_list            : 56 58 73 107
factor               : 63 67 75
factor_sequence      : 63 67
for_statement        : 104
func_dec             : 43
func_heading         : 45
id_list              : 2 25 27 33 52 53
if_statement         : 102
labeled_statement    : 100
mul_op               : 67
new_type             : 29
ordinal_type         : 39 40
ordinal_type_list    : 35 40
param                : 50 51
param_list           : 47 49 51
proc_dec             : 42
proc_heading         : 44
proc_statement       : 97
procfunc_part        : 4 42 43
program              : 0
program_heading      : 1
read_statement       : 98
relation_op          : 60
sign                 : 10 12 62
simple_expr          : 59 60 60
statement            : 93 94 108 122 123 123 124 125 126
statement_list       : 92 94
subrange_type        : 31 37
term                 : 61 62 65
term_sequence        : 61 62 65
tipo                 : 25 35
var_access           : 68 105 112 113
var_access_list      : 109 111 113
var_dec              : 23 24
var_list             : 22 24
var_part             : 4
var_suffix           : 54 56
while_statement      : 103
write_list           : 114 116 118
write_param          : 117 118
write_statement      : 99

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program_heading ; block .
    (2) program_heading -> . PROGRAM ID ( id_list )
    (3) program_heading -> . PROGRAM ID

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    program_heading                shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> program_heading . ; block .

    ;               shift and go to state 4


state 3

    (2) program_heading -> PROGRAM . ID ( id_list )
    (3) program_heading -> PROGRAM . ID

    ID              shift and go to state 5


state 4

    (1) program -> program_heading ; . block .
    (4) block -> . const_part procfunc_part var_part compound_statement
    (5) const_part -> .
    (6) const_part -> . CONST const_list

    VAR             reduce using rule 5 (const_part -> .)
    PROCEDURE       reduce using rule 5 (const_part -> .)
    FUNCTION        reduce using rule 5 (const_part -> .)
    BEGIN           reduce using rule 5 (const_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 6
    const_part                     shift and go to state 7

state 5

    (2) program_heading -> PROGRAM ID . ( id_list )
    (3) program_heading -> PROGRAM ID .

    (               shift and go to state 9
    ;               reduce using rule 3 (program_heading -> PROGRAM ID .)


state 6

    (1) program -> program_heading ; block . .

    .               shift and go to state 10


state 7

    (4) block -> const_part . procfunc_part var_part compound_statement
    (41) procfunc_part -> .
    (42) procfunc_part -> . procfunc_part proc_dec
    (43) procfunc_part -> . procfunc_part func_dec

    VAR             reduce using rule 41 (procfunc_part -> .)
    PROCEDURE       reduce using rule 41 (procfunc_part -> .)
    FUNCTION        reduce using rule 41 (procfunc_part -> .)
    BEGIN           reduce using rule 41 (procfunc_part -> .)

    procfunc_part                  shift and go to state 11

state 8

    (6) const_part -> CONST . const_list
    (7) const_list -> . const_def ;
    (8) const_list -> . const_list const_def ;
    (9) const_def -> . ID = constant

    ID              shift and go to state 14

    const_list                     shift and go to state 12
    const_def                      shift and go to state 13

state 9

    (2) program_heading -> PROGRAM ID ( . id_list )
    (26) id_list -> . ID
    (27) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 16

state 10

    (1) program -> program_heading ; block . .

    $end            reduce using rule 1 (program -> program_heading ; block . .)


state 11

    (4) block -> const_part procfunc_part . var_part compound_statement
    (42) procfunc_part -> procfunc_part . proc_dec
    (43) procfunc_part -> procfunc_part . func_dec
    (21) var_part -> .
    (22) var_part -> . VAR var_list
    (44) proc_dec -> . proc_heading ; block ;
    (45) func_dec -> . func_heading ; block ;
    (46) proc_heading -> . PROCEDURE ID
    (47) proc_heading -> . PROCEDURE ID ( param_list )
    (48) func_heading -> . FUNCTION ID : ID
    (49) func_heading -> . FUNCTION ID ( param_list ) : ID

    BEGIN           reduce using rule 21 (var_part -> .)
    VAR             shift and go to state 20
    PROCEDURE       shift and go to state 23
    FUNCTION        shift and go to state 24

    var_part                       shift and go to state 17
    proc_dec                       shift and go to state 18
    func_dec                       shift and go to state 19
    proc_heading                   shift and go to state 21
    func_heading                   shift and go to state 22

state 12

    (6) const_part -> CONST const_list .
    (8) const_list -> const_list . const_def ;
    (9) const_def -> . ID = constant

    VAR             reduce using rule 6 (const_part -> CONST const_list .)
    PROCEDURE       reduce using rule 6 (const_part -> CONST const_list .)
    FUNCTION        reduce using rule 6 (const_part -> CONST const_list .)
    BEGIN           reduce using rule 6 (const_part -> CONST const_list .)
    ID              shift and go to state 14

    const_def                      shift and go to state 25

state 13

    (7) const_list -> const_def . ;

    ;               shift and go to state 26


state 14

    (9) const_def -> ID . = constant

    =               shift and go to state 27


state 15

    (26) id_list -> ID .
    (27) id_list -> ID . , id_list

    )               reduce using rule 26 (id_list -> ID .)
    :               reduce using rule 26 (id_list -> ID .)
    ,               shift and go to state 28


state 16

    (2) program_heading -> PROGRAM ID ( id_list . )

    )               shift and go to state 29


state 17

    (4) block -> const_part procfunc_part var_part . compound_statement
    (92) compound_statement -> . BEGIN statement_list END

    BEGIN           shift and go to state 31

    compound_statement             shift and go to state 30

state 18

    (42) procfunc_part -> procfunc_part proc_dec .

    VAR             reduce using rule 42 (procfunc_part -> procfunc_part proc_dec .)
    PROCEDURE       reduce using rule 42 (procfunc_part -> procfunc_part proc_dec .)
    FUNCTION        reduce using rule 42 (procfunc_part -> procfunc_part proc_dec .)
    BEGIN           reduce using rule 42 (procfunc_part -> procfunc_part proc_dec .)


state 19

    (43) procfunc_part -> procfunc_part func_dec .

    VAR             reduce using rule 43 (procfunc_part -> procfunc_part func_dec .)
    PROCEDURE       reduce using rule 43 (procfunc_part -> procfunc_part func_dec .)
    FUNCTION        reduce using rule 43 (procfunc_part -> procfunc_part func_dec .)
    BEGIN           reduce using rule 43 (procfunc_part -> procfunc_part func_dec .)


state 20

    (22) var_part -> VAR . var_list
    (23) var_list -> . var_dec ;
    (24) var_list -> . var_list var_dec ;
    (25) var_dec -> . id_list : tipo
    (26) id_list -> . ID
    (27) id_list -> . ID , id_list

    ID              shift and go to state 15

    var_list                       shift and go to state 32
    var_dec                        shift and go to state 33
    id_list                        shift and go to state 34

state 21

    (44) proc_dec -> proc_heading . ; block ;

    ;               shift and go to state 35


state 22

    (45) func_dec -> func_heading . ; block ;

    ;               shift and go to state 36


state 23

    (46) proc_heading -> PROCEDURE . ID
    (47) proc_heading -> PROCEDURE . ID ( param_list )

    ID              shift and go to state 37


state 24

    (48) func_heading -> FUNCTION . ID : ID
    (49) func_heading -> FUNCTION . ID ( param_list ) : ID

    ID              shift and go to state 38


state 25

    (8) const_list -> const_list const_def . ;

    ;               shift and go to state 39


state 26

    (7) const_list -> const_def ; .

    ID              reduce using rule 7 (const_list -> const_def ; .)
    VAR             reduce using rule 7 (const_list -> const_def ; .)
    PROCEDURE       reduce using rule 7 (const_list -> const_def ; .)
    FUNCTION        reduce using rule 7 (const_list -> const_def ; .)
    BEGIN           reduce using rule 7 (const_list -> const_def ; .)


state 27

    (9) const_def -> ID = . constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) constant -> . TRUE
    (18) constant -> . FALSE
    (19) sign -> . +
    (20) sign -> . -

    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    ID              shift and go to state 40
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    +               shift and go to state 49
    -               shift and go to state 50

    constant                       shift and go to state 41
    sign                           shift and go to state 42

state 28

    (27) id_list -> ID , . id_list
    (26) id_list -> . ID
    (27) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 51

state 29

    (2) program_heading -> PROGRAM ID ( id_list ) .

    ;               reduce using rule 2 (program_heading -> PROGRAM ID ( id_list ) .)


state 30

    (4) block -> const_part procfunc_part var_part compound_statement .

    .               reduce using rule 4 (block -> const_part procfunc_part var_part compound_statement .)
    ;               reduce using rule 4 (block -> const_part procfunc_part var_part compound_statement .)


state 31

    (92) compound_statement -> BEGIN . statement_list END
    (93) statement_list -> . statement
    (94) statement_list -> . statement_list ; statement
    (95) statement -> .
    (96) statement -> . assignment_statement
    (97) statement -> . proc_statement
    (98) statement -> . read_statement
    (99) statement -> . write_statement
    (100) statement -> . labeled_statement
    (101) statement -> . compound_statement
    (102) statement -> . if_statement
    (103) statement -> . while_statement
    (104) statement -> . for_statement
    (105) assignment_statement -> . var_access ASSIGN expr
    (106) proc_statement -> . ID
    (107) proc_statement -> . ID ( expr_list )
    (109) read_statement -> . READ ( var_access_list )
    (110) read_statement -> . READLN
    (111) read_statement -> . READLN ( var_access_list )
    (114) write_statement -> . WRITE ( write_list )
    (115) write_statement -> . WRITELN
    (116) write_statement -> . WRITELN ( write_list )
    (108) labeled_statement -> . INT : statement
    (92) compound_statement -> . BEGIN statement_list END
    (122) if_statement -> . IF expr THEN statement
    (123) if_statement -> . IF expr THEN statement ELSE statement
    (124) while_statement -> . WHILE expr DO statement
    (125) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (126) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID var_suffix

    END             reduce using rule 95 (statement -> .)
    ;               reduce using rule 95 (statement -> .)
    ID              shift and go to state 64
    READ            shift and go to state 65
    READLN          shift and go to state 66
    WRITE           shift and go to state 67
    WRITELN         shift and go to state 68
    INT             shift and go to state 69
    BEGIN           shift and go to state 31
    IF              shift and go to state 70
    WHILE           shift and go to state 71
    FOR             shift and go to state 72

    statement_list                 shift and go to state 52
    statement                      shift and go to state 53
    assignment_statement           shift and go to state 54
    proc_statement                 shift and go to state 55
    read_statement                 shift and go to state 56
    write_statement                shift and go to state 57
    labeled_statement              shift and go to state 58
    compound_statement             shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    var_access                     shift and go to state 63

state 32

    (22) var_part -> VAR var_list .
    (24) var_list -> var_list . var_dec ;
    (25) var_dec -> . id_list : tipo
    (26) id_list -> . ID
    (27) id_list -> . ID , id_list

    BEGIN           reduce using rule 22 (var_part -> VAR var_list .)
    ID              shift and go to state 15

    var_dec                        shift and go to state 73
    id_list                        shift and go to state 34

state 33

    (23) var_list -> var_dec . ;

    ;               shift and go to state 74


state 34

    (25) var_dec -> id_list . : tipo

    :               shift and go to state 75


state 35

    (44) proc_dec -> proc_heading ; . block ;
    (4) block -> . const_part procfunc_part var_part compound_statement
    (5) const_part -> .
    (6) const_part -> . CONST const_list

    VAR             reduce using rule 5 (const_part -> .)
    PROCEDURE       reduce using rule 5 (const_part -> .)
    FUNCTION        reduce using rule 5 (const_part -> .)
    BEGIN           reduce using rule 5 (const_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 76
    const_part                     shift and go to state 7

state 36

    (45) func_dec -> func_heading ; . block ;
    (4) block -> . const_part procfunc_part var_part compound_statement
    (5) const_part -> .
    (6) const_part -> . CONST const_list

    VAR             reduce using rule 5 (const_part -> .)
    PROCEDURE       reduce using rule 5 (const_part -> .)
    FUNCTION        reduce using rule 5 (const_part -> .)
    BEGIN           reduce using rule 5 (const_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 77
    const_part                     shift and go to state 7

state 37

    (46) proc_heading -> PROCEDURE ID .
    (47) proc_heading -> PROCEDURE ID . ( param_list )

    ;               reduce using rule 46 (proc_heading -> PROCEDURE ID .)
    (               shift and go to state 78


state 38

    (48) func_heading -> FUNCTION ID . : ID
    (49) func_heading -> FUNCTION ID . ( param_list ) : ID

    :               shift and go to state 79
    (               shift and go to state 80


state 39

    (8) const_list -> const_list const_def ; .

    ID              reduce using rule 8 (const_list -> const_list const_def ; .)
    VAR             reduce using rule 8 (const_list -> const_list const_def ; .)
    PROCEDURE       reduce using rule 8 (const_list -> const_list const_def ; .)
    FUNCTION        reduce using rule 8 (const_list -> const_list const_def ; .)
    BEGIN           reduce using rule 8 (const_list -> const_list const_def ; .)


state 40

    (16) constant -> ID .

    ;               reduce using rule 16 (constant -> ID .)
    ]               reduce using rule 16 (constant -> ID .)
    ,               reduce using rule 16 (constant -> ID .)


state 41

    (9) const_def -> ID = constant .

    ;               reduce using rule 9 (const_def -> ID = constant .)


state 42

    (10) constant -> sign . INT
    (12) constant -> sign . REAL

    INT             shift and go to state 81
    REAL            shift and go to state 82


state 43

    (11) constant -> INT .

    ;               reduce using rule 11 (constant -> INT .)
    DOTDOT          reduce using rule 11 (constant -> INT .)
    ]               reduce using rule 11 (constant -> INT .)
    ,               reduce using rule 11 (constant -> INT .)


state 44

    (13) constant -> REAL .

    ;               reduce using rule 13 (constant -> REAL .)
    DOTDOT          reduce using rule 13 (constant -> REAL .)
    ]               reduce using rule 13 (constant -> REAL .)
    ,               reduce using rule 13 (constant -> REAL .)


state 45

    (14) constant -> CHAR .

    ;               reduce using rule 14 (constant -> CHAR .)
    DOTDOT          reduce using rule 14 (constant -> CHAR .)
    ]               reduce using rule 14 (constant -> CHAR .)
    ,               reduce using rule 14 (constant -> CHAR .)


state 46

    (15) constant -> STRING .

    ;               reduce using rule 15 (constant -> STRING .)
    DOTDOT          reduce using rule 15 (constant -> STRING .)
    ]               reduce using rule 15 (constant -> STRING .)
    ,               reduce using rule 15 (constant -> STRING .)


state 47

    (17) constant -> TRUE .

    ;               reduce using rule 17 (constant -> TRUE .)
    DOTDOT          reduce using rule 17 (constant -> TRUE .)
    ]               reduce using rule 17 (constant -> TRUE .)
    ,               reduce using rule 17 (constant -> TRUE .)


state 48

    (18) constant -> FALSE .

    ;               reduce using rule 18 (constant -> FALSE .)
    DOTDOT          reduce using rule 18 (constant -> FALSE .)
    ]               reduce using rule 18 (constant -> FALSE .)
    ,               reduce using rule 18 (constant -> FALSE .)


state 49

    (19) sign -> + .

    INT             reduce using rule 19 (sign -> + .)
    REAL            reduce using rule 19 (sign -> + .)
    CHAR            reduce using rule 19 (sign -> + .)
    STRING          reduce using rule 19 (sign -> + .)
    ID              reduce using rule 19 (sign -> + .)
    (               reduce using rule 19 (sign -> + .)
    NOT             reduce using rule 19 (sign -> + .)
    TRUE            reduce using rule 19 (sign -> + .)
    FALSE           reduce using rule 19 (sign -> + .)


state 50

    (20) sign -> - .

    INT             reduce using rule 20 (sign -> - .)
    REAL            reduce using rule 20 (sign -> - .)
    CHAR            reduce using rule 20 (sign -> - .)
    STRING          reduce using rule 20 (sign -> - .)
    ID              reduce using rule 20 (sign -> - .)
    (               reduce using rule 20 (sign -> - .)
    NOT             reduce using rule 20 (sign -> - .)
    TRUE            reduce using rule 20 (sign -> - .)
    FALSE           reduce using rule 20 (sign -> - .)


state 51

    (27) id_list -> ID , id_list .

    )               reduce using rule 27 (id_list -> ID , id_list .)
    :               reduce using rule 27 (id_list -> ID , id_list .)


state 52

    (92) compound_statement -> BEGIN statement_list . END
    (94) statement_list -> statement_list . ; statement

    END             shift and go to state 83
    ;               shift and go to state 84


state 53

    (93) statement_list -> statement .

    END             reduce using rule 93 (statement_list -> statement .)
    ;               reduce using rule 93 (statement_list -> statement .)


state 54

    (96) statement -> assignment_statement .

    END             reduce using rule 96 (statement -> assignment_statement .)
    ;               reduce using rule 96 (statement -> assignment_statement .)
    ELSE            reduce using rule 96 (statement -> assignment_statement .)


state 55

    (97) statement -> proc_statement .

    END             reduce using rule 97 (statement -> proc_statement .)
    ;               reduce using rule 97 (statement -> proc_statement .)
    ELSE            reduce using rule 97 (statement -> proc_statement .)


state 56

    (98) statement -> read_statement .

    END             reduce using rule 98 (statement -> read_statement .)
    ;               reduce using rule 98 (statement -> read_statement .)
    ELSE            reduce using rule 98 (statement -> read_statement .)


state 57

    (99) statement -> write_statement .

    END             reduce using rule 99 (statement -> write_statement .)
    ;               reduce using rule 99 (statement -> write_statement .)
    ELSE            reduce using rule 99 (statement -> write_statement .)


state 58

    (100) statement -> labeled_statement .

    END             reduce using rule 100 (statement -> labeled_statement .)
    ;               reduce using rule 100 (statement -> labeled_statement .)
    ELSE            reduce using rule 100 (statement -> labeled_statement .)


state 59

    (101) statement -> compound_statement .

    END             reduce using rule 101 (statement -> compound_statement .)
    ;               reduce using rule 101 (statement -> compound_statement .)
    ELSE            reduce using rule 101 (statement -> compound_statement .)


state 60

    (102) statement -> if_statement .

    END             reduce using rule 102 (statement -> if_statement .)
    ;               reduce using rule 102 (statement -> if_statement .)
    ELSE            reduce using rule 102 (statement -> if_statement .)


state 61

    (103) statement -> while_statement .

    END             reduce using rule 103 (statement -> while_statement .)
    ;               reduce using rule 103 (statement -> while_statement .)
    ELSE            reduce using rule 103 (statement -> while_statement .)


state 62

    (104) statement -> for_statement .

    END             reduce using rule 104 (statement -> for_statement .)
    ;               reduce using rule 104 (statement -> for_statement .)
    ELSE            reduce using rule 104 (statement -> for_statement .)


state 63

    (105) assignment_statement -> var_access . ASSIGN expr

    ASSIGN          shift and go to state 85


state 64

    (106) proc_statement -> ID .
    (107) proc_statement -> ID . ( expr_list )
    (54) var_access -> ID . var_suffix
    (55) var_suffix -> .
    (56) var_suffix -> . [ expr_list ] var_suffix

    END             reduce using rule 106 (proc_statement -> ID .)
    ;               reduce using rule 106 (proc_statement -> ID .)
    ELSE            reduce using rule 106 (proc_statement -> ID .)
    (               shift and go to state 86
    ASSIGN          reduce using rule 55 (var_suffix -> .)
    [               shift and go to state 88

    var_suffix                     shift and go to state 87

state 65

    (109) read_statement -> READ . ( var_access_list )

    (               shift and go to state 89


state 66

    (110) read_statement -> READLN .
    (111) read_statement -> READLN . ( var_access_list )

    END             reduce using rule 110 (read_statement -> READLN .)
    ;               reduce using rule 110 (read_statement -> READLN .)
    ELSE            reduce using rule 110 (read_statement -> READLN .)
    (               shift and go to state 90


state 67

    (114) write_statement -> WRITE . ( write_list )

    (               shift and go to state 91


state 68

    (115) write_statement -> WRITELN .
    (116) write_statement -> WRITELN . ( write_list )

    END             reduce using rule 115 (write_statement -> WRITELN .)
    ;               reduce using rule 115 (write_statement -> WRITELN .)
    ELSE            reduce using rule 115 (write_statement -> WRITELN .)
    (               shift and go to state 92


state 69

    (108) labeled_statement -> INT . : statement

    :               shift and go to state 93


state 70

    (122) if_statement -> IF . expr THEN statement
    (123) if_statement -> IF . expr THEN statement ELSE statement
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    expr                           shift and go to state 94
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 71

    (124) while_statement -> WHILE . expr DO statement
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    expr                           shift and go to state 109
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 72

    (125) for_statement -> FOR . ID ASSIGN expr TO expr DO statement
    (126) for_statement -> FOR . ID ASSIGN expr DOWNTO expr DO statement

    ID              shift and go to state 110


state 73

    (24) var_list -> var_list var_dec . ;

    ;               shift and go to state 111


state 74

    (23) var_list -> var_dec ; .

    ID              reduce using rule 23 (var_list -> var_dec ; .)
    BEGIN           reduce using rule 23 (var_list -> var_dec ; .)


state 75

    (25) var_dec -> id_list : . tipo
    (28) tipo -> . ID
    (29) tipo -> . new_type
    (30) new_type -> . enumerated_type
    (31) new_type -> . subrange_type
    (32) new_type -> . array_type
    (33) enumerated_type -> . ( id_list )
    (34) subrange_type -> . constant DOTDOT constant
    (35) array_type -> . ARRAY [ ordinal_type_list ] OF tipo
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) constant -> . TRUE
    (18) constant -> . FALSE
    (19) sign -> . +
    (20) sign -> . -

    ID              shift and go to state 113
    (               shift and go to state 118
    ARRAY           shift and go to state 120
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    +               shift and go to state 49
    -               shift and go to state 50

    tipo                           shift and go to state 112
    new_type                       shift and go to state 114
    enumerated_type                shift and go to state 115
    subrange_type                  shift and go to state 116
    array_type                     shift and go to state 117
    constant                       shift and go to state 119
    sign                           shift and go to state 42

state 76

    (44) proc_dec -> proc_heading ; block . ;

    ;               shift and go to state 121


state 77

    (45) func_dec -> func_heading ; block . ;

    ;               shift and go to state 122


state 78

    (47) proc_heading -> PROCEDURE ID ( . param_list )
    (50) param_list -> . param
    (51) param_list -> . param_list ; param
    (52) param -> . id_list : ID
    (53) param -> . VAR id_list : ID
    (26) id_list -> . ID
    (27) id_list -> . ID , id_list

    VAR             shift and go to state 126
    ID              shift and go to state 15

    param_list                     shift and go to state 123
    param                          shift and go to state 124
    id_list                        shift and go to state 125

state 79

    (48) func_heading -> FUNCTION ID : . ID

    ID              shift and go to state 127


state 80

    (49) func_heading -> FUNCTION ID ( . param_list ) : ID
    (50) param_list -> . param
    (51) param_list -> . param_list ; param
    (52) param -> . id_list : ID
    (53) param -> . VAR id_list : ID
    (26) id_list -> . ID
    (27) id_list -> . ID , id_list

    VAR             shift and go to state 126
    ID              shift and go to state 15

    param_list                     shift and go to state 128
    param                          shift and go to state 124
    id_list                        shift and go to state 125

state 81

    (10) constant -> sign INT .

    ;               reduce using rule 10 (constant -> sign INT .)
    DOTDOT          reduce using rule 10 (constant -> sign INT .)
    ]               reduce using rule 10 (constant -> sign INT .)
    ,               reduce using rule 10 (constant -> sign INT .)


state 82

    (12) constant -> sign REAL .

    ;               reduce using rule 12 (constant -> sign REAL .)
    DOTDOT          reduce using rule 12 (constant -> sign REAL .)
    ]               reduce using rule 12 (constant -> sign REAL .)
    ,               reduce using rule 12 (constant -> sign REAL .)


state 83

    (92) compound_statement -> BEGIN statement_list END .

    .               reduce using rule 92 (compound_statement -> BEGIN statement_list END .)
    ;               reduce using rule 92 (compound_statement -> BEGIN statement_list END .)
    END             reduce using rule 92 (compound_statement -> BEGIN statement_list END .)
    ELSE            reduce using rule 92 (compound_statement -> BEGIN statement_list END .)


state 84

    (94) statement_list -> statement_list ; . statement
    (95) statement -> .
    (96) statement -> . assignment_statement
    (97) statement -> . proc_statement
    (98) statement -> . read_statement
    (99) statement -> . write_statement
    (100) statement -> . labeled_statement
    (101) statement -> . compound_statement
    (102) statement -> . if_statement
    (103) statement -> . while_statement
    (104) statement -> . for_statement
    (105) assignment_statement -> . var_access ASSIGN expr
    (106) proc_statement -> . ID
    (107) proc_statement -> . ID ( expr_list )
    (109) read_statement -> . READ ( var_access_list )
    (110) read_statement -> . READLN
    (111) read_statement -> . READLN ( var_access_list )
    (114) write_statement -> . WRITE ( write_list )
    (115) write_statement -> . WRITELN
    (116) write_statement -> . WRITELN ( write_list )
    (108) labeled_statement -> . INT : statement
    (92) compound_statement -> . BEGIN statement_list END
    (122) if_statement -> . IF expr THEN statement
    (123) if_statement -> . IF expr THEN statement ELSE statement
    (124) while_statement -> . WHILE expr DO statement
    (125) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (126) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID var_suffix

    END             reduce using rule 95 (statement -> .)
    ;               reduce using rule 95 (statement -> .)
    ID              shift and go to state 64
    READ            shift and go to state 65
    READLN          shift and go to state 66
    WRITE           shift and go to state 67
    WRITELN         shift and go to state 68
    INT             shift and go to state 69
    BEGIN           shift and go to state 31
    IF              shift and go to state 70
    WHILE           shift and go to state 71
    FOR             shift and go to state 72

    statement                      shift and go to state 129
    assignment_statement           shift and go to state 54
    proc_statement                 shift and go to state 55
    read_statement                 shift and go to state 56
    write_statement                shift and go to state 57
    labeled_statement              shift and go to state 58
    compound_statement             shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    var_access                     shift and go to state 63

state 85

    (105) assignment_statement -> var_access ASSIGN . expr
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    var_access                     shift and go to state 99
    expr                           shift and go to state 130
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98

state 86

    (107) proc_statement -> ID ( . expr_list )
    (57) expr_list -> . expr
    (58) expr_list -> . expr_list , expr
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    expr_list                      shift and go to state 131
    expr                           shift and go to state 132
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 87

    (54) var_access -> ID var_suffix .

    ASSIGN          reduce using rule 54 (var_access -> ID var_suffix .)
    *               reduce using rule 54 (var_access -> ID var_suffix .)
    /               reduce using rule 54 (var_access -> ID var_suffix .)
    DIV             reduce using rule 54 (var_access -> ID var_suffix .)
    MOD             reduce using rule 54 (var_access -> ID var_suffix .)
    AND             reduce using rule 54 (var_access -> ID var_suffix .)
    +               reduce using rule 54 (var_access -> ID var_suffix .)
    -               reduce using rule 54 (var_access -> ID var_suffix .)
    OR              reduce using rule 54 (var_access -> ID var_suffix .)
    =               reduce using rule 54 (var_access -> ID var_suffix .)
    NE              reduce using rule 54 (var_access -> ID var_suffix .)
    LT              reduce using rule 54 (var_access -> ID var_suffix .)
    GT              reduce using rule 54 (var_access -> ID var_suffix .)
    LE              reduce using rule 54 (var_access -> ID var_suffix .)
    GE              reduce using rule 54 (var_access -> ID var_suffix .)
    THEN            reduce using rule 54 (var_access -> ID var_suffix .)
    DO              reduce using rule 54 (var_access -> ID var_suffix .)
    END             reduce using rule 54 (var_access -> ID var_suffix .)
    ;               reduce using rule 54 (var_access -> ID var_suffix .)
    ELSE            reduce using rule 54 (var_access -> ID var_suffix .)
    )               reduce using rule 54 (var_access -> ID var_suffix .)
    ,               reduce using rule 54 (var_access -> ID var_suffix .)
    ]               reduce using rule 54 (var_access -> ID var_suffix .)
    :               reduce using rule 54 (var_access -> ID var_suffix .)
    TO              reduce using rule 54 (var_access -> ID var_suffix .)
    DOWNTO          reduce using rule 54 (var_access -> ID var_suffix .)


state 88

    (56) var_suffix -> [ . expr_list ] var_suffix
    (57) expr_list -> . expr
    (58) expr_list -> . expr_list , expr
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    expr_list                      shift and go to state 133
    expr                           shift and go to state 132
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 89

    (109) read_statement -> READ ( . var_access_list )
    (112) var_access_list -> . var_access
    (113) var_access_list -> . var_access_list , var_access
    (54) var_access -> . ID var_suffix

    ID              shift and go to state 136

    var_access_list                shift and go to state 134
    var_access                     shift and go to state 135

state 90

    (111) read_statement -> READLN ( . var_access_list )
    (112) var_access_list -> . var_access
    (113) var_access_list -> . var_access_list , var_access
    (54) var_access -> . ID var_suffix

    ID              shift and go to state 136

    var_access_list                shift and go to state 137
    var_access                     shift and go to state 135

state 91

    (114) write_statement -> WRITE ( . write_list )
    (117) write_list -> . write_param
    (118) write_list -> . write_list , write_param
    (119) write_param -> . expr
    (120) write_param -> . expr : expr
    (121) write_param -> . expr : expr : expr
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    write_list                     shift and go to state 138
    write_param                    shift and go to state 139
    expr                           shift and go to state 140
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 92

    (116) write_statement -> WRITELN ( . write_list )
    (117) write_list -> . write_param
    (118) write_list -> . write_list , write_param
    (119) write_param -> . expr
    (120) write_param -> . expr : expr
    (121) write_param -> . expr : expr : expr
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    write_list                     shift and go to state 141
    write_param                    shift and go to state 139
    expr                           shift and go to state 140
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 93

    (108) labeled_statement -> INT : . statement
    (95) statement -> .
    (96) statement -> . assignment_statement
    (97) statement -> . proc_statement
    (98) statement -> . read_statement
    (99) statement -> . write_statement
    (100) statement -> . labeled_statement
    (101) statement -> . compound_statement
    (102) statement -> . if_statement
    (103) statement -> . while_statement
    (104) statement -> . for_statement
    (105) assignment_statement -> . var_access ASSIGN expr
    (106) proc_statement -> . ID
    (107) proc_statement -> . ID ( expr_list )
    (109) read_statement -> . READ ( var_access_list )
    (110) read_statement -> . READLN
    (111) read_statement -> . READLN ( var_access_list )
    (114) write_statement -> . WRITE ( write_list )
    (115) write_statement -> . WRITELN
    (116) write_statement -> . WRITELN ( write_list )
    (108) labeled_statement -> . INT : statement
    (92) compound_statement -> . BEGIN statement_list END
    (122) if_statement -> . IF expr THEN statement
    (123) if_statement -> . IF expr THEN statement ELSE statement
    (124) while_statement -> . WHILE expr DO statement
    (125) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (126) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID var_suffix

    END             reduce using rule 95 (statement -> .)
    ;               reduce using rule 95 (statement -> .)
    ELSE            reduce using rule 95 (statement -> .)
    ID              shift and go to state 64
    READ            shift and go to state 65
    READLN          shift and go to state 66
    WRITE           shift and go to state 67
    WRITELN         shift and go to state 68
    INT             shift and go to state 69
    BEGIN           shift and go to state 31
    IF              shift and go to state 70
    WHILE           shift and go to state 71
    FOR             shift and go to state 72

    statement                      shift and go to state 142
    assignment_statement           shift and go to state 54
    proc_statement                 shift and go to state 55
    read_statement                 shift and go to state 56
    write_statement                shift and go to state 57
    labeled_statement              shift and go to state 58
    compound_statement             shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    var_access                     shift and go to state 63

state 94

    (122) if_statement -> IF expr . THEN statement
    (123) if_statement -> IF expr . THEN statement ELSE statement

    THEN            shift and go to state 143


state 95

    (59) expr -> simple_expr .
    (60) expr -> simple_expr . relation_op simple_expr
    (86) relation_op -> . =
    (87) relation_op -> . NE
    (88) relation_op -> . LT
    (89) relation_op -> . GT
    (90) relation_op -> . LE
    (91) relation_op -> . GE

    THEN            reduce using rule 59 (expr -> simple_expr .)
    DO              reduce using rule 59 (expr -> simple_expr .)
    END             reduce using rule 59 (expr -> simple_expr .)
    ;               reduce using rule 59 (expr -> simple_expr .)
    ELSE            reduce using rule 59 (expr -> simple_expr .)
    )               reduce using rule 59 (expr -> simple_expr .)
    ,               reduce using rule 59 (expr -> simple_expr .)
    ]               reduce using rule 59 (expr -> simple_expr .)
    :               reduce using rule 59 (expr -> simple_expr .)
    TO              reduce using rule 59 (expr -> simple_expr .)
    DOWNTO          reduce using rule 59 (expr -> simple_expr .)
    =               shift and go to state 145
    NE              shift and go to state 146
    LT              shift and go to state 147
    GT              shift and go to state 148
    LE              shift and go to state 149
    GE              shift and go to state 150

    relation_op                    shift and go to state 144

state 96

    (61) simple_expr -> term . term_sequence
    (64) term_sequence -> .
    (65) term_sequence -> . add_op term term_sequence
    (78) add_op -> . +
    (79) add_op -> . -
    (80) add_op -> . OR

    =               reduce using rule 64 (term_sequence -> .)
    NE              reduce using rule 64 (term_sequence -> .)
    LT              reduce using rule 64 (term_sequence -> .)
    GT              reduce using rule 64 (term_sequence -> .)
    LE              reduce using rule 64 (term_sequence -> .)
    GE              reduce using rule 64 (term_sequence -> .)
    THEN            reduce using rule 64 (term_sequence -> .)
    DO              reduce using rule 64 (term_sequence -> .)
    END             reduce using rule 64 (term_sequence -> .)
    ;               reduce using rule 64 (term_sequence -> .)
    ELSE            reduce using rule 64 (term_sequence -> .)
    )               reduce using rule 64 (term_sequence -> .)
    ,               reduce using rule 64 (term_sequence -> .)
    ]               reduce using rule 64 (term_sequence -> .)
    :               reduce using rule 64 (term_sequence -> .)
    TO              reduce using rule 64 (term_sequence -> .)
    DOWNTO          reduce using rule 64 (term_sequence -> .)
    +               shift and go to state 153
    -               shift and go to state 154
    OR              shift and go to state 155

    term_sequence                  shift and go to state 151
    add_op                         shift and go to state 152

state 97

    (62) simple_expr -> sign . term term_sequence
    (63) term -> . factor factor_sequence
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    term                           shift and go to state 156
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 98

    (63) term -> factor . factor_sequence
    (66) factor_sequence -> .
    (67) factor_sequence -> . mul_op factor factor_sequence
    (81) mul_op -> . *
    (82) mul_op -> . /
    (83) mul_op -> . DIV
    (84) mul_op -> . MOD
    (85) mul_op -> . AND

    +               reduce using rule 66 (factor_sequence -> .)
    -               reduce using rule 66 (factor_sequence -> .)
    OR              reduce using rule 66 (factor_sequence -> .)
    =               reduce using rule 66 (factor_sequence -> .)
    NE              reduce using rule 66 (factor_sequence -> .)
    LT              reduce using rule 66 (factor_sequence -> .)
    GT              reduce using rule 66 (factor_sequence -> .)
    LE              reduce using rule 66 (factor_sequence -> .)
    GE              reduce using rule 66 (factor_sequence -> .)
    THEN            reduce using rule 66 (factor_sequence -> .)
    DO              reduce using rule 66 (factor_sequence -> .)
    END             reduce using rule 66 (factor_sequence -> .)
    ;               reduce using rule 66 (factor_sequence -> .)
    ELSE            reduce using rule 66 (factor_sequence -> .)
    )               reduce using rule 66 (factor_sequence -> .)
    ,               reduce using rule 66 (factor_sequence -> .)
    ]               reduce using rule 66 (factor_sequence -> .)
    :               reduce using rule 66 (factor_sequence -> .)
    TO              reduce using rule 66 (factor_sequence -> .)
    DOWNTO          reduce using rule 66 (factor_sequence -> .)
    *               shift and go to state 159
    /               shift and go to state 160
    DIV             shift and go to state 161
    MOD             shift and go to state 162
    AND             shift and go to state 163

    factor_sequence                shift and go to state 157
    mul_op                         shift and go to state 158

state 99

    (68) factor -> var_access .

    *               reduce using rule 68 (factor -> var_access .)
    /               reduce using rule 68 (factor -> var_access .)
    DIV             reduce using rule 68 (factor -> var_access .)
    MOD             reduce using rule 68 (factor -> var_access .)
    AND             reduce using rule 68 (factor -> var_access .)
    +               reduce using rule 68 (factor -> var_access .)
    -               reduce using rule 68 (factor -> var_access .)
    OR              reduce using rule 68 (factor -> var_access .)
    =               reduce using rule 68 (factor -> var_access .)
    NE              reduce using rule 68 (factor -> var_access .)
    LT              reduce using rule 68 (factor -> var_access .)
    GT              reduce using rule 68 (factor -> var_access .)
    LE              reduce using rule 68 (factor -> var_access .)
    GE              reduce using rule 68 (factor -> var_access .)
    THEN            reduce using rule 68 (factor -> var_access .)
    DO              reduce using rule 68 (factor -> var_access .)
    END             reduce using rule 68 (factor -> var_access .)
    ;               reduce using rule 68 (factor -> var_access .)
    ELSE            reduce using rule 68 (factor -> var_access .)
    )               reduce using rule 68 (factor -> var_access .)
    ,               reduce using rule 68 (factor -> var_access .)
    ]               reduce using rule 68 (factor -> var_access .)
    :               reduce using rule 68 (factor -> var_access .)
    TO              reduce using rule 68 (factor -> var_access .)
    DOWNTO          reduce using rule 68 (factor -> var_access .)


state 100

    (69) factor -> INT .

    *               reduce using rule 69 (factor -> INT .)
    /               reduce using rule 69 (factor -> INT .)
    DIV             reduce using rule 69 (factor -> INT .)
    MOD             reduce using rule 69 (factor -> INT .)
    AND             reduce using rule 69 (factor -> INT .)
    +               reduce using rule 69 (factor -> INT .)
    -               reduce using rule 69 (factor -> INT .)
    OR              reduce using rule 69 (factor -> INT .)
    =               reduce using rule 69 (factor -> INT .)
    NE              reduce using rule 69 (factor -> INT .)
    LT              reduce using rule 69 (factor -> INT .)
    GT              reduce using rule 69 (factor -> INT .)
    LE              reduce using rule 69 (factor -> INT .)
    GE              reduce using rule 69 (factor -> INT .)
    THEN            reduce using rule 69 (factor -> INT .)
    DO              reduce using rule 69 (factor -> INT .)
    END             reduce using rule 69 (factor -> INT .)
    ;               reduce using rule 69 (factor -> INT .)
    ELSE            reduce using rule 69 (factor -> INT .)
    )               reduce using rule 69 (factor -> INT .)
    ,               reduce using rule 69 (factor -> INT .)
    ]               reduce using rule 69 (factor -> INT .)
    :               reduce using rule 69 (factor -> INT .)
    TO              reduce using rule 69 (factor -> INT .)
    DOWNTO          reduce using rule 69 (factor -> INT .)


state 101

    (70) factor -> REAL .

    *               reduce using rule 70 (factor -> REAL .)
    /               reduce using rule 70 (factor -> REAL .)
    DIV             reduce using rule 70 (factor -> REAL .)
    MOD             reduce using rule 70 (factor -> REAL .)
    AND             reduce using rule 70 (factor -> REAL .)
    +               reduce using rule 70 (factor -> REAL .)
    -               reduce using rule 70 (factor -> REAL .)
    OR              reduce using rule 70 (factor -> REAL .)
    =               reduce using rule 70 (factor -> REAL .)
    NE              reduce using rule 70 (factor -> REAL .)
    LT              reduce using rule 70 (factor -> REAL .)
    GT              reduce using rule 70 (factor -> REAL .)
    LE              reduce using rule 70 (factor -> REAL .)
    GE              reduce using rule 70 (factor -> REAL .)
    THEN            reduce using rule 70 (factor -> REAL .)
    DO              reduce using rule 70 (factor -> REAL .)
    END             reduce using rule 70 (factor -> REAL .)
    ;               reduce using rule 70 (factor -> REAL .)
    ELSE            reduce using rule 70 (factor -> REAL .)
    )               reduce using rule 70 (factor -> REAL .)
    ,               reduce using rule 70 (factor -> REAL .)
    ]               reduce using rule 70 (factor -> REAL .)
    :               reduce using rule 70 (factor -> REAL .)
    TO              reduce using rule 70 (factor -> REAL .)
    DOWNTO          reduce using rule 70 (factor -> REAL .)


state 102

    (71) factor -> CHAR .

    *               reduce using rule 71 (factor -> CHAR .)
    /               reduce using rule 71 (factor -> CHAR .)
    DIV             reduce using rule 71 (factor -> CHAR .)
    MOD             reduce using rule 71 (factor -> CHAR .)
    AND             reduce using rule 71 (factor -> CHAR .)
    +               reduce using rule 71 (factor -> CHAR .)
    -               reduce using rule 71 (factor -> CHAR .)
    OR              reduce using rule 71 (factor -> CHAR .)
    =               reduce using rule 71 (factor -> CHAR .)
    NE              reduce using rule 71 (factor -> CHAR .)
    LT              reduce using rule 71 (factor -> CHAR .)
    GT              reduce using rule 71 (factor -> CHAR .)
    LE              reduce using rule 71 (factor -> CHAR .)
    GE              reduce using rule 71 (factor -> CHAR .)
    THEN            reduce using rule 71 (factor -> CHAR .)
    DO              reduce using rule 71 (factor -> CHAR .)
    END             reduce using rule 71 (factor -> CHAR .)
    ;               reduce using rule 71 (factor -> CHAR .)
    ELSE            reduce using rule 71 (factor -> CHAR .)
    )               reduce using rule 71 (factor -> CHAR .)
    ,               reduce using rule 71 (factor -> CHAR .)
    ]               reduce using rule 71 (factor -> CHAR .)
    :               reduce using rule 71 (factor -> CHAR .)
    TO              reduce using rule 71 (factor -> CHAR .)
    DOWNTO          reduce using rule 71 (factor -> CHAR .)


state 103

    (72) factor -> STRING .

    *               reduce using rule 72 (factor -> STRING .)
    /               reduce using rule 72 (factor -> STRING .)
    DIV             reduce using rule 72 (factor -> STRING .)
    MOD             reduce using rule 72 (factor -> STRING .)
    AND             reduce using rule 72 (factor -> STRING .)
    +               reduce using rule 72 (factor -> STRING .)
    -               reduce using rule 72 (factor -> STRING .)
    OR              reduce using rule 72 (factor -> STRING .)
    =               reduce using rule 72 (factor -> STRING .)
    NE              reduce using rule 72 (factor -> STRING .)
    LT              reduce using rule 72 (factor -> STRING .)
    GT              reduce using rule 72 (factor -> STRING .)
    LE              reduce using rule 72 (factor -> STRING .)
    GE              reduce using rule 72 (factor -> STRING .)
    THEN            reduce using rule 72 (factor -> STRING .)
    DO              reduce using rule 72 (factor -> STRING .)
    END             reduce using rule 72 (factor -> STRING .)
    ;               reduce using rule 72 (factor -> STRING .)
    ELSE            reduce using rule 72 (factor -> STRING .)
    )               reduce using rule 72 (factor -> STRING .)
    ,               reduce using rule 72 (factor -> STRING .)
    ]               reduce using rule 72 (factor -> STRING .)
    :               reduce using rule 72 (factor -> STRING .)
    TO              reduce using rule 72 (factor -> STRING .)
    DOWNTO          reduce using rule 72 (factor -> STRING .)


state 104

    (73) factor -> ID . ( expr_list )
    (54) var_access -> ID . var_suffix
    (55) var_suffix -> .
    (56) var_suffix -> . [ expr_list ] var_suffix

    (               shift and go to state 164
    *               reduce using rule 55 (var_suffix -> .)
    /               reduce using rule 55 (var_suffix -> .)
    DIV             reduce using rule 55 (var_suffix -> .)
    MOD             reduce using rule 55 (var_suffix -> .)
    AND             reduce using rule 55 (var_suffix -> .)
    +               reduce using rule 55 (var_suffix -> .)
    -               reduce using rule 55 (var_suffix -> .)
    OR              reduce using rule 55 (var_suffix -> .)
    =               reduce using rule 55 (var_suffix -> .)
    NE              reduce using rule 55 (var_suffix -> .)
    LT              reduce using rule 55 (var_suffix -> .)
    GT              reduce using rule 55 (var_suffix -> .)
    LE              reduce using rule 55 (var_suffix -> .)
    GE              reduce using rule 55 (var_suffix -> .)
    THEN            reduce using rule 55 (var_suffix -> .)
    DO              reduce using rule 55 (var_suffix -> .)
    END             reduce using rule 55 (var_suffix -> .)
    ;               reduce using rule 55 (var_suffix -> .)
    ELSE            reduce using rule 55 (var_suffix -> .)
    )               reduce using rule 55 (var_suffix -> .)
    ,               reduce using rule 55 (var_suffix -> .)
    ]               reduce using rule 55 (var_suffix -> .)
    :               reduce using rule 55 (var_suffix -> .)
    TO              reduce using rule 55 (var_suffix -> .)
    DOWNTO          reduce using rule 55 (var_suffix -> .)
    [               shift and go to state 88

    var_suffix                     shift and go to state 87

state 105

    (74) factor -> ( . expr )
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    expr                           shift and go to state 165
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 106

    (75) factor -> NOT . factor
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    factor                         shift and go to state 166
    var_access                     shift and go to state 99

state 107

    (76) factor -> TRUE .

    *               reduce using rule 76 (factor -> TRUE .)
    /               reduce using rule 76 (factor -> TRUE .)
    DIV             reduce using rule 76 (factor -> TRUE .)
    MOD             reduce using rule 76 (factor -> TRUE .)
    AND             reduce using rule 76 (factor -> TRUE .)
    +               reduce using rule 76 (factor -> TRUE .)
    -               reduce using rule 76 (factor -> TRUE .)
    OR              reduce using rule 76 (factor -> TRUE .)
    =               reduce using rule 76 (factor -> TRUE .)
    NE              reduce using rule 76 (factor -> TRUE .)
    LT              reduce using rule 76 (factor -> TRUE .)
    GT              reduce using rule 76 (factor -> TRUE .)
    LE              reduce using rule 76 (factor -> TRUE .)
    GE              reduce using rule 76 (factor -> TRUE .)
    THEN            reduce using rule 76 (factor -> TRUE .)
    DO              reduce using rule 76 (factor -> TRUE .)
    END             reduce using rule 76 (factor -> TRUE .)
    ;               reduce using rule 76 (factor -> TRUE .)
    ELSE            reduce using rule 76 (factor -> TRUE .)
    )               reduce using rule 76 (factor -> TRUE .)
    ,               reduce using rule 76 (factor -> TRUE .)
    ]               reduce using rule 76 (factor -> TRUE .)
    :               reduce using rule 76 (factor -> TRUE .)
    TO              reduce using rule 76 (factor -> TRUE .)
    DOWNTO          reduce using rule 76 (factor -> TRUE .)


state 108

    (77) factor -> FALSE .

    *               reduce using rule 77 (factor -> FALSE .)
    /               reduce using rule 77 (factor -> FALSE .)
    DIV             reduce using rule 77 (factor -> FALSE .)
    MOD             reduce using rule 77 (factor -> FALSE .)
    AND             reduce using rule 77 (factor -> FALSE .)
    +               reduce using rule 77 (factor -> FALSE .)
    -               reduce using rule 77 (factor -> FALSE .)
    OR              reduce using rule 77 (factor -> FALSE .)
    =               reduce using rule 77 (factor -> FALSE .)
    NE              reduce using rule 77 (factor -> FALSE .)
    LT              reduce using rule 77 (factor -> FALSE .)
    GT              reduce using rule 77 (factor -> FALSE .)
    LE              reduce using rule 77 (factor -> FALSE .)
    GE              reduce using rule 77 (factor -> FALSE .)
    THEN            reduce using rule 77 (factor -> FALSE .)
    DO              reduce using rule 77 (factor -> FALSE .)
    END             reduce using rule 77 (factor -> FALSE .)
    ;               reduce using rule 77 (factor -> FALSE .)
    ELSE            reduce using rule 77 (factor -> FALSE .)
    )               reduce using rule 77 (factor -> FALSE .)
    ,               reduce using rule 77 (factor -> FALSE .)
    ]               reduce using rule 77 (factor -> FALSE .)
    :               reduce using rule 77 (factor -> FALSE .)
    TO              reduce using rule 77 (factor -> FALSE .)
    DOWNTO          reduce using rule 77 (factor -> FALSE .)


state 109

    (124) while_statement -> WHILE expr . DO statement

    DO              shift and go to state 167


state 110

    (125) for_statement -> FOR ID . ASSIGN expr TO expr DO statement
    (126) for_statement -> FOR ID . ASSIGN expr DOWNTO expr DO statement

    ASSIGN          shift and go to state 168


state 111

    (24) var_list -> var_list var_dec ; .

    ID              reduce using rule 24 (var_list -> var_list var_dec ; .)
    BEGIN           reduce using rule 24 (var_list -> var_list var_dec ; .)


state 112

    (25) var_dec -> id_list : tipo .

    ;               reduce using rule 25 (var_dec -> id_list : tipo .)


state 113

    (28) tipo -> ID .
    (16) constant -> ID .

    ;               reduce using rule 28 (tipo -> ID .)
    DOTDOT          reduce using rule 16 (constant -> ID .)


state 114

    (29) tipo -> new_type .

    ;               reduce using rule 29 (tipo -> new_type .)


state 115

    (30) new_type -> enumerated_type .

    ;               reduce using rule 30 (new_type -> enumerated_type .)


state 116

    (31) new_type -> subrange_type .

    ;               reduce using rule 31 (new_type -> subrange_type .)


state 117

    (32) new_type -> array_type .

    ;               reduce using rule 32 (new_type -> array_type .)


state 118

    (33) enumerated_type -> ( . id_list )
    (26) id_list -> . ID
    (27) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 169

state 119

    (34) subrange_type -> constant . DOTDOT constant

    DOTDOT          shift and go to state 170


state 120

    (35) array_type -> ARRAY . [ ordinal_type_list ] OF tipo

    [               shift and go to state 171


state 121

    (44) proc_dec -> proc_heading ; block ; .

    VAR             reduce using rule 44 (proc_dec -> proc_heading ; block ; .)
    PROCEDURE       reduce using rule 44 (proc_dec -> proc_heading ; block ; .)
    FUNCTION        reduce using rule 44 (proc_dec -> proc_heading ; block ; .)
    BEGIN           reduce using rule 44 (proc_dec -> proc_heading ; block ; .)


state 122

    (45) func_dec -> func_heading ; block ; .

    VAR             reduce using rule 45 (func_dec -> func_heading ; block ; .)
    PROCEDURE       reduce using rule 45 (func_dec -> func_heading ; block ; .)
    FUNCTION        reduce using rule 45 (func_dec -> func_heading ; block ; .)
    BEGIN           reduce using rule 45 (func_dec -> func_heading ; block ; .)


state 123

    (47) proc_heading -> PROCEDURE ID ( param_list . )
    (51) param_list -> param_list . ; param

    )               shift and go to state 172
    ;               shift and go to state 173


state 124

    (50) param_list -> param .

    )               reduce using rule 50 (param_list -> param .)
    ;               reduce using rule 50 (param_list -> param .)


state 125

    (52) param -> id_list . : ID

    :               shift and go to state 174


state 126

    (53) param -> VAR . id_list : ID
    (26) id_list -> . ID
    (27) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 175

state 127

    (48) func_heading -> FUNCTION ID : ID .

    ;               reduce using rule 48 (func_heading -> FUNCTION ID : ID .)


state 128

    (49) func_heading -> FUNCTION ID ( param_list . ) : ID
    (51) param_list -> param_list . ; param

    )               shift and go to state 176
    ;               shift and go to state 173


state 129

    (94) statement_list -> statement_list ; statement .

    END             reduce using rule 94 (statement_list -> statement_list ; statement .)
    ;               reduce using rule 94 (statement_list -> statement_list ; statement .)


state 130

    (105) assignment_statement -> var_access ASSIGN expr .

    END             reduce using rule 105 (assignment_statement -> var_access ASSIGN expr .)
    ;               reduce using rule 105 (assignment_statement -> var_access ASSIGN expr .)
    ELSE            reduce using rule 105 (assignment_statement -> var_access ASSIGN expr .)


state 131

    (107) proc_statement -> ID ( expr_list . )
    (58) expr_list -> expr_list . , expr

    )               shift and go to state 177
    ,               shift and go to state 178


state 132

    (57) expr_list -> expr .

    )               reduce using rule 57 (expr_list -> expr .)
    ,               reduce using rule 57 (expr_list -> expr .)
    ]               reduce using rule 57 (expr_list -> expr .)


state 133

    (56) var_suffix -> [ expr_list . ] var_suffix
    (58) expr_list -> expr_list . , expr

    ]               shift and go to state 179
    ,               shift and go to state 178


state 134

    (109) read_statement -> READ ( var_access_list . )
    (113) var_access_list -> var_access_list . , var_access

    )               shift and go to state 180
    ,               shift and go to state 181


state 135

    (112) var_access_list -> var_access .

    )               reduce using rule 112 (var_access_list -> var_access .)
    ,               reduce using rule 112 (var_access_list -> var_access .)


state 136

    (54) var_access -> ID . var_suffix
    (55) var_suffix -> .
    (56) var_suffix -> . [ expr_list ] var_suffix

    )               reduce using rule 55 (var_suffix -> .)
    ,               reduce using rule 55 (var_suffix -> .)
    [               shift and go to state 88

    var_suffix                     shift and go to state 87

state 137

    (111) read_statement -> READLN ( var_access_list . )
    (113) var_access_list -> var_access_list . , var_access

    )               shift and go to state 182
    ,               shift and go to state 181


state 138

    (114) write_statement -> WRITE ( write_list . )
    (118) write_list -> write_list . , write_param

    )               shift and go to state 183
    ,               shift and go to state 184


state 139

    (117) write_list -> write_param .

    )               reduce using rule 117 (write_list -> write_param .)
    ,               reduce using rule 117 (write_list -> write_param .)


state 140

    (119) write_param -> expr .
    (120) write_param -> expr . : expr
    (121) write_param -> expr . : expr : expr

    )               reduce using rule 119 (write_param -> expr .)
    ,               reduce using rule 119 (write_param -> expr .)
    :               shift and go to state 185


state 141

    (116) write_statement -> WRITELN ( write_list . )
    (118) write_list -> write_list . , write_param

    )               shift and go to state 186
    ,               shift and go to state 184


state 142

    (108) labeled_statement -> INT : statement .

    END             reduce using rule 108 (labeled_statement -> INT : statement .)
    ;               reduce using rule 108 (labeled_statement -> INT : statement .)
    ELSE            reduce using rule 108 (labeled_statement -> INT : statement .)


state 143

    (122) if_statement -> IF expr THEN . statement
    (123) if_statement -> IF expr THEN . statement ELSE statement
    (95) statement -> .
    (96) statement -> . assignment_statement
    (97) statement -> . proc_statement
    (98) statement -> . read_statement
    (99) statement -> . write_statement
    (100) statement -> . labeled_statement
    (101) statement -> . compound_statement
    (102) statement -> . if_statement
    (103) statement -> . while_statement
    (104) statement -> . for_statement
    (105) assignment_statement -> . var_access ASSIGN expr
    (106) proc_statement -> . ID
    (107) proc_statement -> . ID ( expr_list )
    (109) read_statement -> . READ ( var_access_list )
    (110) read_statement -> . READLN
    (111) read_statement -> . READLN ( var_access_list )
    (114) write_statement -> . WRITE ( write_list )
    (115) write_statement -> . WRITELN
    (116) write_statement -> . WRITELN ( write_list )
    (108) labeled_statement -> . INT : statement
    (92) compound_statement -> . BEGIN statement_list END
    (122) if_statement -> . IF expr THEN statement
    (123) if_statement -> . IF expr THEN statement ELSE statement
    (124) while_statement -> . WHILE expr DO statement
    (125) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (126) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID var_suffix

    END             reduce using rule 95 (statement -> .)
    ;               reduce using rule 95 (statement -> .)
    ELSE            reduce using rule 95 (statement -> .)
    ID              shift and go to state 64
    READ            shift and go to state 65
    READLN          shift and go to state 66
    WRITE           shift and go to state 67
    WRITELN         shift and go to state 68
    INT             shift and go to state 69
    BEGIN           shift and go to state 31
    IF              shift and go to state 70
    WHILE           shift and go to state 71
    FOR             shift and go to state 72

    statement                      shift and go to state 187
    assignment_statement           shift and go to state 54
    proc_statement                 shift and go to state 55
    read_statement                 shift and go to state 56
    write_statement                shift and go to state 57
    labeled_statement              shift and go to state 58
    compound_statement             shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    var_access                     shift and go to state 63

state 144

    (60) expr -> simple_expr relation_op . simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    simple_expr                    shift and go to state 188
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 145

    (86) relation_op -> = .

    +               reduce using rule 86 (relation_op -> = .)
    -               reduce using rule 86 (relation_op -> = .)
    INT             reduce using rule 86 (relation_op -> = .)
    REAL            reduce using rule 86 (relation_op -> = .)
    CHAR            reduce using rule 86 (relation_op -> = .)
    STRING          reduce using rule 86 (relation_op -> = .)
    ID              reduce using rule 86 (relation_op -> = .)
    (               reduce using rule 86 (relation_op -> = .)
    NOT             reduce using rule 86 (relation_op -> = .)
    TRUE            reduce using rule 86 (relation_op -> = .)
    FALSE           reduce using rule 86 (relation_op -> = .)


state 146

    (87) relation_op -> NE .

    +               reduce using rule 87 (relation_op -> NE .)
    -               reduce using rule 87 (relation_op -> NE .)
    INT             reduce using rule 87 (relation_op -> NE .)
    REAL            reduce using rule 87 (relation_op -> NE .)
    CHAR            reduce using rule 87 (relation_op -> NE .)
    STRING          reduce using rule 87 (relation_op -> NE .)
    ID              reduce using rule 87 (relation_op -> NE .)
    (               reduce using rule 87 (relation_op -> NE .)
    NOT             reduce using rule 87 (relation_op -> NE .)
    TRUE            reduce using rule 87 (relation_op -> NE .)
    FALSE           reduce using rule 87 (relation_op -> NE .)


state 147

    (88) relation_op -> LT .

    +               reduce using rule 88 (relation_op -> LT .)
    -               reduce using rule 88 (relation_op -> LT .)
    INT             reduce using rule 88 (relation_op -> LT .)
    REAL            reduce using rule 88 (relation_op -> LT .)
    CHAR            reduce using rule 88 (relation_op -> LT .)
    STRING          reduce using rule 88 (relation_op -> LT .)
    ID              reduce using rule 88 (relation_op -> LT .)
    (               reduce using rule 88 (relation_op -> LT .)
    NOT             reduce using rule 88 (relation_op -> LT .)
    TRUE            reduce using rule 88 (relation_op -> LT .)
    FALSE           reduce using rule 88 (relation_op -> LT .)


state 148

    (89) relation_op -> GT .

    +               reduce using rule 89 (relation_op -> GT .)
    -               reduce using rule 89 (relation_op -> GT .)
    INT             reduce using rule 89 (relation_op -> GT .)
    REAL            reduce using rule 89 (relation_op -> GT .)
    CHAR            reduce using rule 89 (relation_op -> GT .)
    STRING          reduce using rule 89 (relation_op -> GT .)
    ID              reduce using rule 89 (relation_op -> GT .)
    (               reduce using rule 89 (relation_op -> GT .)
    NOT             reduce using rule 89 (relation_op -> GT .)
    TRUE            reduce using rule 89 (relation_op -> GT .)
    FALSE           reduce using rule 89 (relation_op -> GT .)


state 149

    (90) relation_op -> LE .

    +               reduce using rule 90 (relation_op -> LE .)
    -               reduce using rule 90 (relation_op -> LE .)
    INT             reduce using rule 90 (relation_op -> LE .)
    REAL            reduce using rule 90 (relation_op -> LE .)
    CHAR            reduce using rule 90 (relation_op -> LE .)
    STRING          reduce using rule 90 (relation_op -> LE .)
    ID              reduce using rule 90 (relation_op -> LE .)
    (               reduce using rule 90 (relation_op -> LE .)
    NOT             reduce using rule 90 (relation_op -> LE .)
    TRUE            reduce using rule 90 (relation_op -> LE .)
    FALSE           reduce using rule 90 (relation_op -> LE .)


state 150

    (91) relation_op -> GE .

    +               reduce using rule 91 (relation_op -> GE .)
    -               reduce using rule 91 (relation_op -> GE .)
    INT             reduce using rule 91 (relation_op -> GE .)
    REAL            reduce using rule 91 (relation_op -> GE .)
    CHAR            reduce using rule 91 (relation_op -> GE .)
    STRING          reduce using rule 91 (relation_op -> GE .)
    ID              reduce using rule 91 (relation_op -> GE .)
    (               reduce using rule 91 (relation_op -> GE .)
    NOT             reduce using rule 91 (relation_op -> GE .)
    TRUE            reduce using rule 91 (relation_op -> GE .)
    FALSE           reduce using rule 91 (relation_op -> GE .)


state 151

    (61) simple_expr -> term term_sequence .

    =               reduce using rule 61 (simple_expr -> term term_sequence .)
    NE              reduce using rule 61 (simple_expr -> term term_sequence .)
    LT              reduce using rule 61 (simple_expr -> term term_sequence .)
    GT              reduce using rule 61 (simple_expr -> term term_sequence .)
    LE              reduce using rule 61 (simple_expr -> term term_sequence .)
    GE              reduce using rule 61 (simple_expr -> term term_sequence .)
    THEN            reduce using rule 61 (simple_expr -> term term_sequence .)
    DO              reduce using rule 61 (simple_expr -> term term_sequence .)
    END             reduce using rule 61 (simple_expr -> term term_sequence .)
    ;               reduce using rule 61 (simple_expr -> term term_sequence .)
    ELSE            reduce using rule 61 (simple_expr -> term term_sequence .)
    )               reduce using rule 61 (simple_expr -> term term_sequence .)
    ,               reduce using rule 61 (simple_expr -> term term_sequence .)
    ]               reduce using rule 61 (simple_expr -> term term_sequence .)
    :               reduce using rule 61 (simple_expr -> term term_sequence .)
    TO              reduce using rule 61 (simple_expr -> term term_sequence .)
    DOWNTO          reduce using rule 61 (simple_expr -> term term_sequence .)


state 152

    (65) term_sequence -> add_op . term term_sequence
    (63) term -> . factor factor_sequence
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    term                           shift and go to state 189
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 153

    (78) add_op -> + .

    INT             reduce using rule 78 (add_op -> + .)
    REAL            reduce using rule 78 (add_op -> + .)
    CHAR            reduce using rule 78 (add_op -> + .)
    STRING          reduce using rule 78 (add_op -> + .)
    ID              reduce using rule 78 (add_op -> + .)
    (               reduce using rule 78 (add_op -> + .)
    NOT             reduce using rule 78 (add_op -> + .)
    TRUE            reduce using rule 78 (add_op -> + .)
    FALSE           reduce using rule 78 (add_op -> + .)


state 154

    (79) add_op -> - .

    INT             reduce using rule 79 (add_op -> - .)
    REAL            reduce using rule 79 (add_op -> - .)
    CHAR            reduce using rule 79 (add_op -> - .)
    STRING          reduce using rule 79 (add_op -> - .)
    ID              reduce using rule 79 (add_op -> - .)
    (               reduce using rule 79 (add_op -> - .)
    NOT             reduce using rule 79 (add_op -> - .)
    TRUE            reduce using rule 79 (add_op -> - .)
    FALSE           reduce using rule 79 (add_op -> - .)


state 155

    (80) add_op -> OR .

    INT             reduce using rule 80 (add_op -> OR .)
    REAL            reduce using rule 80 (add_op -> OR .)
    CHAR            reduce using rule 80 (add_op -> OR .)
    STRING          reduce using rule 80 (add_op -> OR .)
    ID              reduce using rule 80 (add_op -> OR .)
    (               reduce using rule 80 (add_op -> OR .)
    NOT             reduce using rule 80 (add_op -> OR .)
    TRUE            reduce using rule 80 (add_op -> OR .)
    FALSE           reduce using rule 80 (add_op -> OR .)


state 156

    (62) simple_expr -> sign term . term_sequence
    (64) term_sequence -> .
    (65) term_sequence -> . add_op term term_sequence
    (78) add_op -> . +
    (79) add_op -> . -
    (80) add_op -> . OR

    =               reduce using rule 64 (term_sequence -> .)
    NE              reduce using rule 64 (term_sequence -> .)
    LT              reduce using rule 64 (term_sequence -> .)
    GT              reduce using rule 64 (term_sequence -> .)
    LE              reduce using rule 64 (term_sequence -> .)
    GE              reduce using rule 64 (term_sequence -> .)
    THEN            reduce using rule 64 (term_sequence -> .)
    DO              reduce using rule 64 (term_sequence -> .)
    END             reduce using rule 64 (term_sequence -> .)
    ;               reduce using rule 64 (term_sequence -> .)
    ELSE            reduce using rule 64 (term_sequence -> .)
    )               reduce using rule 64 (term_sequence -> .)
    ,               reduce using rule 64 (term_sequence -> .)
    ]               reduce using rule 64 (term_sequence -> .)
    :               reduce using rule 64 (term_sequence -> .)
    TO              reduce using rule 64 (term_sequence -> .)
    DOWNTO          reduce using rule 64 (term_sequence -> .)
    +               shift and go to state 153
    -               shift and go to state 154
    OR              shift and go to state 155

    term_sequence                  shift and go to state 190
    add_op                         shift and go to state 152

state 157

    (63) term -> factor factor_sequence .

    +               reduce using rule 63 (term -> factor factor_sequence .)
    -               reduce using rule 63 (term -> factor factor_sequence .)
    OR              reduce using rule 63 (term -> factor factor_sequence .)
    =               reduce using rule 63 (term -> factor factor_sequence .)
    NE              reduce using rule 63 (term -> factor factor_sequence .)
    LT              reduce using rule 63 (term -> factor factor_sequence .)
    GT              reduce using rule 63 (term -> factor factor_sequence .)
    LE              reduce using rule 63 (term -> factor factor_sequence .)
    GE              reduce using rule 63 (term -> factor factor_sequence .)
    THEN            reduce using rule 63 (term -> factor factor_sequence .)
    DO              reduce using rule 63 (term -> factor factor_sequence .)
    END             reduce using rule 63 (term -> factor factor_sequence .)
    ;               reduce using rule 63 (term -> factor factor_sequence .)
    ELSE            reduce using rule 63 (term -> factor factor_sequence .)
    )               reduce using rule 63 (term -> factor factor_sequence .)
    ,               reduce using rule 63 (term -> factor factor_sequence .)
    ]               reduce using rule 63 (term -> factor factor_sequence .)
    :               reduce using rule 63 (term -> factor factor_sequence .)
    TO              reduce using rule 63 (term -> factor factor_sequence .)
    DOWNTO          reduce using rule 63 (term -> factor factor_sequence .)


state 158

    (67) factor_sequence -> mul_op . factor factor_sequence
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    factor                         shift and go to state 191
    var_access                     shift and go to state 99

state 159

    (81) mul_op -> * .

    INT             reduce using rule 81 (mul_op -> * .)
    REAL            reduce using rule 81 (mul_op -> * .)
    CHAR            reduce using rule 81 (mul_op -> * .)
    STRING          reduce using rule 81 (mul_op -> * .)
    ID              reduce using rule 81 (mul_op -> * .)
    (               reduce using rule 81 (mul_op -> * .)
    NOT             reduce using rule 81 (mul_op -> * .)
    TRUE            reduce using rule 81 (mul_op -> * .)
    FALSE           reduce using rule 81 (mul_op -> * .)


state 160

    (82) mul_op -> / .

    INT             reduce using rule 82 (mul_op -> / .)
    REAL            reduce using rule 82 (mul_op -> / .)
    CHAR            reduce using rule 82 (mul_op -> / .)
    STRING          reduce using rule 82 (mul_op -> / .)
    ID              reduce using rule 82 (mul_op -> / .)
    (               reduce using rule 82 (mul_op -> / .)
    NOT             reduce using rule 82 (mul_op -> / .)
    TRUE            reduce using rule 82 (mul_op -> / .)
    FALSE           reduce using rule 82 (mul_op -> / .)


state 161

    (83) mul_op -> DIV .

    INT             reduce using rule 83 (mul_op -> DIV .)
    REAL            reduce using rule 83 (mul_op -> DIV .)
    CHAR            reduce using rule 83 (mul_op -> DIV .)
    STRING          reduce using rule 83 (mul_op -> DIV .)
    ID              reduce using rule 83 (mul_op -> DIV .)
    (               reduce using rule 83 (mul_op -> DIV .)
    NOT             reduce using rule 83 (mul_op -> DIV .)
    TRUE            reduce using rule 83 (mul_op -> DIV .)
    FALSE           reduce using rule 83 (mul_op -> DIV .)


state 162

    (84) mul_op -> MOD .

    INT             reduce using rule 84 (mul_op -> MOD .)
    REAL            reduce using rule 84 (mul_op -> MOD .)
    CHAR            reduce using rule 84 (mul_op -> MOD .)
    STRING          reduce using rule 84 (mul_op -> MOD .)
    ID              reduce using rule 84 (mul_op -> MOD .)
    (               reduce using rule 84 (mul_op -> MOD .)
    NOT             reduce using rule 84 (mul_op -> MOD .)
    TRUE            reduce using rule 84 (mul_op -> MOD .)
    FALSE           reduce using rule 84 (mul_op -> MOD .)


state 163

    (85) mul_op -> AND .

    INT             reduce using rule 85 (mul_op -> AND .)
    REAL            reduce using rule 85 (mul_op -> AND .)
    CHAR            reduce using rule 85 (mul_op -> AND .)
    STRING          reduce using rule 85 (mul_op -> AND .)
    ID              reduce using rule 85 (mul_op -> AND .)
    (               reduce using rule 85 (mul_op -> AND .)
    NOT             reduce using rule 85 (mul_op -> AND .)
    TRUE            reduce using rule 85 (mul_op -> AND .)
    FALSE           reduce using rule 85 (mul_op -> AND .)


state 164

    (73) factor -> ID ( . expr_list )
    (57) expr_list -> . expr
    (58) expr_list -> . expr_list , expr
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    expr_list                      shift and go to state 192
    expr                           shift and go to state 132
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 165

    (74) factor -> ( expr . )

    )               shift and go to state 193


state 166

    (75) factor -> NOT factor .

    *               reduce using rule 75 (factor -> NOT factor .)
    /               reduce using rule 75 (factor -> NOT factor .)
    DIV             reduce using rule 75 (factor -> NOT factor .)
    MOD             reduce using rule 75 (factor -> NOT factor .)
    AND             reduce using rule 75 (factor -> NOT factor .)
    +               reduce using rule 75 (factor -> NOT factor .)
    -               reduce using rule 75 (factor -> NOT factor .)
    OR              reduce using rule 75 (factor -> NOT factor .)
    =               reduce using rule 75 (factor -> NOT factor .)
    NE              reduce using rule 75 (factor -> NOT factor .)
    LT              reduce using rule 75 (factor -> NOT factor .)
    GT              reduce using rule 75 (factor -> NOT factor .)
    LE              reduce using rule 75 (factor -> NOT factor .)
    GE              reduce using rule 75 (factor -> NOT factor .)
    THEN            reduce using rule 75 (factor -> NOT factor .)
    DO              reduce using rule 75 (factor -> NOT factor .)
    END             reduce using rule 75 (factor -> NOT factor .)
    ;               reduce using rule 75 (factor -> NOT factor .)
    ELSE            reduce using rule 75 (factor -> NOT factor .)
    )               reduce using rule 75 (factor -> NOT factor .)
    ,               reduce using rule 75 (factor -> NOT factor .)
    ]               reduce using rule 75 (factor -> NOT factor .)
    :               reduce using rule 75 (factor -> NOT factor .)
    TO              reduce using rule 75 (factor -> NOT factor .)
    DOWNTO          reduce using rule 75 (factor -> NOT factor .)


state 167

    (124) while_statement -> WHILE expr DO . statement
    (95) statement -> .
    (96) statement -> . assignment_statement
    (97) statement -> . proc_statement
    (98) statement -> . read_statement
    (99) statement -> . write_statement
    (100) statement -> . labeled_statement
    (101) statement -> . compound_statement
    (102) statement -> . if_statement
    (103) statement -> . while_statement
    (104) statement -> . for_statement
    (105) assignment_statement -> . var_access ASSIGN expr
    (106) proc_statement -> . ID
    (107) proc_statement -> . ID ( expr_list )
    (109) read_statement -> . READ ( var_access_list )
    (110) read_statement -> . READLN
    (111) read_statement -> . READLN ( var_access_list )
    (114) write_statement -> . WRITE ( write_list )
    (115) write_statement -> . WRITELN
    (116) write_statement -> . WRITELN ( write_list )
    (108) labeled_statement -> . INT : statement
    (92) compound_statement -> . BEGIN statement_list END
    (122) if_statement -> . IF expr THEN statement
    (123) if_statement -> . IF expr THEN statement ELSE statement
    (124) while_statement -> . WHILE expr DO statement
    (125) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (126) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID var_suffix

    END             reduce using rule 95 (statement -> .)
    ;               reduce using rule 95 (statement -> .)
    ELSE            reduce using rule 95 (statement -> .)
    ID              shift and go to state 64
    READ            shift and go to state 65
    READLN          shift and go to state 66
    WRITE           shift and go to state 67
    WRITELN         shift and go to state 68
    INT             shift and go to state 69
    BEGIN           shift and go to state 31
    IF              shift and go to state 70
    WHILE           shift and go to state 71
    FOR             shift and go to state 72

    statement                      shift and go to state 194
    assignment_statement           shift and go to state 54
    proc_statement                 shift and go to state 55
    read_statement                 shift and go to state 56
    write_statement                shift and go to state 57
    labeled_statement              shift and go to state 58
    compound_statement             shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    var_access                     shift and go to state 63

state 168

    (125) for_statement -> FOR ID ASSIGN . expr TO expr DO statement
    (126) for_statement -> FOR ID ASSIGN . expr DOWNTO expr DO statement
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    expr                           shift and go to state 195
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 169

    (33) enumerated_type -> ( id_list . )

    )               shift and go to state 196


state 170

    (34) subrange_type -> constant DOTDOT . constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) constant -> . TRUE
    (18) constant -> . FALSE
    (19) sign -> . +
    (20) sign -> . -

    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    ID              shift and go to state 40
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    +               shift and go to state 49
    -               shift and go to state 50

    constant                       shift and go to state 197
    sign                           shift and go to state 42

state 171

    (35) array_type -> ARRAY [ . ordinal_type_list ] OF tipo
    (39) ordinal_type_list -> . ordinal_type
    (40) ordinal_type_list -> . ordinal_type_list , ordinal_type
    (36) ordinal_type -> . enumerated_type
    (37) ordinal_type -> . subrange_type
    (38) ordinal_type -> . ID
    (33) enumerated_type -> . ( id_list )
    (34) subrange_type -> . constant DOTDOT constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) constant -> . TRUE
    (18) constant -> . FALSE
    (19) sign -> . +
    (20) sign -> . -

    ID              shift and go to state 202
    (               shift and go to state 118
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    +               shift and go to state 49
    -               shift and go to state 50

    ordinal_type_list              shift and go to state 198
    ordinal_type                   shift and go to state 199
    enumerated_type                shift and go to state 200
    subrange_type                  shift and go to state 201
    constant                       shift and go to state 119
    sign                           shift and go to state 42

state 172

    (47) proc_heading -> PROCEDURE ID ( param_list ) .

    ;               reduce using rule 47 (proc_heading -> PROCEDURE ID ( param_list ) .)


state 173

    (51) param_list -> param_list ; . param
    (52) param -> . id_list : ID
    (53) param -> . VAR id_list : ID
    (26) id_list -> . ID
    (27) id_list -> . ID , id_list

    VAR             shift and go to state 126
    ID              shift and go to state 15

    param                          shift and go to state 203
    id_list                        shift and go to state 125

state 174

    (52) param -> id_list : . ID

    ID              shift and go to state 204


state 175

    (53) param -> VAR id_list . : ID

    :               shift and go to state 205


state 176

    (49) func_heading -> FUNCTION ID ( param_list ) . : ID

    :               shift and go to state 206


state 177

    (107) proc_statement -> ID ( expr_list ) .

    END             reduce using rule 107 (proc_statement -> ID ( expr_list ) .)
    ;               reduce using rule 107 (proc_statement -> ID ( expr_list ) .)
    ELSE            reduce using rule 107 (proc_statement -> ID ( expr_list ) .)


state 178

    (58) expr_list -> expr_list , . expr
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    expr                           shift and go to state 207
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 179

    (56) var_suffix -> [ expr_list ] . var_suffix
    (55) var_suffix -> .
    (56) var_suffix -> . [ expr_list ] var_suffix

    ASSIGN          reduce using rule 55 (var_suffix -> .)
    *               reduce using rule 55 (var_suffix -> .)
    /               reduce using rule 55 (var_suffix -> .)
    DIV             reduce using rule 55 (var_suffix -> .)
    MOD             reduce using rule 55 (var_suffix -> .)
    AND             reduce using rule 55 (var_suffix -> .)
    +               reduce using rule 55 (var_suffix -> .)
    -               reduce using rule 55 (var_suffix -> .)
    OR              reduce using rule 55 (var_suffix -> .)
    =               reduce using rule 55 (var_suffix -> .)
    NE              reduce using rule 55 (var_suffix -> .)
    LT              reduce using rule 55 (var_suffix -> .)
    GT              reduce using rule 55 (var_suffix -> .)
    LE              reduce using rule 55 (var_suffix -> .)
    GE              reduce using rule 55 (var_suffix -> .)
    THEN            reduce using rule 55 (var_suffix -> .)
    DO              reduce using rule 55 (var_suffix -> .)
    END             reduce using rule 55 (var_suffix -> .)
    ;               reduce using rule 55 (var_suffix -> .)
    ELSE            reduce using rule 55 (var_suffix -> .)
    )               reduce using rule 55 (var_suffix -> .)
    ,               reduce using rule 55 (var_suffix -> .)
    ]               reduce using rule 55 (var_suffix -> .)
    :               reduce using rule 55 (var_suffix -> .)
    TO              reduce using rule 55 (var_suffix -> .)
    DOWNTO          reduce using rule 55 (var_suffix -> .)
    [               shift and go to state 88

    var_suffix                     shift and go to state 208

state 180

    (109) read_statement -> READ ( var_access_list ) .

    END             reduce using rule 109 (read_statement -> READ ( var_access_list ) .)
    ;               reduce using rule 109 (read_statement -> READ ( var_access_list ) .)
    ELSE            reduce using rule 109 (read_statement -> READ ( var_access_list ) .)


state 181

    (113) var_access_list -> var_access_list , . var_access
    (54) var_access -> . ID var_suffix

    ID              shift and go to state 136

    var_access                     shift and go to state 209

state 182

    (111) read_statement -> READLN ( var_access_list ) .

    END             reduce using rule 111 (read_statement -> READLN ( var_access_list ) .)
    ;               reduce using rule 111 (read_statement -> READLN ( var_access_list ) .)
    ELSE            reduce using rule 111 (read_statement -> READLN ( var_access_list ) .)


state 183

    (114) write_statement -> WRITE ( write_list ) .

    END             reduce using rule 114 (write_statement -> WRITE ( write_list ) .)
    ;               reduce using rule 114 (write_statement -> WRITE ( write_list ) .)
    ELSE            reduce using rule 114 (write_statement -> WRITE ( write_list ) .)


state 184

    (118) write_list -> write_list , . write_param
    (119) write_param -> . expr
    (120) write_param -> . expr : expr
    (121) write_param -> . expr : expr : expr
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    write_param                    shift and go to state 210
    expr                           shift and go to state 140
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 185

    (120) write_param -> expr : . expr
    (121) write_param -> expr : . expr : expr
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    expr                           shift and go to state 211
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 186

    (116) write_statement -> WRITELN ( write_list ) .

    END             reduce using rule 116 (write_statement -> WRITELN ( write_list ) .)
    ;               reduce using rule 116 (write_statement -> WRITELN ( write_list ) .)
    ELSE            reduce using rule 116 (write_statement -> WRITELN ( write_list ) .)


state 187

    (122) if_statement -> IF expr THEN statement .
    (123) if_statement -> IF expr THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    END             reduce using rule 122 (if_statement -> IF expr THEN statement .)
    ;               reduce using rule 122 (if_statement -> IF expr THEN statement .)
    ELSE            shift and go to state 212

  ! ELSE            [ reduce using rule 122 (if_statement -> IF expr THEN statement .) ]


state 188

    (60) expr -> simple_expr relation_op simple_expr .

    THEN            reduce using rule 60 (expr -> simple_expr relation_op simple_expr .)
    DO              reduce using rule 60 (expr -> simple_expr relation_op simple_expr .)
    END             reduce using rule 60 (expr -> simple_expr relation_op simple_expr .)
    ;               reduce using rule 60 (expr -> simple_expr relation_op simple_expr .)
    ELSE            reduce using rule 60 (expr -> simple_expr relation_op simple_expr .)
    )               reduce using rule 60 (expr -> simple_expr relation_op simple_expr .)
    ,               reduce using rule 60 (expr -> simple_expr relation_op simple_expr .)
    ]               reduce using rule 60 (expr -> simple_expr relation_op simple_expr .)
    :               reduce using rule 60 (expr -> simple_expr relation_op simple_expr .)
    TO              reduce using rule 60 (expr -> simple_expr relation_op simple_expr .)
    DOWNTO          reduce using rule 60 (expr -> simple_expr relation_op simple_expr .)


state 189

    (65) term_sequence -> add_op term . term_sequence
    (64) term_sequence -> .
    (65) term_sequence -> . add_op term term_sequence
    (78) add_op -> . +
    (79) add_op -> . -
    (80) add_op -> . OR

    =               reduce using rule 64 (term_sequence -> .)
    NE              reduce using rule 64 (term_sequence -> .)
    LT              reduce using rule 64 (term_sequence -> .)
    GT              reduce using rule 64 (term_sequence -> .)
    LE              reduce using rule 64 (term_sequence -> .)
    GE              reduce using rule 64 (term_sequence -> .)
    THEN            reduce using rule 64 (term_sequence -> .)
    DO              reduce using rule 64 (term_sequence -> .)
    END             reduce using rule 64 (term_sequence -> .)
    ;               reduce using rule 64 (term_sequence -> .)
    ELSE            reduce using rule 64 (term_sequence -> .)
    )               reduce using rule 64 (term_sequence -> .)
    ,               reduce using rule 64 (term_sequence -> .)
    ]               reduce using rule 64 (term_sequence -> .)
    :               reduce using rule 64 (term_sequence -> .)
    TO              reduce using rule 64 (term_sequence -> .)
    DOWNTO          reduce using rule 64 (term_sequence -> .)
    +               shift and go to state 153
    -               shift and go to state 154
    OR              shift and go to state 155

    add_op                         shift and go to state 152
    term_sequence                  shift and go to state 213

state 190

    (62) simple_expr -> sign term term_sequence .

    =               reduce using rule 62 (simple_expr -> sign term term_sequence .)
    NE              reduce using rule 62 (simple_expr -> sign term term_sequence .)
    LT              reduce using rule 62 (simple_expr -> sign term term_sequence .)
    GT              reduce using rule 62 (simple_expr -> sign term term_sequence .)
    LE              reduce using rule 62 (simple_expr -> sign term term_sequence .)
    GE              reduce using rule 62 (simple_expr -> sign term term_sequence .)
    THEN            reduce using rule 62 (simple_expr -> sign term term_sequence .)
    DO              reduce using rule 62 (simple_expr -> sign term term_sequence .)
    END             reduce using rule 62 (simple_expr -> sign term term_sequence .)
    ;               reduce using rule 62 (simple_expr -> sign term term_sequence .)
    ELSE            reduce using rule 62 (simple_expr -> sign term term_sequence .)
    )               reduce using rule 62 (simple_expr -> sign term term_sequence .)
    ,               reduce using rule 62 (simple_expr -> sign term term_sequence .)
    ]               reduce using rule 62 (simple_expr -> sign term term_sequence .)
    :               reduce using rule 62 (simple_expr -> sign term term_sequence .)
    TO              reduce using rule 62 (simple_expr -> sign term term_sequence .)
    DOWNTO          reduce using rule 62 (simple_expr -> sign term term_sequence .)


state 191

    (67) factor_sequence -> mul_op factor . factor_sequence
    (66) factor_sequence -> .
    (67) factor_sequence -> . mul_op factor factor_sequence
    (81) mul_op -> . *
    (82) mul_op -> . /
    (83) mul_op -> . DIV
    (84) mul_op -> . MOD
    (85) mul_op -> . AND

    +               reduce using rule 66 (factor_sequence -> .)
    -               reduce using rule 66 (factor_sequence -> .)
    OR              reduce using rule 66 (factor_sequence -> .)
    =               reduce using rule 66 (factor_sequence -> .)
    NE              reduce using rule 66 (factor_sequence -> .)
    LT              reduce using rule 66 (factor_sequence -> .)
    GT              reduce using rule 66 (factor_sequence -> .)
    LE              reduce using rule 66 (factor_sequence -> .)
    GE              reduce using rule 66 (factor_sequence -> .)
    THEN            reduce using rule 66 (factor_sequence -> .)
    DO              reduce using rule 66 (factor_sequence -> .)
    END             reduce using rule 66 (factor_sequence -> .)
    ;               reduce using rule 66 (factor_sequence -> .)
    ELSE            reduce using rule 66 (factor_sequence -> .)
    )               reduce using rule 66 (factor_sequence -> .)
    ,               reduce using rule 66 (factor_sequence -> .)
    ]               reduce using rule 66 (factor_sequence -> .)
    :               reduce using rule 66 (factor_sequence -> .)
    TO              reduce using rule 66 (factor_sequence -> .)
    DOWNTO          reduce using rule 66 (factor_sequence -> .)
    *               shift and go to state 159
    /               shift and go to state 160
    DIV             shift and go to state 161
    MOD             shift and go to state 162
    AND             shift and go to state 163

    mul_op                         shift and go to state 158
    factor_sequence                shift and go to state 214

state 192

    (73) factor -> ID ( expr_list . )
    (58) expr_list -> expr_list . , expr

    )               shift and go to state 215
    ,               shift and go to state 178


state 193

    (74) factor -> ( expr ) .

    *               reduce using rule 74 (factor -> ( expr ) .)
    /               reduce using rule 74 (factor -> ( expr ) .)
    DIV             reduce using rule 74 (factor -> ( expr ) .)
    MOD             reduce using rule 74 (factor -> ( expr ) .)
    AND             reduce using rule 74 (factor -> ( expr ) .)
    +               reduce using rule 74 (factor -> ( expr ) .)
    -               reduce using rule 74 (factor -> ( expr ) .)
    OR              reduce using rule 74 (factor -> ( expr ) .)
    =               reduce using rule 74 (factor -> ( expr ) .)
    NE              reduce using rule 74 (factor -> ( expr ) .)
    LT              reduce using rule 74 (factor -> ( expr ) .)
    GT              reduce using rule 74 (factor -> ( expr ) .)
    LE              reduce using rule 74 (factor -> ( expr ) .)
    GE              reduce using rule 74 (factor -> ( expr ) .)
    THEN            reduce using rule 74 (factor -> ( expr ) .)
    DO              reduce using rule 74 (factor -> ( expr ) .)
    END             reduce using rule 74 (factor -> ( expr ) .)
    ;               reduce using rule 74 (factor -> ( expr ) .)
    ELSE            reduce using rule 74 (factor -> ( expr ) .)
    )               reduce using rule 74 (factor -> ( expr ) .)
    ,               reduce using rule 74 (factor -> ( expr ) .)
    ]               reduce using rule 74 (factor -> ( expr ) .)
    :               reduce using rule 74 (factor -> ( expr ) .)
    TO              reduce using rule 74 (factor -> ( expr ) .)
    DOWNTO          reduce using rule 74 (factor -> ( expr ) .)


state 194

    (124) while_statement -> WHILE expr DO statement .

    END             reduce using rule 124 (while_statement -> WHILE expr DO statement .)
    ;               reduce using rule 124 (while_statement -> WHILE expr DO statement .)
    ELSE            reduce using rule 124 (while_statement -> WHILE expr DO statement .)


state 195

    (125) for_statement -> FOR ID ASSIGN expr . TO expr DO statement
    (126) for_statement -> FOR ID ASSIGN expr . DOWNTO expr DO statement

    TO              shift and go to state 216
    DOWNTO          shift and go to state 217


state 196

    (33) enumerated_type -> ( id_list ) .

    ;               reduce using rule 33 (enumerated_type -> ( id_list ) .)
    ]               reduce using rule 33 (enumerated_type -> ( id_list ) .)
    ,               reduce using rule 33 (enumerated_type -> ( id_list ) .)


state 197

    (34) subrange_type -> constant DOTDOT constant .

    ;               reduce using rule 34 (subrange_type -> constant DOTDOT constant .)
    ]               reduce using rule 34 (subrange_type -> constant DOTDOT constant .)
    ,               reduce using rule 34 (subrange_type -> constant DOTDOT constant .)


state 198

    (35) array_type -> ARRAY [ ordinal_type_list . ] OF tipo
    (40) ordinal_type_list -> ordinal_type_list . , ordinal_type

    ]               shift and go to state 218
    ,               shift and go to state 219


state 199

    (39) ordinal_type_list -> ordinal_type .

    ]               reduce using rule 39 (ordinal_type_list -> ordinal_type .)
    ,               reduce using rule 39 (ordinal_type_list -> ordinal_type .)


state 200

    (36) ordinal_type -> enumerated_type .

    ]               reduce using rule 36 (ordinal_type -> enumerated_type .)
    ,               reduce using rule 36 (ordinal_type -> enumerated_type .)


state 201

    (37) ordinal_type -> subrange_type .

    ]               reduce using rule 37 (ordinal_type -> subrange_type .)
    ,               reduce using rule 37 (ordinal_type -> subrange_type .)


state 202

    (38) ordinal_type -> ID .
    (16) constant -> ID .

    ]               reduce using rule 38 (ordinal_type -> ID .)
    ,               reduce using rule 38 (ordinal_type -> ID .)
    DOTDOT          reduce using rule 16 (constant -> ID .)


state 203

    (51) param_list -> param_list ; param .

    )               reduce using rule 51 (param_list -> param_list ; param .)
    ;               reduce using rule 51 (param_list -> param_list ; param .)


state 204

    (52) param -> id_list : ID .

    )               reduce using rule 52 (param -> id_list : ID .)
    ;               reduce using rule 52 (param -> id_list : ID .)


state 205

    (53) param -> VAR id_list : . ID

    ID              shift and go to state 220


state 206

    (49) func_heading -> FUNCTION ID ( param_list ) : . ID

    ID              shift and go to state 221


state 207

    (58) expr_list -> expr_list , expr .

    )               reduce using rule 58 (expr_list -> expr_list , expr .)
    ,               reduce using rule 58 (expr_list -> expr_list , expr .)
    ]               reduce using rule 58 (expr_list -> expr_list , expr .)


state 208

    (56) var_suffix -> [ expr_list ] var_suffix .

    ASSIGN          reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    *               reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    /               reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    DIV             reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    MOD             reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    AND             reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    +               reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    -               reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    OR              reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    =               reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    NE              reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    LT              reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    GT              reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    LE              reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    GE              reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    THEN            reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    DO              reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    END             reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    ;               reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    ELSE            reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    )               reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    ,               reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    ]               reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    :               reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    TO              reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)
    DOWNTO          reduce using rule 56 (var_suffix -> [ expr_list ] var_suffix .)


state 209

    (113) var_access_list -> var_access_list , var_access .

    )               reduce using rule 113 (var_access_list -> var_access_list , var_access .)
    ,               reduce using rule 113 (var_access_list -> var_access_list , var_access .)


state 210

    (118) write_list -> write_list , write_param .

    )               reduce using rule 118 (write_list -> write_list , write_param .)
    ,               reduce using rule 118 (write_list -> write_list , write_param .)


state 211

    (120) write_param -> expr : expr .
    (121) write_param -> expr : expr . : expr

    )               reduce using rule 120 (write_param -> expr : expr .)
    ,               reduce using rule 120 (write_param -> expr : expr .)
    :               shift and go to state 222


state 212

    (123) if_statement -> IF expr THEN statement ELSE . statement
    (95) statement -> .
    (96) statement -> . assignment_statement
    (97) statement -> . proc_statement
    (98) statement -> . read_statement
    (99) statement -> . write_statement
    (100) statement -> . labeled_statement
    (101) statement -> . compound_statement
    (102) statement -> . if_statement
    (103) statement -> . while_statement
    (104) statement -> . for_statement
    (105) assignment_statement -> . var_access ASSIGN expr
    (106) proc_statement -> . ID
    (107) proc_statement -> . ID ( expr_list )
    (109) read_statement -> . READ ( var_access_list )
    (110) read_statement -> . READLN
    (111) read_statement -> . READLN ( var_access_list )
    (114) write_statement -> . WRITE ( write_list )
    (115) write_statement -> . WRITELN
    (116) write_statement -> . WRITELN ( write_list )
    (108) labeled_statement -> . INT : statement
    (92) compound_statement -> . BEGIN statement_list END
    (122) if_statement -> . IF expr THEN statement
    (123) if_statement -> . IF expr THEN statement ELSE statement
    (124) while_statement -> . WHILE expr DO statement
    (125) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (126) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID var_suffix

    END             reduce using rule 95 (statement -> .)
    ;               reduce using rule 95 (statement -> .)
    ELSE            reduce using rule 95 (statement -> .)
    ID              shift and go to state 64
    READ            shift and go to state 65
    READLN          shift and go to state 66
    WRITE           shift and go to state 67
    WRITELN         shift and go to state 68
    INT             shift and go to state 69
    BEGIN           shift and go to state 31
    IF              shift and go to state 70
    WHILE           shift and go to state 71
    FOR             shift and go to state 72

    statement                      shift and go to state 223
    assignment_statement           shift and go to state 54
    proc_statement                 shift and go to state 55
    read_statement                 shift and go to state 56
    write_statement                shift and go to state 57
    labeled_statement              shift and go to state 58
    compound_statement             shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    var_access                     shift and go to state 63

state 213

    (65) term_sequence -> add_op term term_sequence .

    =               reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    NE              reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    LT              reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    GT              reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    LE              reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    GE              reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    THEN            reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    DO              reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    END             reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    ;               reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    ELSE            reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    )               reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    ,               reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    ]               reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    :               reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    TO              reduce using rule 65 (term_sequence -> add_op term term_sequence .)
    DOWNTO          reduce using rule 65 (term_sequence -> add_op term term_sequence .)


state 214

    (67) factor_sequence -> mul_op factor factor_sequence .

    +               reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    -               reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    OR              reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    =               reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    NE              reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    LT              reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    GT              reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    LE              reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    GE              reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    THEN            reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    DO              reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    END             reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    ;               reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    ELSE            reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    )               reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    ,               reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    ]               reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    :               reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    TO              reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)
    DOWNTO          reduce using rule 67 (factor_sequence -> mul_op factor factor_sequence .)


state 215

    (73) factor -> ID ( expr_list ) .

    *               reduce using rule 73 (factor -> ID ( expr_list ) .)
    /               reduce using rule 73 (factor -> ID ( expr_list ) .)
    DIV             reduce using rule 73 (factor -> ID ( expr_list ) .)
    MOD             reduce using rule 73 (factor -> ID ( expr_list ) .)
    AND             reduce using rule 73 (factor -> ID ( expr_list ) .)
    +               reduce using rule 73 (factor -> ID ( expr_list ) .)
    -               reduce using rule 73 (factor -> ID ( expr_list ) .)
    OR              reduce using rule 73 (factor -> ID ( expr_list ) .)
    =               reduce using rule 73 (factor -> ID ( expr_list ) .)
    NE              reduce using rule 73 (factor -> ID ( expr_list ) .)
    LT              reduce using rule 73 (factor -> ID ( expr_list ) .)
    GT              reduce using rule 73 (factor -> ID ( expr_list ) .)
    LE              reduce using rule 73 (factor -> ID ( expr_list ) .)
    GE              reduce using rule 73 (factor -> ID ( expr_list ) .)
    THEN            reduce using rule 73 (factor -> ID ( expr_list ) .)
    DO              reduce using rule 73 (factor -> ID ( expr_list ) .)
    END             reduce using rule 73 (factor -> ID ( expr_list ) .)
    ;               reduce using rule 73 (factor -> ID ( expr_list ) .)
    ELSE            reduce using rule 73 (factor -> ID ( expr_list ) .)
    )               reduce using rule 73 (factor -> ID ( expr_list ) .)
    ,               reduce using rule 73 (factor -> ID ( expr_list ) .)
    ]               reduce using rule 73 (factor -> ID ( expr_list ) .)
    :               reduce using rule 73 (factor -> ID ( expr_list ) .)
    TO              reduce using rule 73 (factor -> ID ( expr_list ) .)
    DOWNTO          reduce using rule 73 (factor -> ID ( expr_list ) .)


state 216

    (125) for_statement -> FOR ID ASSIGN expr TO . expr DO statement
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    expr                           shift and go to state 224
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 217

    (126) for_statement -> FOR ID ASSIGN expr DOWNTO . expr DO statement
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    expr                           shift and go to state 225
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 218

    (35) array_type -> ARRAY [ ordinal_type_list ] . OF tipo

    OF              shift and go to state 226


state 219

    (40) ordinal_type_list -> ordinal_type_list , . ordinal_type
    (36) ordinal_type -> . enumerated_type
    (37) ordinal_type -> . subrange_type
    (38) ordinal_type -> . ID
    (33) enumerated_type -> . ( id_list )
    (34) subrange_type -> . constant DOTDOT constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) constant -> . TRUE
    (18) constant -> . FALSE
    (19) sign -> . +
    (20) sign -> . -

    ID              shift and go to state 202
    (               shift and go to state 118
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    +               shift and go to state 49
    -               shift and go to state 50

    ordinal_type                   shift and go to state 227
    enumerated_type                shift and go to state 200
    subrange_type                  shift and go to state 201
    constant                       shift and go to state 119
    sign                           shift and go to state 42

state 220

    (53) param -> VAR id_list : ID .

    )               reduce using rule 53 (param -> VAR id_list : ID .)
    ;               reduce using rule 53 (param -> VAR id_list : ID .)


state 221

    (49) func_heading -> FUNCTION ID ( param_list ) : ID .

    ;               reduce using rule 49 (func_heading -> FUNCTION ID ( param_list ) : ID .)


state 222

    (121) write_param -> expr : expr : . expr
    (59) expr -> . simple_expr
    (60) expr -> . simple_expr relation_op simple_expr
    (61) simple_expr -> . term term_sequence
    (62) simple_expr -> . sign term term_sequence
    (63) term -> . factor factor_sequence
    (19) sign -> . +
    (20) sign -> . -
    (68) factor -> . var_access
    (69) factor -> . INT
    (70) factor -> . REAL
    (71) factor -> . CHAR
    (72) factor -> . STRING
    (73) factor -> . ID ( expr_list )
    (74) factor -> . ( expr )
    (75) factor -> . NOT factor
    (76) factor -> . TRUE
    (77) factor -> . FALSE
    (54) var_access -> . ID var_suffix

    +               shift and go to state 49
    -               shift and go to state 50
    INT             shift and go to state 100
    REAL            shift and go to state 101
    CHAR            shift and go to state 102
    STRING          shift and go to state 103
    ID              shift and go to state 104
    (               shift and go to state 105
    NOT             shift and go to state 106
    TRUE            shift and go to state 107
    FALSE           shift and go to state 108

    expr                           shift and go to state 228
    simple_expr                    shift and go to state 95
    term                           shift and go to state 96
    sign                           shift and go to state 97
    factor                         shift and go to state 98
    var_access                     shift and go to state 99

state 223

    (123) if_statement -> IF expr THEN statement ELSE statement .

    END             reduce using rule 123 (if_statement -> IF expr THEN statement ELSE statement .)
    ;               reduce using rule 123 (if_statement -> IF expr THEN statement ELSE statement .)
    ELSE            reduce using rule 123 (if_statement -> IF expr THEN statement ELSE statement .)


state 224

    (125) for_statement -> FOR ID ASSIGN expr TO expr . DO statement

    DO              shift and go to state 229


state 225

    (126) for_statement -> FOR ID ASSIGN expr DOWNTO expr . DO statement

    DO              shift and go to state 230


state 226

    (35) array_type -> ARRAY [ ordinal_type_list ] OF . tipo
    (28) tipo -> . ID
    (29) tipo -> . new_type
    (30) new_type -> . enumerated_type
    (31) new_type -> . subrange_type
    (32) new_type -> . array_type
    (33) enumerated_type -> . ( id_list )
    (34) subrange_type -> . constant DOTDOT constant
    (35) array_type -> . ARRAY [ ordinal_type_list ] OF tipo
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) constant -> . TRUE
    (18) constant -> . FALSE
    (19) sign -> . +
    (20) sign -> . -

    ID              shift and go to state 113
    (               shift and go to state 118
    ARRAY           shift and go to state 120
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    +               shift and go to state 49
    -               shift and go to state 50

    tipo                           shift and go to state 231
    new_type                       shift and go to state 114
    enumerated_type                shift and go to state 115
    subrange_type                  shift and go to state 116
    array_type                     shift and go to state 117
    constant                       shift and go to state 119
    sign                           shift and go to state 42

state 227

    (40) ordinal_type_list -> ordinal_type_list , ordinal_type .

    ]               reduce using rule 40 (ordinal_type_list -> ordinal_type_list , ordinal_type .)
    ,               reduce using rule 40 (ordinal_type_list -> ordinal_type_list , ordinal_type .)


state 228

    (121) write_param -> expr : expr : expr .

    )               reduce using rule 121 (write_param -> expr : expr : expr .)
    ,               reduce using rule 121 (write_param -> expr : expr : expr .)


state 229

    (125) for_statement -> FOR ID ASSIGN expr TO expr DO . statement
    (95) statement -> .
    (96) statement -> . assignment_statement
    (97) statement -> . proc_statement
    (98) statement -> . read_statement
    (99) statement -> . write_statement
    (100) statement -> . labeled_statement
    (101) statement -> . compound_statement
    (102) statement -> . if_statement
    (103) statement -> . while_statement
    (104) statement -> . for_statement
    (105) assignment_statement -> . var_access ASSIGN expr
    (106) proc_statement -> . ID
    (107) proc_statement -> . ID ( expr_list )
    (109) read_statement -> . READ ( var_access_list )
    (110) read_statement -> . READLN
    (111) read_statement -> . READLN ( var_access_list )
    (114) write_statement -> . WRITE ( write_list )
    (115) write_statement -> . WRITELN
    (116) write_statement -> . WRITELN ( write_list )
    (108) labeled_statement -> . INT : statement
    (92) compound_statement -> . BEGIN statement_list END
    (122) if_statement -> . IF expr THEN statement
    (123) if_statement -> . IF expr THEN statement ELSE statement
    (124) while_statement -> . WHILE expr DO statement
    (125) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (126) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID var_suffix

    END             reduce using rule 95 (statement -> .)
    ;               reduce using rule 95 (statement -> .)
    ELSE            reduce using rule 95 (statement -> .)
    ID              shift and go to state 64
    READ            shift and go to state 65
    READLN          shift and go to state 66
    WRITE           shift and go to state 67
    WRITELN         shift and go to state 68
    INT             shift and go to state 69
    BEGIN           shift and go to state 31
    IF              shift and go to state 70
    WHILE           shift and go to state 71
    FOR             shift and go to state 72

    statement                      shift and go to state 232
    assignment_statement           shift and go to state 54
    proc_statement                 shift and go to state 55
    read_statement                 shift and go to state 56
    write_statement                shift and go to state 57
    labeled_statement              shift and go to state 58
    compound_statement             shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    var_access                     shift and go to state 63

state 230

    (126) for_statement -> FOR ID ASSIGN expr DOWNTO expr DO . statement
    (95) statement -> .
    (96) statement -> . assignment_statement
    (97) statement -> . proc_statement
    (98) statement -> . read_statement
    (99) statement -> . write_statement
    (100) statement -> . labeled_statement
    (101) statement -> . compound_statement
    (102) statement -> . if_statement
    (103) statement -> . while_statement
    (104) statement -> . for_statement
    (105) assignment_statement -> . var_access ASSIGN expr
    (106) proc_statement -> . ID
    (107) proc_statement -> . ID ( expr_list )
    (109) read_statement -> . READ ( var_access_list )
    (110) read_statement -> . READLN
    (111) read_statement -> . READLN ( var_access_list )
    (114) write_statement -> . WRITE ( write_list )
    (115) write_statement -> . WRITELN
    (116) write_statement -> . WRITELN ( write_list )
    (108) labeled_statement -> . INT : statement
    (92) compound_statement -> . BEGIN statement_list END
    (122) if_statement -> . IF expr THEN statement
    (123) if_statement -> . IF expr THEN statement ELSE statement
    (124) while_statement -> . WHILE expr DO statement
    (125) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (126) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID var_suffix

    END             reduce using rule 95 (statement -> .)
    ;               reduce using rule 95 (statement -> .)
    ELSE            reduce using rule 95 (statement -> .)
    ID              shift and go to state 64
    READ            shift and go to state 65
    READLN          shift and go to state 66
    WRITE           shift and go to state 67
    WRITELN         shift and go to state 68
    INT             shift and go to state 69
    BEGIN           shift and go to state 31
    IF              shift and go to state 70
    WHILE           shift and go to state 71
    FOR             shift and go to state 72

    statement                      shift and go to state 233
    assignment_statement           shift and go to state 54
    proc_statement                 shift and go to state 55
    read_statement                 shift and go to state 56
    write_statement                shift and go to state 57
    labeled_statement              shift and go to state 58
    compound_statement             shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    var_access                     shift and go to state 63

state 231

    (35) array_type -> ARRAY [ ordinal_type_list ] OF tipo .

    ;               reduce using rule 35 (array_type -> ARRAY [ ordinal_type_list ] OF tipo .)


state 232

    (125) for_statement -> FOR ID ASSIGN expr TO expr DO statement .

    END             reduce using rule 125 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)
    ;               reduce using rule 125 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)
    ELSE            reduce using rule 125 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)


state 233

    (126) for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .

    END             reduce using rule 126 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)
    ;               reduce using rule 126 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)
    ELSE            reduce using rule 126 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 187 resolved as shift
