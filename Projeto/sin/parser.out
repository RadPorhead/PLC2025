Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program_heading ; block .
Rule 2     program_heading -> PROGRAM ID ( id_list )
Rule 3     program_heading -> PROGRAM ID
Rule 4     block -> const_part procfunc_part var_part compound_statement
Rule 5     const_part -> <empty>
Rule 6     const_part -> CONST const_list
Rule 7     const_list -> const_def ;
Rule 8     const_list -> const_list const_def ;
Rule 9     const_def -> ID = constant
Rule 10    constant -> sign INT
Rule 11    constant -> INT
Rule 12    constant -> sign REAL
Rule 13    constant -> REAL
Rule 14    constant -> CHAR
Rule 15    constant -> STRING
Rule 16    constant -> ID
Rule 17    sign -> +
Rule 18    sign -> -
Rule 19    var_part -> <empty>
Rule 20    var_part -> VAR var_list
Rule 21    var_list -> var_dec ;
Rule 22    var_list -> var_list var_dec ;
Rule 23    var_dec -> id_list : tipo
Rule 24    id_list -> ID
Rule 25    id_list -> ID , id_list
Rule 26    tipo -> ID
Rule 27    tipo -> new_type
Rule 28    new_type -> enumerated_type
Rule 29    new_type -> subrange_type
Rule 30    new_type -> array_type
Rule 31    enumerated_type -> ( id_list )
Rule 32    subrange_type -> constant DOTDOT constant
Rule 33    array_type -> ARRAY [ ordinal_type_list ] OF tipo
Rule 34    ordinal_type -> enumerated_type
Rule 35    ordinal_type -> subrange_type
Rule 36    ordinal_type -> ID
Rule 37    ordinal_type_list -> ordinal_type
Rule 38    ordinal_type_list -> ordinal_type_list , ordinal_type
Rule 39    procfunc_part -> <empty>
Rule 40    procfunc_part -> procfunc_part proc_dec
Rule 41    procfunc_part -> procfunc_part func_dec
Rule 42    proc_dec -> proc_heading ; block ;
Rule 43    func_dec -> func_heading ; block ;
Rule 44    proc_heading -> PROCEDURE ID
Rule 45    proc_heading -> PROCEDURE ID ( param_list )
Rule 46    func_heading -> FUNCTION ID : ID
Rule 47    func_heading -> FUNCTION ID ( param_list ) : ID
Rule 48    param_list -> param
Rule 49    param_list -> param_list ; param
Rule 50    param -> id_list : ID
Rule 51    param -> VAR id_list : ID
Rule 52    param -> proc_heading
Rule 53    param -> func_heading
Rule 54    var_access -> ID
Rule 55    var_access -> var_access [ expr_list ]
Rule 56    expr_list -> expr
Rule 57    expr_list -> expr_list , expr
Rule 58    expr -> simple_expr
Rule 59    expr -> simple_expr relation_op simple_expr
Rule 60    simple_expr -> term term_sequence
Rule 61    simple_expr -> sign term term_sequence
Rule 62    term -> factor factor_sequence
Rule 63    term_sequence -> <empty>
Rule 64    term_sequence -> add_op term term_sequence
Rule 65    factor -> var_access
Rule 66    factor -> INT
Rule 67    factor -> REAL
Rule 68    factor -> CHAR
Rule 69    factor -> STRING
Rule 70    factor -> ID ( expr_list )
Rule 71    factor -> ( expr )
Rule 72    factor -> NOT factor
Rule 73    factor_sequence -> <empty>
Rule 74    factor_sequence -> mul_op factor factor_sequence
Rule 75    add_op -> +
Rule 76    add_op -> -
Rule 77    add_op -> OR
Rule 78    mul_op -> *
Rule 79    mul_op -> /
Rule 80    mul_op -> DIV
Rule 81    mul_op -> MOD
Rule 82    mul_op -> AND
Rule 83    relation_op -> =
Rule 84    relation_op -> NE
Rule 85    relation_op -> <
Rule 86    relation_op -> >
Rule 87    relation_op -> LE
Rule 88    relation_op -> GE
Rule 89    compound_statement -> BEGIN statement_list END
Rule 90    statement_list -> statement
Rule 91    statement_list -> statement_list ; statement
Rule 92    statement -> <empty>
Rule 93    statement -> assignment_statement
Rule 94    statement -> proc_statement
Rule 95    statement -> read_statement
Rule 96    statement -> write_statement
Rule 97    statement -> labeled_statement
Rule 98    statement -> compound_statement
Rule 99    statement -> if_statement
Rule 100   statement -> while_statement
Rule 101   statement -> for_statement
Rule 102   assignment_statement -> var_access ASSIGN expr
Rule 103   proc_statement -> ID
Rule 104   proc_statement -> ID ( expr_list )
Rule 105   labeled_statement -> INT : statement
Rule 106   read_statement -> READ ( var_access_list )
Rule 107   read_statement -> READLN
Rule 108   read_statement -> READLN ( var_access_list )
Rule 109   write_statement -> WRITE ( write_list )
Rule 110   write_statement -> WRITELN
Rule 111   write_statement -> WRITELN ( write_list )
Rule 112   var_access_list -> var_access
Rule 113   var_access_list -> var_access_list , var_access
Rule 114   write_list -> write_param
Rule 115   write_list -> write_list , write_param
Rule 116   write_param -> expr
Rule 117   write_param -> expr : expr
Rule 118   write_param -> expr : expr : expr
Rule 119   if_statement -> IF expr THEN statement
Rule 120   if_statement -> IF expr THEN statement ELSE statement
Rule 121   while_statement -> WHILE expr DO statement
Rule 122   for_statement -> FOR ID ASSIGN expr TO expr DO statement
Rule 123   for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement

Terminals, with rules where they appear

(                    : 2 31 45 47 70 71 104 106 108 109 111
)                    : 2 31 45 47 70 71 104 106 108 109 111
*                    : 78
+                    : 17 75
,                    : 25 38 57 113 115
-                    : 18 76
.                    : 1
/                    : 79
:                    : 23 46 47 50 51 105 117 118 118
;                    : 1 7 8 21 22 42 42 43 43 49 91
<                    : 85
=                    : 9 83
>                    : 86
AND                  : 82
ARRAY                : 33
ASSIGN               : 102 122 123
BEGIN                : 89
CHAR                 : 14 68
CONST                : 6
DIV                  : 80
DO                   : 121 122 123
DOTDOT               : 32
DOWNTO               : 123
ELSE                 : 120
END                  : 89
FOR                  : 122 123
FUNCTION             : 46 47
GE                   : 88
ID                   : 2 3 9 16 24 25 26 36 44 45 46 46 47 47 50 51 54 70 103 104 122 123
IF                   : 119 120
INT                  : 10 11 66 105
LE                   : 87
MOD                  : 81
NE                   : 84
NOT                  : 72
OF                   : 33
OR                   : 77
PROCEDURE            : 44 45
PROGRAM              : 2 3
READ                 : 106
READLN               : 107 108
REAL                 : 12 13 67
STRING               : 15 69
THEN                 : 119 120
TO                   : 122
VAR                  : 20 51
WHILE                : 121
WRITE                : 109
WRITELN              : 110 111
[                    : 33 55
]                    : 33 55
error                : 

Nonterminals, with rules where they appear

add_op               : 64
array_type           : 30
assignment_statement : 93
block                : 1 42 43
compound_statement   : 4 98
const_def            : 7 8
const_list           : 6 8
const_part           : 4
constant             : 9 32 32
enumerated_type      : 28 34
expr                 : 56 57 71 102 116 117 117 118 118 118 119 120 121 122 122 123 123
expr_list            : 55 57 70 104
factor               : 62 72 74
factor_sequence      : 62 74
for_statement        : 101
func_dec             : 41
func_heading         : 43 53
id_list              : 2 23 25 31 50 51
if_statement         : 99
labeled_statement    : 97
mul_op               : 74
new_type             : 27
ordinal_type         : 37 38
ordinal_type_list    : 33 38
param                : 48 49
param_list           : 45 47 49
proc_dec             : 40
proc_heading         : 42 52
proc_statement       : 94
procfunc_part        : 4 40 41
program              : 0
program_heading      : 1
read_statement       : 95
relation_op          : 59
sign                 : 10 12 61
simple_expr          : 58 59 59
statement            : 90 91 105 119 120 120 121 122 123
statement_list       : 89 91
subrange_type        : 29 35
term                 : 60 61 64
term_sequence        : 60 61 64
tipo                 : 23 33
var_access           : 55 65 102 112 113
var_access_list      : 106 108 113
var_dec              : 21 22
var_list             : 20 22
var_part             : 4
while_statement      : 100
write_list           : 109 111 115
write_param          : 114 115
write_statement      : 96

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program_heading ; block .
    (2) program_heading -> . PROGRAM ID ( id_list )
    (3) program_heading -> . PROGRAM ID

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    program_heading                shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> program_heading . ; block .

    ;               shift and go to state 4


state 3

    (2) program_heading -> PROGRAM . ID ( id_list )
    (3) program_heading -> PROGRAM . ID

    ID              shift and go to state 5


state 4

    (1) program -> program_heading ; . block .
    (4) block -> . const_part procfunc_part var_part compound_statement
    (5) const_part -> .
    (6) const_part -> . CONST const_list

    VAR             reduce using rule 5 (const_part -> .)
    PROCEDURE       reduce using rule 5 (const_part -> .)
    FUNCTION        reduce using rule 5 (const_part -> .)
    BEGIN           reduce using rule 5 (const_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 6
    const_part                     shift and go to state 7

state 5

    (2) program_heading -> PROGRAM ID . ( id_list )
    (3) program_heading -> PROGRAM ID .

    (               shift and go to state 9
    ;               reduce using rule 3 (program_heading -> PROGRAM ID .)


state 6

    (1) program -> program_heading ; block . .

    .               shift and go to state 10


state 7

    (4) block -> const_part . procfunc_part var_part compound_statement
    (39) procfunc_part -> .
    (40) procfunc_part -> . procfunc_part proc_dec
    (41) procfunc_part -> . procfunc_part func_dec

    VAR             reduce using rule 39 (procfunc_part -> .)
    PROCEDURE       reduce using rule 39 (procfunc_part -> .)
    FUNCTION        reduce using rule 39 (procfunc_part -> .)
    BEGIN           reduce using rule 39 (procfunc_part -> .)

    procfunc_part                  shift and go to state 11

state 8

    (6) const_part -> CONST . const_list
    (7) const_list -> . const_def ;
    (8) const_list -> . const_list const_def ;
    (9) const_def -> . ID = constant

    ID              shift and go to state 14

    const_list                     shift and go to state 12
    const_def                      shift and go to state 13

state 9

    (2) program_heading -> PROGRAM ID ( . id_list )
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 16

state 10

    (1) program -> program_heading ; block . .

    $end            reduce using rule 1 (program -> program_heading ; block . .)


state 11

    (4) block -> const_part procfunc_part . var_part compound_statement
    (40) procfunc_part -> procfunc_part . proc_dec
    (41) procfunc_part -> procfunc_part . func_dec
    (19) var_part -> .
    (20) var_part -> . VAR var_list
    (42) proc_dec -> . proc_heading ; block ;
    (43) func_dec -> . func_heading ; block ;
    (44) proc_heading -> . PROCEDURE ID
    (45) proc_heading -> . PROCEDURE ID ( param_list )
    (46) func_heading -> . FUNCTION ID : ID
    (47) func_heading -> . FUNCTION ID ( param_list ) : ID

    BEGIN           reduce using rule 19 (var_part -> .)
    VAR             shift and go to state 20
    PROCEDURE       shift and go to state 23
    FUNCTION        shift and go to state 24

    var_part                       shift and go to state 17
    proc_dec                       shift and go to state 18
    func_dec                       shift and go to state 19
    proc_heading                   shift and go to state 21
    func_heading                   shift and go to state 22

state 12

    (6) const_part -> CONST const_list .
    (8) const_list -> const_list . const_def ;
    (9) const_def -> . ID = constant

    VAR             reduce using rule 6 (const_part -> CONST const_list .)
    PROCEDURE       reduce using rule 6 (const_part -> CONST const_list .)
    FUNCTION        reduce using rule 6 (const_part -> CONST const_list .)
    BEGIN           reduce using rule 6 (const_part -> CONST const_list .)
    ID              shift and go to state 14

    const_def                      shift and go to state 25

state 13

    (7) const_list -> const_def . ;

    ;               shift and go to state 26


state 14

    (9) const_def -> ID . = constant

    =               shift and go to state 27


state 15

    (24) id_list -> ID .
    (25) id_list -> ID . , id_list

    )               reduce using rule 24 (id_list -> ID .)
    :               reduce using rule 24 (id_list -> ID .)
    ,               shift and go to state 28


state 16

    (2) program_heading -> PROGRAM ID ( id_list . )

    )               shift and go to state 29


state 17

    (4) block -> const_part procfunc_part var_part . compound_statement
    (89) compound_statement -> . BEGIN statement_list END

    BEGIN           shift and go to state 31

    compound_statement             shift and go to state 30

state 18

    (40) procfunc_part -> procfunc_part proc_dec .

    VAR             reduce using rule 40 (procfunc_part -> procfunc_part proc_dec .)
    PROCEDURE       reduce using rule 40 (procfunc_part -> procfunc_part proc_dec .)
    FUNCTION        reduce using rule 40 (procfunc_part -> procfunc_part proc_dec .)
    BEGIN           reduce using rule 40 (procfunc_part -> procfunc_part proc_dec .)


state 19

    (41) procfunc_part -> procfunc_part func_dec .

    VAR             reduce using rule 41 (procfunc_part -> procfunc_part func_dec .)
    PROCEDURE       reduce using rule 41 (procfunc_part -> procfunc_part func_dec .)
    FUNCTION        reduce using rule 41 (procfunc_part -> procfunc_part func_dec .)
    BEGIN           reduce using rule 41 (procfunc_part -> procfunc_part func_dec .)


state 20

    (20) var_part -> VAR . var_list
    (21) var_list -> . var_dec ;
    (22) var_list -> . var_list var_dec ;
    (23) var_dec -> . id_list : tipo
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    var_list                       shift and go to state 32
    var_dec                        shift and go to state 33
    id_list                        shift and go to state 34

state 21

    (42) proc_dec -> proc_heading . ; block ;

    ;               shift and go to state 35


state 22

    (43) func_dec -> func_heading . ; block ;

    ;               shift and go to state 36


state 23

    (44) proc_heading -> PROCEDURE . ID
    (45) proc_heading -> PROCEDURE . ID ( param_list )

    ID              shift and go to state 37


state 24

    (46) func_heading -> FUNCTION . ID : ID
    (47) func_heading -> FUNCTION . ID ( param_list ) : ID

    ID              shift and go to state 38


state 25

    (8) const_list -> const_list const_def . ;

    ;               shift and go to state 39


state 26

    (7) const_list -> const_def ; .

    ID              reduce using rule 7 (const_list -> const_def ; .)
    VAR             reduce using rule 7 (const_list -> const_def ; .)
    PROCEDURE       reduce using rule 7 (const_list -> const_def ; .)
    FUNCTION        reduce using rule 7 (const_list -> const_def ; .)
    BEGIN           reduce using rule 7 (const_list -> const_def ; .)


state 27

    (9) const_def -> ID = . constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    ID              shift and go to state 40
    +               shift and go to state 47
    -               shift and go to state 48

    constant                       shift and go to state 41
    sign                           shift and go to state 42

state 28

    (25) id_list -> ID , . id_list
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 49

state 29

    (2) program_heading -> PROGRAM ID ( id_list ) .

    ;               reduce using rule 2 (program_heading -> PROGRAM ID ( id_list ) .)


state 30

    (4) block -> const_part procfunc_part var_part compound_statement .

    .               reduce using rule 4 (block -> const_part procfunc_part var_part compound_statement .)
    ;               reduce using rule 4 (block -> const_part procfunc_part var_part compound_statement .)


state 31

    (89) compound_statement -> BEGIN . statement_list END
    (90) statement_list -> . statement
    (91) statement_list -> . statement_list ; statement
    (92) statement -> .
    (93) statement -> . assignment_statement
    (94) statement -> . proc_statement
    (95) statement -> . read_statement
    (96) statement -> . write_statement
    (97) statement -> . labeled_statement
    (98) statement -> . compound_statement
    (99) statement -> . if_statement
    (100) statement -> . while_statement
    (101) statement -> . for_statement
    (102) assignment_statement -> . var_access ASSIGN expr
    (103) proc_statement -> . ID
    (104) proc_statement -> . ID ( expr_list )
    (106) read_statement -> . READ ( var_access_list )
    (107) read_statement -> . READLN
    (108) read_statement -> . READLN ( var_access_list )
    (109) write_statement -> . WRITE ( write_list )
    (110) write_statement -> . WRITELN
    (111) write_statement -> . WRITELN ( write_list )
    (105) labeled_statement -> . INT : statement
    (89) compound_statement -> . BEGIN statement_list END
    (119) if_statement -> . IF expr THEN statement
    (120) if_statement -> . IF expr THEN statement ELSE statement
    (121) while_statement -> . WHILE expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    END             reduce using rule 92 (statement -> .)
    ;               reduce using rule 92 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement_list                 shift and go to state 50
    statement                      shift and go to state 51
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 32

    (20) var_part -> VAR var_list .
    (22) var_list -> var_list . var_dec ;
    (23) var_dec -> . id_list : tipo
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    BEGIN           reduce using rule 20 (var_part -> VAR var_list .)
    ID              shift and go to state 15

    var_dec                        shift and go to state 71
    id_list                        shift and go to state 34

state 33

    (21) var_list -> var_dec . ;

    ;               shift and go to state 72


state 34

    (23) var_dec -> id_list . : tipo

    :               shift and go to state 73


state 35

    (42) proc_dec -> proc_heading ; . block ;
    (4) block -> . const_part procfunc_part var_part compound_statement
    (5) const_part -> .
    (6) const_part -> . CONST const_list

    VAR             reduce using rule 5 (const_part -> .)
    PROCEDURE       reduce using rule 5 (const_part -> .)
    FUNCTION        reduce using rule 5 (const_part -> .)
    BEGIN           reduce using rule 5 (const_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 74
    const_part                     shift and go to state 7

state 36

    (43) func_dec -> func_heading ; . block ;
    (4) block -> . const_part procfunc_part var_part compound_statement
    (5) const_part -> .
    (6) const_part -> . CONST const_list

    VAR             reduce using rule 5 (const_part -> .)
    PROCEDURE       reduce using rule 5 (const_part -> .)
    FUNCTION        reduce using rule 5 (const_part -> .)
    BEGIN           reduce using rule 5 (const_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 75
    const_part                     shift and go to state 7

state 37

    (44) proc_heading -> PROCEDURE ID .
    (45) proc_heading -> PROCEDURE ID . ( param_list )

    ;               reduce using rule 44 (proc_heading -> PROCEDURE ID .)
    )               reduce using rule 44 (proc_heading -> PROCEDURE ID .)
    (               shift and go to state 76


state 38

    (46) func_heading -> FUNCTION ID . : ID
    (47) func_heading -> FUNCTION ID . ( param_list ) : ID

    :               shift and go to state 77
    (               shift and go to state 78


state 39

    (8) const_list -> const_list const_def ; .

    ID              reduce using rule 8 (const_list -> const_list const_def ; .)
    VAR             reduce using rule 8 (const_list -> const_list const_def ; .)
    PROCEDURE       reduce using rule 8 (const_list -> const_list const_def ; .)
    FUNCTION        reduce using rule 8 (const_list -> const_list const_def ; .)
    BEGIN           reduce using rule 8 (const_list -> const_list const_def ; .)


state 40

    (16) constant -> ID .

    ;               reduce using rule 16 (constant -> ID .)
    ]               reduce using rule 16 (constant -> ID .)
    ,               reduce using rule 16 (constant -> ID .)


state 41

    (9) const_def -> ID = constant .

    ;               reduce using rule 9 (const_def -> ID = constant .)


state 42

    (10) constant -> sign . INT
    (12) constant -> sign . REAL

    INT             shift and go to state 79
    REAL            shift and go to state 80


state 43

    (11) constant -> INT .

    ;               reduce using rule 11 (constant -> INT .)
    DOTDOT          reduce using rule 11 (constant -> INT .)
    ]               reduce using rule 11 (constant -> INT .)
    ,               reduce using rule 11 (constant -> INT .)


state 44

    (13) constant -> REAL .

    ;               reduce using rule 13 (constant -> REAL .)
    DOTDOT          reduce using rule 13 (constant -> REAL .)
    ]               reduce using rule 13 (constant -> REAL .)
    ,               reduce using rule 13 (constant -> REAL .)


state 45

    (14) constant -> CHAR .

    ;               reduce using rule 14 (constant -> CHAR .)
    DOTDOT          reduce using rule 14 (constant -> CHAR .)
    ]               reduce using rule 14 (constant -> CHAR .)
    ,               reduce using rule 14 (constant -> CHAR .)


state 46

    (15) constant -> STRING .

    ;               reduce using rule 15 (constant -> STRING .)
    DOTDOT          reduce using rule 15 (constant -> STRING .)
    ]               reduce using rule 15 (constant -> STRING .)
    ,               reduce using rule 15 (constant -> STRING .)


state 47

    (17) sign -> + .

    INT             reduce using rule 17 (sign -> + .)
    REAL            reduce using rule 17 (sign -> + .)
    CHAR            reduce using rule 17 (sign -> + .)
    STRING          reduce using rule 17 (sign -> + .)
    ID              reduce using rule 17 (sign -> + .)
    (               reduce using rule 17 (sign -> + .)
    NOT             reduce using rule 17 (sign -> + .)


state 48

    (18) sign -> - .

    INT             reduce using rule 18 (sign -> - .)
    REAL            reduce using rule 18 (sign -> - .)
    CHAR            reduce using rule 18 (sign -> - .)
    STRING          reduce using rule 18 (sign -> - .)
    ID              reduce using rule 18 (sign -> - .)
    (               reduce using rule 18 (sign -> - .)
    NOT             reduce using rule 18 (sign -> - .)


state 49

    (25) id_list -> ID , id_list .

    )               reduce using rule 25 (id_list -> ID , id_list .)
    :               reduce using rule 25 (id_list -> ID , id_list .)


state 50

    (89) compound_statement -> BEGIN statement_list . END
    (91) statement_list -> statement_list . ; statement

    END             shift and go to state 81
    ;               shift and go to state 82


state 51

    (90) statement_list -> statement .

    END             reduce using rule 90 (statement_list -> statement .)
    ;               reduce using rule 90 (statement_list -> statement .)


state 52

    (93) statement -> assignment_statement .

    END             reduce using rule 93 (statement -> assignment_statement .)
    ;               reduce using rule 93 (statement -> assignment_statement .)
    ELSE            reduce using rule 93 (statement -> assignment_statement .)


state 53

    (94) statement -> proc_statement .

    END             reduce using rule 94 (statement -> proc_statement .)
    ;               reduce using rule 94 (statement -> proc_statement .)
    ELSE            reduce using rule 94 (statement -> proc_statement .)


state 54

    (95) statement -> read_statement .

    END             reduce using rule 95 (statement -> read_statement .)
    ;               reduce using rule 95 (statement -> read_statement .)
    ELSE            reduce using rule 95 (statement -> read_statement .)


state 55

    (96) statement -> write_statement .

    END             reduce using rule 96 (statement -> write_statement .)
    ;               reduce using rule 96 (statement -> write_statement .)
    ELSE            reduce using rule 96 (statement -> write_statement .)


state 56

    (97) statement -> labeled_statement .

    END             reduce using rule 97 (statement -> labeled_statement .)
    ;               reduce using rule 97 (statement -> labeled_statement .)
    ELSE            reduce using rule 97 (statement -> labeled_statement .)


state 57

    (98) statement -> compound_statement .

    END             reduce using rule 98 (statement -> compound_statement .)
    ;               reduce using rule 98 (statement -> compound_statement .)
    ELSE            reduce using rule 98 (statement -> compound_statement .)


state 58

    (99) statement -> if_statement .

    END             reduce using rule 99 (statement -> if_statement .)
    ;               reduce using rule 99 (statement -> if_statement .)
    ELSE            reduce using rule 99 (statement -> if_statement .)


state 59

    (100) statement -> while_statement .

    END             reduce using rule 100 (statement -> while_statement .)
    ;               reduce using rule 100 (statement -> while_statement .)
    ELSE            reduce using rule 100 (statement -> while_statement .)


state 60

    (101) statement -> for_statement .

    END             reduce using rule 101 (statement -> for_statement .)
    ;               reduce using rule 101 (statement -> for_statement .)
    ELSE            reduce using rule 101 (statement -> for_statement .)


state 61

    (102) assignment_statement -> var_access . ASSIGN expr
    (55) var_access -> var_access . [ expr_list ]

    ASSIGN          shift and go to state 83
    [               shift and go to state 84


state 62

    (103) proc_statement -> ID .
    (104) proc_statement -> ID . ( expr_list )
    (54) var_access -> ID .

    END             reduce using rule 103 (proc_statement -> ID .)
    ;               reduce using rule 103 (proc_statement -> ID .)
    ELSE            reduce using rule 103 (proc_statement -> ID .)
    (               shift and go to state 85
    ASSIGN          reduce using rule 54 (var_access -> ID .)
    [               reduce using rule 54 (var_access -> ID .)


state 63

    (106) read_statement -> READ . ( var_access_list )

    (               shift and go to state 86


state 64

    (107) read_statement -> READLN .
    (108) read_statement -> READLN . ( var_access_list )

    END             reduce using rule 107 (read_statement -> READLN .)
    ;               reduce using rule 107 (read_statement -> READLN .)
    ELSE            reduce using rule 107 (read_statement -> READLN .)
    (               shift and go to state 87


state 65

    (109) write_statement -> WRITE . ( write_list )

    (               shift and go to state 88


state 66

    (110) write_statement -> WRITELN .
    (111) write_statement -> WRITELN . ( write_list )

    END             reduce using rule 110 (write_statement -> WRITELN .)
    ;               reduce using rule 110 (write_statement -> WRITELN .)
    ELSE            reduce using rule 110 (write_statement -> WRITELN .)
    (               shift and go to state 89


state 67

    (105) labeled_statement -> INT . : statement

    :               shift and go to state 90


state 68

    (119) if_statement -> IF . expr THEN statement
    (120) if_statement -> IF . expr THEN statement ELSE statement
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    expr                           shift and go to state 91
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 69

    (121) while_statement -> WHILE . expr DO statement
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    expr                           shift and go to state 104
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 70

    (122) for_statement -> FOR . ID ASSIGN expr TO expr DO statement
    (123) for_statement -> FOR . ID ASSIGN expr DOWNTO expr DO statement

    ID              shift and go to state 105


state 71

    (22) var_list -> var_list var_dec . ;

    ;               shift and go to state 106


state 72

    (21) var_list -> var_dec ; .

    ID              reduce using rule 21 (var_list -> var_dec ; .)
    BEGIN           reduce using rule 21 (var_list -> var_dec ; .)


state 73

    (23) var_dec -> id_list : . tipo
    (26) tipo -> . ID
    (27) tipo -> . new_type
    (28) new_type -> . enumerated_type
    (29) new_type -> . subrange_type
    (30) new_type -> . array_type
    (31) enumerated_type -> . ( id_list )
    (32) subrange_type -> . constant DOTDOT constant
    (33) array_type -> . ARRAY [ ordinal_type_list ] OF tipo
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    ID              shift and go to state 108
    (               shift and go to state 113
    ARRAY           shift and go to state 115
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    +               shift and go to state 47
    -               shift and go to state 48

    tipo                           shift and go to state 107
    new_type                       shift and go to state 109
    enumerated_type                shift and go to state 110
    subrange_type                  shift and go to state 111
    array_type                     shift and go to state 112
    constant                       shift and go to state 114
    sign                           shift and go to state 42

state 74

    (42) proc_dec -> proc_heading ; block . ;

    ;               shift and go to state 116


state 75

    (43) func_dec -> func_heading ; block . ;

    ;               shift and go to state 117


state 76

    (45) proc_heading -> PROCEDURE ID ( . param_list )
    (48) param_list -> . param
    (49) param_list -> . param_list ; param
    (50) param -> . id_list : ID
    (51) param -> . VAR id_list : ID
    (52) param -> . proc_heading
    (53) param -> . func_heading
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list
    (44) proc_heading -> . PROCEDURE ID
    (45) proc_heading -> . PROCEDURE ID ( param_list )
    (46) func_heading -> . FUNCTION ID : ID
    (47) func_heading -> . FUNCTION ID ( param_list ) : ID

    VAR             shift and go to state 121
    ID              shift and go to state 15
    PROCEDURE       shift and go to state 23
    FUNCTION        shift and go to state 24

    param_list                     shift and go to state 118
    param                          shift and go to state 119
    id_list                        shift and go to state 120
    proc_heading                   shift and go to state 122
    func_heading                   shift and go to state 123

state 77

    (46) func_heading -> FUNCTION ID : . ID

    ID              shift and go to state 124


state 78

    (47) func_heading -> FUNCTION ID ( . param_list ) : ID
    (48) param_list -> . param
    (49) param_list -> . param_list ; param
    (50) param -> . id_list : ID
    (51) param -> . VAR id_list : ID
    (52) param -> . proc_heading
    (53) param -> . func_heading
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list
    (44) proc_heading -> . PROCEDURE ID
    (45) proc_heading -> . PROCEDURE ID ( param_list )
    (46) func_heading -> . FUNCTION ID : ID
    (47) func_heading -> . FUNCTION ID ( param_list ) : ID

    VAR             shift and go to state 121
    ID              shift and go to state 15
    PROCEDURE       shift and go to state 23
    FUNCTION        shift and go to state 24

    param_list                     shift and go to state 125
    param                          shift and go to state 119
    id_list                        shift and go to state 120
    proc_heading                   shift and go to state 122
    func_heading                   shift and go to state 123

state 79

    (10) constant -> sign INT .

    ;               reduce using rule 10 (constant -> sign INT .)
    DOTDOT          reduce using rule 10 (constant -> sign INT .)
    ]               reduce using rule 10 (constant -> sign INT .)
    ,               reduce using rule 10 (constant -> sign INT .)


state 80

    (12) constant -> sign REAL .

    ;               reduce using rule 12 (constant -> sign REAL .)
    DOTDOT          reduce using rule 12 (constant -> sign REAL .)
    ]               reduce using rule 12 (constant -> sign REAL .)
    ,               reduce using rule 12 (constant -> sign REAL .)


state 81

    (89) compound_statement -> BEGIN statement_list END .

    .               reduce using rule 89 (compound_statement -> BEGIN statement_list END .)
    ;               reduce using rule 89 (compound_statement -> BEGIN statement_list END .)
    END             reduce using rule 89 (compound_statement -> BEGIN statement_list END .)
    ELSE            reduce using rule 89 (compound_statement -> BEGIN statement_list END .)


state 82

    (91) statement_list -> statement_list ; . statement
    (92) statement -> .
    (93) statement -> . assignment_statement
    (94) statement -> . proc_statement
    (95) statement -> . read_statement
    (96) statement -> . write_statement
    (97) statement -> . labeled_statement
    (98) statement -> . compound_statement
    (99) statement -> . if_statement
    (100) statement -> . while_statement
    (101) statement -> . for_statement
    (102) assignment_statement -> . var_access ASSIGN expr
    (103) proc_statement -> . ID
    (104) proc_statement -> . ID ( expr_list )
    (106) read_statement -> . READ ( var_access_list )
    (107) read_statement -> . READLN
    (108) read_statement -> . READLN ( var_access_list )
    (109) write_statement -> . WRITE ( write_list )
    (110) write_statement -> . WRITELN
    (111) write_statement -> . WRITELN ( write_list )
    (105) labeled_statement -> . INT : statement
    (89) compound_statement -> . BEGIN statement_list END
    (119) if_statement -> . IF expr THEN statement
    (120) if_statement -> . IF expr THEN statement ELSE statement
    (121) while_statement -> . WHILE expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    END             reduce using rule 92 (statement -> .)
    ;               reduce using rule 92 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 126
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 83

    (102) assignment_statement -> var_access ASSIGN . expr
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    var_access                     shift and go to state 96
    expr                           shift and go to state 127
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95

state 84

    (55) var_access -> var_access [ . expr_list ]
    (56) expr_list -> . expr
    (57) expr_list -> . expr_list , expr
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    var_access                     shift and go to state 96
    expr_list                      shift and go to state 128
    expr                           shift and go to state 129
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95

state 85

    (104) proc_statement -> ID ( . expr_list )
    (56) expr_list -> . expr
    (57) expr_list -> . expr_list , expr
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    expr_list                      shift and go to state 130
    expr                           shift and go to state 129
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 86

    (106) read_statement -> READ ( . var_access_list )
    (112) var_access_list -> . var_access
    (113) var_access_list -> . var_access_list , var_access
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    ID              shift and go to state 133

    var_access_list                shift and go to state 131
    var_access                     shift and go to state 132

state 87

    (108) read_statement -> READLN ( . var_access_list )
    (112) var_access_list -> . var_access
    (113) var_access_list -> . var_access_list , var_access
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    ID              shift and go to state 133

    var_access_list                shift and go to state 134
    var_access                     shift and go to state 132

state 88

    (109) write_statement -> WRITE ( . write_list )
    (114) write_list -> . write_param
    (115) write_list -> . write_list , write_param
    (116) write_param -> . expr
    (117) write_param -> . expr : expr
    (118) write_param -> . expr : expr : expr
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    write_list                     shift and go to state 135
    write_param                    shift and go to state 136
    expr                           shift and go to state 137
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 89

    (111) write_statement -> WRITELN ( . write_list )
    (114) write_list -> . write_param
    (115) write_list -> . write_list , write_param
    (116) write_param -> . expr
    (117) write_param -> . expr : expr
    (118) write_param -> . expr : expr : expr
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    write_list                     shift and go to state 138
    write_param                    shift and go to state 136
    expr                           shift and go to state 137
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 90

    (105) labeled_statement -> INT : . statement
    (92) statement -> .
    (93) statement -> . assignment_statement
    (94) statement -> . proc_statement
    (95) statement -> . read_statement
    (96) statement -> . write_statement
    (97) statement -> . labeled_statement
    (98) statement -> . compound_statement
    (99) statement -> . if_statement
    (100) statement -> . while_statement
    (101) statement -> . for_statement
    (102) assignment_statement -> . var_access ASSIGN expr
    (103) proc_statement -> . ID
    (104) proc_statement -> . ID ( expr_list )
    (106) read_statement -> . READ ( var_access_list )
    (107) read_statement -> . READLN
    (108) read_statement -> . READLN ( var_access_list )
    (109) write_statement -> . WRITE ( write_list )
    (110) write_statement -> . WRITELN
    (111) write_statement -> . WRITELN ( write_list )
    (105) labeled_statement -> . INT : statement
    (89) compound_statement -> . BEGIN statement_list END
    (119) if_statement -> . IF expr THEN statement
    (120) if_statement -> . IF expr THEN statement ELSE statement
    (121) while_statement -> . WHILE expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    END             reduce using rule 92 (statement -> .)
    ;               reduce using rule 92 (statement -> .)
    ELSE            reduce using rule 92 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 139
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 91

    (119) if_statement -> IF expr . THEN statement
    (120) if_statement -> IF expr . THEN statement ELSE statement

    THEN            shift and go to state 140


state 92

    (58) expr -> simple_expr .
    (59) expr -> simple_expr . relation_op simple_expr
    (83) relation_op -> . =
    (84) relation_op -> . NE
    (85) relation_op -> . <
    (86) relation_op -> . >
    (87) relation_op -> . LE
    (88) relation_op -> . GE

    THEN            reduce using rule 58 (expr -> simple_expr .)
    DO              reduce using rule 58 (expr -> simple_expr .)
    END             reduce using rule 58 (expr -> simple_expr .)
    ;               reduce using rule 58 (expr -> simple_expr .)
    ELSE            reduce using rule 58 (expr -> simple_expr .)
    ]               reduce using rule 58 (expr -> simple_expr .)
    ,               reduce using rule 58 (expr -> simple_expr .)
    )               reduce using rule 58 (expr -> simple_expr .)
    :               reduce using rule 58 (expr -> simple_expr .)
    TO              reduce using rule 58 (expr -> simple_expr .)
    DOWNTO          reduce using rule 58 (expr -> simple_expr .)
    =               shift and go to state 142
    NE              shift and go to state 143
    <               shift and go to state 144
    >               shift and go to state 145
    LE              shift and go to state 146
    GE              shift and go to state 147

    relation_op                    shift and go to state 141

state 93

    (60) simple_expr -> term . term_sequence
    (63) term_sequence -> .
    (64) term_sequence -> . add_op term term_sequence
    (75) add_op -> . +
    (76) add_op -> . -
    (77) add_op -> . OR

    =               reduce using rule 63 (term_sequence -> .)
    NE              reduce using rule 63 (term_sequence -> .)
    <               reduce using rule 63 (term_sequence -> .)
    >               reduce using rule 63 (term_sequence -> .)
    LE              reduce using rule 63 (term_sequence -> .)
    GE              reduce using rule 63 (term_sequence -> .)
    THEN            reduce using rule 63 (term_sequence -> .)
    DO              reduce using rule 63 (term_sequence -> .)
    END             reduce using rule 63 (term_sequence -> .)
    ;               reduce using rule 63 (term_sequence -> .)
    ELSE            reduce using rule 63 (term_sequence -> .)
    ]               reduce using rule 63 (term_sequence -> .)
    ,               reduce using rule 63 (term_sequence -> .)
    )               reduce using rule 63 (term_sequence -> .)
    :               reduce using rule 63 (term_sequence -> .)
    TO              reduce using rule 63 (term_sequence -> .)
    DOWNTO          reduce using rule 63 (term_sequence -> .)
    +               shift and go to state 150
    -               shift and go to state 151
    OR              shift and go to state 152

    term_sequence                  shift and go to state 148
    add_op                         shift and go to state 149

state 94

    (61) simple_expr -> sign . term term_sequence
    (62) term -> . factor factor_sequence
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    term                           shift and go to state 153
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 95

    (62) term -> factor . factor_sequence
    (73) factor_sequence -> .
    (74) factor_sequence -> . mul_op factor factor_sequence
    (78) mul_op -> . *
    (79) mul_op -> . /
    (80) mul_op -> . DIV
    (81) mul_op -> . MOD
    (82) mul_op -> . AND

    +               reduce using rule 73 (factor_sequence -> .)
    -               reduce using rule 73 (factor_sequence -> .)
    OR              reduce using rule 73 (factor_sequence -> .)
    =               reduce using rule 73 (factor_sequence -> .)
    NE              reduce using rule 73 (factor_sequence -> .)
    <               reduce using rule 73 (factor_sequence -> .)
    >               reduce using rule 73 (factor_sequence -> .)
    LE              reduce using rule 73 (factor_sequence -> .)
    GE              reduce using rule 73 (factor_sequence -> .)
    THEN            reduce using rule 73 (factor_sequence -> .)
    DO              reduce using rule 73 (factor_sequence -> .)
    END             reduce using rule 73 (factor_sequence -> .)
    ;               reduce using rule 73 (factor_sequence -> .)
    ELSE            reduce using rule 73 (factor_sequence -> .)
    ]               reduce using rule 73 (factor_sequence -> .)
    ,               reduce using rule 73 (factor_sequence -> .)
    )               reduce using rule 73 (factor_sequence -> .)
    :               reduce using rule 73 (factor_sequence -> .)
    TO              reduce using rule 73 (factor_sequence -> .)
    DOWNTO          reduce using rule 73 (factor_sequence -> .)
    *               shift and go to state 156
    /               shift and go to state 157
    DIV             shift and go to state 158
    MOD             shift and go to state 159
    AND             shift and go to state 160

    factor_sequence                shift and go to state 154
    mul_op                         shift and go to state 155

state 96

    (65) factor -> var_access .
    (55) var_access -> var_access . [ expr_list ]

    *               reduce using rule 65 (factor -> var_access .)
    /               reduce using rule 65 (factor -> var_access .)
    DIV             reduce using rule 65 (factor -> var_access .)
    MOD             reduce using rule 65 (factor -> var_access .)
    AND             reduce using rule 65 (factor -> var_access .)
    +               reduce using rule 65 (factor -> var_access .)
    -               reduce using rule 65 (factor -> var_access .)
    OR              reduce using rule 65 (factor -> var_access .)
    =               reduce using rule 65 (factor -> var_access .)
    NE              reduce using rule 65 (factor -> var_access .)
    <               reduce using rule 65 (factor -> var_access .)
    >               reduce using rule 65 (factor -> var_access .)
    LE              reduce using rule 65 (factor -> var_access .)
    GE              reduce using rule 65 (factor -> var_access .)
    THEN            reduce using rule 65 (factor -> var_access .)
    DO              reduce using rule 65 (factor -> var_access .)
    END             reduce using rule 65 (factor -> var_access .)
    ;               reduce using rule 65 (factor -> var_access .)
    ELSE            reduce using rule 65 (factor -> var_access .)
    ]               reduce using rule 65 (factor -> var_access .)
    ,               reduce using rule 65 (factor -> var_access .)
    )               reduce using rule 65 (factor -> var_access .)
    :               reduce using rule 65 (factor -> var_access .)
    TO              reduce using rule 65 (factor -> var_access .)
    DOWNTO          reduce using rule 65 (factor -> var_access .)
    [               shift and go to state 84


state 97

    (66) factor -> INT .

    *               reduce using rule 66 (factor -> INT .)
    /               reduce using rule 66 (factor -> INT .)
    DIV             reduce using rule 66 (factor -> INT .)
    MOD             reduce using rule 66 (factor -> INT .)
    AND             reduce using rule 66 (factor -> INT .)
    +               reduce using rule 66 (factor -> INT .)
    -               reduce using rule 66 (factor -> INT .)
    OR              reduce using rule 66 (factor -> INT .)
    =               reduce using rule 66 (factor -> INT .)
    NE              reduce using rule 66 (factor -> INT .)
    <               reduce using rule 66 (factor -> INT .)
    >               reduce using rule 66 (factor -> INT .)
    LE              reduce using rule 66 (factor -> INT .)
    GE              reduce using rule 66 (factor -> INT .)
    THEN            reduce using rule 66 (factor -> INT .)
    DO              reduce using rule 66 (factor -> INT .)
    END             reduce using rule 66 (factor -> INT .)
    ;               reduce using rule 66 (factor -> INT .)
    ELSE            reduce using rule 66 (factor -> INT .)
    ]               reduce using rule 66 (factor -> INT .)
    ,               reduce using rule 66 (factor -> INT .)
    )               reduce using rule 66 (factor -> INT .)
    :               reduce using rule 66 (factor -> INT .)
    TO              reduce using rule 66 (factor -> INT .)
    DOWNTO          reduce using rule 66 (factor -> INT .)


state 98

    (67) factor -> REAL .

    *               reduce using rule 67 (factor -> REAL .)
    /               reduce using rule 67 (factor -> REAL .)
    DIV             reduce using rule 67 (factor -> REAL .)
    MOD             reduce using rule 67 (factor -> REAL .)
    AND             reduce using rule 67 (factor -> REAL .)
    +               reduce using rule 67 (factor -> REAL .)
    -               reduce using rule 67 (factor -> REAL .)
    OR              reduce using rule 67 (factor -> REAL .)
    =               reduce using rule 67 (factor -> REAL .)
    NE              reduce using rule 67 (factor -> REAL .)
    <               reduce using rule 67 (factor -> REAL .)
    >               reduce using rule 67 (factor -> REAL .)
    LE              reduce using rule 67 (factor -> REAL .)
    GE              reduce using rule 67 (factor -> REAL .)
    THEN            reduce using rule 67 (factor -> REAL .)
    DO              reduce using rule 67 (factor -> REAL .)
    END             reduce using rule 67 (factor -> REAL .)
    ;               reduce using rule 67 (factor -> REAL .)
    ELSE            reduce using rule 67 (factor -> REAL .)
    ]               reduce using rule 67 (factor -> REAL .)
    ,               reduce using rule 67 (factor -> REAL .)
    )               reduce using rule 67 (factor -> REAL .)
    :               reduce using rule 67 (factor -> REAL .)
    TO              reduce using rule 67 (factor -> REAL .)
    DOWNTO          reduce using rule 67 (factor -> REAL .)


state 99

    (68) factor -> CHAR .

    *               reduce using rule 68 (factor -> CHAR .)
    /               reduce using rule 68 (factor -> CHAR .)
    DIV             reduce using rule 68 (factor -> CHAR .)
    MOD             reduce using rule 68 (factor -> CHAR .)
    AND             reduce using rule 68 (factor -> CHAR .)
    +               reduce using rule 68 (factor -> CHAR .)
    -               reduce using rule 68 (factor -> CHAR .)
    OR              reduce using rule 68 (factor -> CHAR .)
    =               reduce using rule 68 (factor -> CHAR .)
    NE              reduce using rule 68 (factor -> CHAR .)
    <               reduce using rule 68 (factor -> CHAR .)
    >               reduce using rule 68 (factor -> CHAR .)
    LE              reduce using rule 68 (factor -> CHAR .)
    GE              reduce using rule 68 (factor -> CHAR .)
    THEN            reduce using rule 68 (factor -> CHAR .)
    DO              reduce using rule 68 (factor -> CHAR .)
    END             reduce using rule 68 (factor -> CHAR .)
    ;               reduce using rule 68 (factor -> CHAR .)
    ELSE            reduce using rule 68 (factor -> CHAR .)
    ]               reduce using rule 68 (factor -> CHAR .)
    ,               reduce using rule 68 (factor -> CHAR .)
    )               reduce using rule 68 (factor -> CHAR .)
    :               reduce using rule 68 (factor -> CHAR .)
    TO              reduce using rule 68 (factor -> CHAR .)
    DOWNTO          reduce using rule 68 (factor -> CHAR .)


state 100

    (69) factor -> STRING .

    *               reduce using rule 69 (factor -> STRING .)
    /               reduce using rule 69 (factor -> STRING .)
    DIV             reduce using rule 69 (factor -> STRING .)
    MOD             reduce using rule 69 (factor -> STRING .)
    AND             reduce using rule 69 (factor -> STRING .)
    +               reduce using rule 69 (factor -> STRING .)
    -               reduce using rule 69 (factor -> STRING .)
    OR              reduce using rule 69 (factor -> STRING .)
    =               reduce using rule 69 (factor -> STRING .)
    NE              reduce using rule 69 (factor -> STRING .)
    <               reduce using rule 69 (factor -> STRING .)
    >               reduce using rule 69 (factor -> STRING .)
    LE              reduce using rule 69 (factor -> STRING .)
    GE              reduce using rule 69 (factor -> STRING .)
    THEN            reduce using rule 69 (factor -> STRING .)
    DO              reduce using rule 69 (factor -> STRING .)
    END             reduce using rule 69 (factor -> STRING .)
    ;               reduce using rule 69 (factor -> STRING .)
    ELSE            reduce using rule 69 (factor -> STRING .)
    ]               reduce using rule 69 (factor -> STRING .)
    ,               reduce using rule 69 (factor -> STRING .)
    )               reduce using rule 69 (factor -> STRING .)
    :               reduce using rule 69 (factor -> STRING .)
    TO              reduce using rule 69 (factor -> STRING .)
    DOWNTO          reduce using rule 69 (factor -> STRING .)


state 101

    (70) factor -> ID . ( expr_list )
    (54) var_access -> ID .

    (               shift and go to state 161
    [               reduce using rule 54 (var_access -> ID .)
    *               reduce using rule 54 (var_access -> ID .)
    /               reduce using rule 54 (var_access -> ID .)
    DIV             reduce using rule 54 (var_access -> ID .)
    MOD             reduce using rule 54 (var_access -> ID .)
    AND             reduce using rule 54 (var_access -> ID .)
    +               reduce using rule 54 (var_access -> ID .)
    -               reduce using rule 54 (var_access -> ID .)
    OR              reduce using rule 54 (var_access -> ID .)
    =               reduce using rule 54 (var_access -> ID .)
    NE              reduce using rule 54 (var_access -> ID .)
    <               reduce using rule 54 (var_access -> ID .)
    >               reduce using rule 54 (var_access -> ID .)
    LE              reduce using rule 54 (var_access -> ID .)
    GE              reduce using rule 54 (var_access -> ID .)
    THEN            reduce using rule 54 (var_access -> ID .)
    DO              reduce using rule 54 (var_access -> ID .)
    END             reduce using rule 54 (var_access -> ID .)
    ;               reduce using rule 54 (var_access -> ID .)
    ELSE            reduce using rule 54 (var_access -> ID .)
    ]               reduce using rule 54 (var_access -> ID .)
    ,               reduce using rule 54 (var_access -> ID .)
    )               reduce using rule 54 (var_access -> ID .)
    :               reduce using rule 54 (var_access -> ID .)
    TO              reduce using rule 54 (var_access -> ID .)
    DOWNTO          reduce using rule 54 (var_access -> ID .)


state 102

    (71) factor -> ( . expr )
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    expr                           shift and go to state 162
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 103

    (72) factor -> NOT . factor
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    factor                         shift and go to state 163
    var_access                     shift and go to state 96

state 104

    (121) while_statement -> WHILE expr . DO statement

    DO              shift and go to state 164


state 105

    (122) for_statement -> FOR ID . ASSIGN expr TO expr DO statement
    (123) for_statement -> FOR ID . ASSIGN expr DOWNTO expr DO statement

    ASSIGN          shift and go to state 165


state 106

    (22) var_list -> var_list var_dec ; .

    ID              reduce using rule 22 (var_list -> var_list var_dec ; .)
    BEGIN           reduce using rule 22 (var_list -> var_list var_dec ; .)


state 107

    (23) var_dec -> id_list : tipo .

    ;               reduce using rule 23 (var_dec -> id_list : tipo .)


state 108

    (26) tipo -> ID .
    (16) constant -> ID .

    ;               reduce using rule 26 (tipo -> ID .)
    DOTDOT          reduce using rule 16 (constant -> ID .)


state 109

    (27) tipo -> new_type .

    ;               reduce using rule 27 (tipo -> new_type .)


state 110

    (28) new_type -> enumerated_type .

    ;               reduce using rule 28 (new_type -> enumerated_type .)


state 111

    (29) new_type -> subrange_type .

    ;               reduce using rule 29 (new_type -> subrange_type .)


state 112

    (30) new_type -> array_type .

    ;               reduce using rule 30 (new_type -> array_type .)


state 113

    (31) enumerated_type -> ( . id_list )
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 166

state 114

    (32) subrange_type -> constant . DOTDOT constant

    DOTDOT          shift and go to state 167


state 115

    (33) array_type -> ARRAY . [ ordinal_type_list ] OF tipo

    [               shift and go to state 168


state 116

    (42) proc_dec -> proc_heading ; block ; .

    VAR             reduce using rule 42 (proc_dec -> proc_heading ; block ; .)
    PROCEDURE       reduce using rule 42 (proc_dec -> proc_heading ; block ; .)
    FUNCTION        reduce using rule 42 (proc_dec -> proc_heading ; block ; .)
    BEGIN           reduce using rule 42 (proc_dec -> proc_heading ; block ; .)


state 117

    (43) func_dec -> func_heading ; block ; .

    VAR             reduce using rule 43 (func_dec -> func_heading ; block ; .)
    PROCEDURE       reduce using rule 43 (func_dec -> func_heading ; block ; .)
    FUNCTION        reduce using rule 43 (func_dec -> func_heading ; block ; .)
    BEGIN           reduce using rule 43 (func_dec -> func_heading ; block ; .)


state 118

    (45) proc_heading -> PROCEDURE ID ( param_list . )
    (49) param_list -> param_list . ; param

    )               shift and go to state 169
    ;               shift and go to state 170


state 119

    (48) param_list -> param .

    )               reduce using rule 48 (param_list -> param .)
    ;               reduce using rule 48 (param_list -> param .)


state 120

    (50) param -> id_list . : ID

    :               shift and go to state 171


state 121

    (51) param -> VAR . id_list : ID
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 172

state 122

    (52) param -> proc_heading .

    )               reduce using rule 52 (param -> proc_heading .)
    ;               reduce using rule 52 (param -> proc_heading .)


state 123

    (53) param -> func_heading .

    )               reduce using rule 53 (param -> func_heading .)
    ;               reduce using rule 53 (param -> func_heading .)


state 124

    (46) func_heading -> FUNCTION ID : ID .

    ;               reduce using rule 46 (func_heading -> FUNCTION ID : ID .)
    )               reduce using rule 46 (func_heading -> FUNCTION ID : ID .)


state 125

    (47) func_heading -> FUNCTION ID ( param_list . ) : ID
    (49) param_list -> param_list . ; param

    )               shift and go to state 173
    ;               shift and go to state 170


state 126

    (91) statement_list -> statement_list ; statement .

    END             reduce using rule 91 (statement_list -> statement_list ; statement .)
    ;               reduce using rule 91 (statement_list -> statement_list ; statement .)


state 127

    (102) assignment_statement -> var_access ASSIGN expr .

    END             reduce using rule 102 (assignment_statement -> var_access ASSIGN expr .)
    ;               reduce using rule 102 (assignment_statement -> var_access ASSIGN expr .)
    ELSE            reduce using rule 102 (assignment_statement -> var_access ASSIGN expr .)


state 128

    (55) var_access -> var_access [ expr_list . ]
    (57) expr_list -> expr_list . , expr

    ]               shift and go to state 174
    ,               shift and go to state 175


state 129

    (56) expr_list -> expr .

    ]               reduce using rule 56 (expr_list -> expr .)
    ,               reduce using rule 56 (expr_list -> expr .)
    )               reduce using rule 56 (expr_list -> expr .)


state 130

    (104) proc_statement -> ID ( expr_list . )
    (57) expr_list -> expr_list . , expr

    )               shift and go to state 176
    ,               shift and go to state 175


state 131

    (106) read_statement -> READ ( var_access_list . )
    (113) var_access_list -> var_access_list . , var_access

    )               shift and go to state 177
    ,               shift and go to state 178


state 132

    (112) var_access_list -> var_access .
    (55) var_access -> var_access . [ expr_list ]

    )               reduce using rule 112 (var_access_list -> var_access .)
    ,               reduce using rule 112 (var_access_list -> var_access .)
    [               shift and go to state 84


state 133

    (54) var_access -> ID .

    [               reduce using rule 54 (var_access -> ID .)
    )               reduce using rule 54 (var_access -> ID .)
    ,               reduce using rule 54 (var_access -> ID .)


state 134

    (108) read_statement -> READLN ( var_access_list . )
    (113) var_access_list -> var_access_list . , var_access

    )               shift and go to state 179
    ,               shift and go to state 178


state 135

    (109) write_statement -> WRITE ( write_list . )
    (115) write_list -> write_list . , write_param

    )               shift and go to state 180
    ,               shift and go to state 181


state 136

    (114) write_list -> write_param .

    )               reduce using rule 114 (write_list -> write_param .)
    ,               reduce using rule 114 (write_list -> write_param .)


state 137

    (116) write_param -> expr .
    (117) write_param -> expr . : expr
    (118) write_param -> expr . : expr : expr

    )               reduce using rule 116 (write_param -> expr .)
    ,               reduce using rule 116 (write_param -> expr .)
    :               shift and go to state 182


state 138

    (111) write_statement -> WRITELN ( write_list . )
    (115) write_list -> write_list . , write_param

    )               shift and go to state 183
    ,               shift and go to state 181


state 139

    (105) labeled_statement -> INT : statement .

    END             reduce using rule 105 (labeled_statement -> INT : statement .)
    ;               reduce using rule 105 (labeled_statement -> INT : statement .)
    ELSE            reduce using rule 105 (labeled_statement -> INT : statement .)


state 140

    (119) if_statement -> IF expr THEN . statement
    (120) if_statement -> IF expr THEN . statement ELSE statement
    (92) statement -> .
    (93) statement -> . assignment_statement
    (94) statement -> . proc_statement
    (95) statement -> . read_statement
    (96) statement -> . write_statement
    (97) statement -> . labeled_statement
    (98) statement -> . compound_statement
    (99) statement -> . if_statement
    (100) statement -> . while_statement
    (101) statement -> . for_statement
    (102) assignment_statement -> . var_access ASSIGN expr
    (103) proc_statement -> . ID
    (104) proc_statement -> . ID ( expr_list )
    (106) read_statement -> . READ ( var_access_list )
    (107) read_statement -> . READLN
    (108) read_statement -> . READLN ( var_access_list )
    (109) write_statement -> . WRITE ( write_list )
    (110) write_statement -> . WRITELN
    (111) write_statement -> . WRITELN ( write_list )
    (105) labeled_statement -> . INT : statement
    (89) compound_statement -> . BEGIN statement_list END
    (119) if_statement -> . IF expr THEN statement
    (120) if_statement -> . IF expr THEN statement ELSE statement
    (121) while_statement -> . WHILE expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    END             reduce using rule 92 (statement -> .)
    ;               reduce using rule 92 (statement -> .)
    ELSE            reduce using rule 92 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 184
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 141

    (59) expr -> simple_expr relation_op . simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    simple_expr                    shift and go to state 185
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 142

    (83) relation_op -> = .

    +               reduce using rule 83 (relation_op -> = .)
    -               reduce using rule 83 (relation_op -> = .)
    INT             reduce using rule 83 (relation_op -> = .)
    REAL            reduce using rule 83 (relation_op -> = .)
    CHAR            reduce using rule 83 (relation_op -> = .)
    STRING          reduce using rule 83 (relation_op -> = .)
    ID              reduce using rule 83 (relation_op -> = .)
    (               reduce using rule 83 (relation_op -> = .)
    NOT             reduce using rule 83 (relation_op -> = .)


state 143

    (84) relation_op -> NE .

    +               reduce using rule 84 (relation_op -> NE .)
    -               reduce using rule 84 (relation_op -> NE .)
    INT             reduce using rule 84 (relation_op -> NE .)
    REAL            reduce using rule 84 (relation_op -> NE .)
    CHAR            reduce using rule 84 (relation_op -> NE .)
    STRING          reduce using rule 84 (relation_op -> NE .)
    ID              reduce using rule 84 (relation_op -> NE .)
    (               reduce using rule 84 (relation_op -> NE .)
    NOT             reduce using rule 84 (relation_op -> NE .)


state 144

    (85) relation_op -> < .

    +               reduce using rule 85 (relation_op -> < .)
    -               reduce using rule 85 (relation_op -> < .)
    INT             reduce using rule 85 (relation_op -> < .)
    REAL            reduce using rule 85 (relation_op -> < .)
    CHAR            reduce using rule 85 (relation_op -> < .)
    STRING          reduce using rule 85 (relation_op -> < .)
    ID              reduce using rule 85 (relation_op -> < .)
    (               reduce using rule 85 (relation_op -> < .)
    NOT             reduce using rule 85 (relation_op -> < .)


state 145

    (86) relation_op -> > .

    +               reduce using rule 86 (relation_op -> > .)
    -               reduce using rule 86 (relation_op -> > .)
    INT             reduce using rule 86 (relation_op -> > .)
    REAL            reduce using rule 86 (relation_op -> > .)
    CHAR            reduce using rule 86 (relation_op -> > .)
    STRING          reduce using rule 86 (relation_op -> > .)
    ID              reduce using rule 86 (relation_op -> > .)
    (               reduce using rule 86 (relation_op -> > .)
    NOT             reduce using rule 86 (relation_op -> > .)


state 146

    (87) relation_op -> LE .

    +               reduce using rule 87 (relation_op -> LE .)
    -               reduce using rule 87 (relation_op -> LE .)
    INT             reduce using rule 87 (relation_op -> LE .)
    REAL            reduce using rule 87 (relation_op -> LE .)
    CHAR            reduce using rule 87 (relation_op -> LE .)
    STRING          reduce using rule 87 (relation_op -> LE .)
    ID              reduce using rule 87 (relation_op -> LE .)
    (               reduce using rule 87 (relation_op -> LE .)
    NOT             reduce using rule 87 (relation_op -> LE .)


state 147

    (88) relation_op -> GE .

    +               reduce using rule 88 (relation_op -> GE .)
    -               reduce using rule 88 (relation_op -> GE .)
    INT             reduce using rule 88 (relation_op -> GE .)
    REAL            reduce using rule 88 (relation_op -> GE .)
    CHAR            reduce using rule 88 (relation_op -> GE .)
    STRING          reduce using rule 88 (relation_op -> GE .)
    ID              reduce using rule 88 (relation_op -> GE .)
    (               reduce using rule 88 (relation_op -> GE .)
    NOT             reduce using rule 88 (relation_op -> GE .)


state 148

    (60) simple_expr -> term term_sequence .

    =               reduce using rule 60 (simple_expr -> term term_sequence .)
    NE              reduce using rule 60 (simple_expr -> term term_sequence .)
    <               reduce using rule 60 (simple_expr -> term term_sequence .)
    >               reduce using rule 60 (simple_expr -> term term_sequence .)
    LE              reduce using rule 60 (simple_expr -> term term_sequence .)
    GE              reduce using rule 60 (simple_expr -> term term_sequence .)
    THEN            reduce using rule 60 (simple_expr -> term term_sequence .)
    DO              reduce using rule 60 (simple_expr -> term term_sequence .)
    END             reduce using rule 60 (simple_expr -> term term_sequence .)
    ;               reduce using rule 60 (simple_expr -> term term_sequence .)
    ELSE            reduce using rule 60 (simple_expr -> term term_sequence .)
    ]               reduce using rule 60 (simple_expr -> term term_sequence .)
    ,               reduce using rule 60 (simple_expr -> term term_sequence .)
    )               reduce using rule 60 (simple_expr -> term term_sequence .)
    :               reduce using rule 60 (simple_expr -> term term_sequence .)
    TO              reduce using rule 60 (simple_expr -> term term_sequence .)
    DOWNTO          reduce using rule 60 (simple_expr -> term term_sequence .)


state 149

    (64) term_sequence -> add_op . term term_sequence
    (62) term -> . factor factor_sequence
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    term                           shift and go to state 186
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 150

    (75) add_op -> + .

    INT             reduce using rule 75 (add_op -> + .)
    REAL            reduce using rule 75 (add_op -> + .)
    CHAR            reduce using rule 75 (add_op -> + .)
    STRING          reduce using rule 75 (add_op -> + .)
    ID              reduce using rule 75 (add_op -> + .)
    (               reduce using rule 75 (add_op -> + .)
    NOT             reduce using rule 75 (add_op -> + .)


state 151

    (76) add_op -> - .

    INT             reduce using rule 76 (add_op -> - .)
    REAL            reduce using rule 76 (add_op -> - .)
    CHAR            reduce using rule 76 (add_op -> - .)
    STRING          reduce using rule 76 (add_op -> - .)
    ID              reduce using rule 76 (add_op -> - .)
    (               reduce using rule 76 (add_op -> - .)
    NOT             reduce using rule 76 (add_op -> - .)


state 152

    (77) add_op -> OR .

    INT             reduce using rule 77 (add_op -> OR .)
    REAL            reduce using rule 77 (add_op -> OR .)
    CHAR            reduce using rule 77 (add_op -> OR .)
    STRING          reduce using rule 77 (add_op -> OR .)
    ID              reduce using rule 77 (add_op -> OR .)
    (               reduce using rule 77 (add_op -> OR .)
    NOT             reduce using rule 77 (add_op -> OR .)


state 153

    (61) simple_expr -> sign term . term_sequence
    (63) term_sequence -> .
    (64) term_sequence -> . add_op term term_sequence
    (75) add_op -> . +
    (76) add_op -> . -
    (77) add_op -> . OR

    =               reduce using rule 63 (term_sequence -> .)
    NE              reduce using rule 63 (term_sequence -> .)
    <               reduce using rule 63 (term_sequence -> .)
    >               reduce using rule 63 (term_sequence -> .)
    LE              reduce using rule 63 (term_sequence -> .)
    GE              reduce using rule 63 (term_sequence -> .)
    THEN            reduce using rule 63 (term_sequence -> .)
    DO              reduce using rule 63 (term_sequence -> .)
    END             reduce using rule 63 (term_sequence -> .)
    ;               reduce using rule 63 (term_sequence -> .)
    ELSE            reduce using rule 63 (term_sequence -> .)
    ]               reduce using rule 63 (term_sequence -> .)
    ,               reduce using rule 63 (term_sequence -> .)
    )               reduce using rule 63 (term_sequence -> .)
    :               reduce using rule 63 (term_sequence -> .)
    TO              reduce using rule 63 (term_sequence -> .)
    DOWNTO          reduce using rule 63 (term_sequence -> .)
    +               shift and go to state 150
    -               shift and go to state 151
    OR              shift and go to state 152

    term_sequence                  shift and go to state 187
    add_op                         shift and go to state 149

state 154

    (62) term -> factor factor_sequence .

    +               reduce using rule 62 (term -> factor factor_sequence .)
    -               reduce using rule 62 (term -> factor factor_sequence .)
    OR              reduce using rule 62 (term -> factor factor_sequence .)
    =               reduce using rule 62 (term -> factor factor_sequence .)
    NE              reduce using rule 62 (term -> factor factor_sequence .)
    <               reduce using rule 62 (term -> factor factor_sequence .)
    >               reduce using rule 62 (term -> factor factor_sequence .)
    LE              reduce using rule 62 (term -> factor factor_sequence .)
    GE              reduce using rule 62 (term -> factor factor_sequence .)
    THEN            reduce using rule 62 (term -> factor factor_sequence .)
    DO              reduce using rule 62 (term -> factor factor_sequence .)
    END             reduce using rule 62 (term -> factor factor_sequence .)
    ;               reduce using rule 62 (term -> factor factor_sequence .)
    ELSE            reduce using rule 62 (term -> factor factor_sequence .)
    ]               reduce using rule 62 (term -> factor factor_sequence .)
    ,               reduce using rule 62 (term -> factor factor_sequence .)
    )               reduce using rule 62 (term -> factor factor_sequence .)
    :               reduce using rule 62 (term -> factor factor_sequence .)
    TO              reduce using rule 62 (term -> factor factor_sequence .)
    DOWNTO          reduce using rule 62 (term -> factor factor_sequence .)


state 155

    (74) factor_sequence -> mul_op . factor factor_sequence
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    factor                         shift and go to state 188
    var_access                     shift and go to state 96

state 156

    (78) mul_op -> * .

    INT             reduce using rule 78 (mul_op -> * .)
    REAL            reduce using rule 78 (mul_op -> * .)
    CHAR            reduce using rule 78 (mul_op -> * .)
    STRING          reduce using rule 78 (mul_op -> * .)
    ID              reduce using rule 78 (mul_op -> * .)
    (               reduce using rule 78 (mul_op -> * .)
    NOT             reduce using rule 78 (mul_op -> * .)


state 157

    (79) mul_op -> / .

    INT             reduce using rule 79 (mul_op -> / .)
    REAL            reduce using rule 79 (mul_op -> / .)
    CHAR            reduce using rule 79 (mul_op -> / .)
    STRING          reduce using rule 79 (mul_op -> / .)
    ID              reduce using rule 79 (mul_op -> / .)
    (               reduce using rule 79 (mul_op -> / .)
    NOT             reduce using rule 79 (mul_op -> / .)


state 158

    (80) mul_op -> DIV .

    INT             reduce using rule 80 (mul_op -> DIV .)
    REAL            reduce using rule 80 (mul_op -> DIV .)
    CHAR            reduce using rule 80 (mul_op -> DIV .)
    STRING          reduce using rule 80 (mul_op -> DIV .)
    ID              reduce using rule 80 (mul_op -> DIV .)
    (               reduce using rule 80 (mul_op -> DIV .)
    NOT             reduce using rule 80 (mul_op -> DIV .)


state 159

    (81) mul_op -> MOD .

    INT             reduce using rule 81 (mul_op -> MOD .)
    REAL            reduce using rule 81 (mul_op -> MOD .)
    CHAR            reduce using rule 81 (mul_op -> MOD .)
    STRING          reduce using rule 81 (mul_op -> MOD .)
    ID              reduce using rule 81 (mul_op -> MOD .)
    (               reduce using rule 81 (mul_op -> MOD .)
    NOT             reduce using rule 81 (mul_op -> MOD .)


state 160

    (82) mul_op -> AND .

    INT             reduce using rule 82 (mul_op -> AND .)
    REAL            reduce using rule 82 (mul_op -> AND .)
    CHAR            reduce using rule 82 (mul_op -> AND .)
    STRING          reduce using rule 82 (mul_op -> AND .)
    ID              reduce using rule 82 (mul_op -> AND .)
    (               reduce using rule 82 (mul_op -> AND .)
    NOT             reduce using rule 82 (mul_op -> AND .)


state 161

    (70) factor -> ID ( . expr_list )
    (56) expr_list -> . expr
    (57) expr_list -> . expr_list , expr
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    expr_list                      shift and go to state 189
    expr                           shift and go to state 129
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 162

    (71) factor -> ( expr . )

    )               shift and go to state 190


state 163

    (72) factor -> NOT factor .

    *               reduce using rule 72 (factor -> NOT factor .)
    /               reduce using rule 72 (factor -> NOT factor .)
    DIV             reduce using rule 72 (factor -> NOT factor .)
    MOD             reduce using rule 72 (factor -> NOT factor .)
    AND             reduce using rule 72 (factor -> NOT factor .)
    +               reduce using rule 72 (factor -> NOT factor .)
    -               reduce using rule 72 (factor -> NOT factor .)
    OR              reduce using rule 72 (factor -> NOT factor .)
    =               reduce using rule 72 (factor -> NOT factor .)
    NE              reduce using rule 72 (factor -> NOT factor .)
    <               reduce using rule 72 (factor -> NOT factor .)
    >               reduce using rule 72 (factor -> NOT factor .)
    LE              reduce using rule 72 (factor -> NOT factor .)
    GE              reduce using rule 72 (factor -> NOT factor .)
    THEN            reduce using rule 72 (factor -> NOT factor .)
    DO              reduce using rule 72 (factor -> NOT factor .)
    END             reduce using rule 72 (factor -> NOT factor .)
    ;               reduce using rule 72 (factor -> NOT factor .)
    ELSE            reduce using rule 72 (factor -> NOT factor .)
    ]               reduce using rule 72 (factor -> NOT factor .)
    ,               reduce using rule 72 (factor -> NOT factor .)
    )               reduce using rule 72 (factor -> NOT factor .)
    :               reduce using rule 72 (factor -> NOT factor .)
    TO              reduce using rule 72 (factor -> NOT factor .)
    DOWNTO          reduce using rule 72 (factor -> NOT factor .)


state 164

    (121) while_statement -> WHILE expr DO . statement
    (92) statement -> .
    (93) statement -> . assignment_statement
    (94) statement -> . proc_statement
    (95) statement -> . read_statement
    (96) statement -> . write_statement
    (97) statement -> . labeled_statement
    (98) statement -> . compound_statement
    (99) statement -> . if_statement
    (100) statement -> . while_statement
    (101) statement -> . for_statement
    (102) assignment_statement -> . var_access ASSIGN expr
    (103) proc_statement -> . ID
    (104) proc_statement -> . ID ( expr_list )
    (106) read_statement -> . READ ( var_access_list )
    (107) read_statement -> . READLN
    (108) read_statement -> . READLN ( var_access_list )
    (109) write_statement -> . WRITE ( write_list )
    (110) write_statement -> . WRITELN
    (111) write_statement -> . WRITELN ( write_list )
    (105) labeled_statement -> . INT : statement
    (89) compound_statement -> . BEGIN statement_list END
    (119) if_statement -> . IF expr THEN statement
    (120) if_statement -> . IF expr THEN statement ELSE statement
    (121) while_statement -> . WHILE expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    END             reduce using rule 92 (statement -> .)
    ;               reduce using rule 92 (statement -> .)
    ELSE            reduce using rule 92 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 191
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 165

    (122) for_statement -> FOR ID ASSIGN . expr TO expr DO statement
    (123) for_statement -> FOR ID ASSIGN . expr DOWNTO expr DO statement
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    expr                           shift and go to state 192
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 166

    (31) enumerated_type -> ( id_list . )

    )               shift and go to state 193


state 167

    (32) subrange_type -> constant DOTDOT . constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    ID              shift and go to state 40
    +               shift and go to state 47
    -               shift and go to state 48

    constant                       shift and go to state 194
    sign                           shift and go to state 42

state 168

    (33) array_type -> ARRAY [ . ordinal_type_list ] OF tipo
    (37) ordinal_type_list -> . ordinal_type
    (38) ordinal_type_list -> . ordinal_type_list , ordinal_type
    (34) ordinal_type -> . enumerated_type
    (35) ordinal_type -> . subrange_type
    (36) ordinal_type -> . ID
    (31) enumerated_type -> . ( id_list )
    (32) subrange_type -> . constant DOTDOT constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    ID              shift and go to state 199
    (               shift and go to state 113
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    +               shift and go to state 47
    -               shift and go to state 48

    ordinal_type_list              shift and go to state 195
    ordinal_type                   shift and go to state 196
    enumerated_type                shift and go to state 197
    subrange_type                  shift and go to state 198
    constant                       shift and go to state 114
    sign                           shift and go to state 42

state 169

    (45) proc_heading -> PROCEDURE ID ( param_list ) .

    ;               reduce using rule 45 (proc_heading -> PROCEDURE ID ( param_list ) .)
    )               reduce using rule 45 (proc_heading -> PROCEDURE ID ( param_list ) .)


state 170

    (49) param_list -> param_list ; . param
    (50) param -> . id_list : ID
    (51) param -> . VAR id_list : ID
    (52) param -> . proc_heading
    (53) param -> . func_heading
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list
    (44) proc_heading -> . PROCEDURE ID
    (45) proc_heading -> . PROCEDURE ID ( param_list )
    (46) func_heading -> . FUNCTION ID : ID
    (47) func_heading -> . FUNCTION ID ( param_list ) : ID

    VAR             shift and go to state 121
    ID              shift and go to state 15
    PROCEDURE       shift and go to state 23
    FUNCTION        shift and go to state 24

    param                          shift and go to state 200
    id_list                        shift and go to state 120
    proc_heading                   shift and go to state 122
    func_heading                   shift and go to state 123

state 171

    (50) param -> id_list : . ID

    ID              shift and go to state 201


state 172

    (51) param -> VAR id_list . : ID

    :               shift and go to state 202


state 173

    (47) func_heading -> FUNCTION ID ( param_list ) . : ID

    :               shift and go to state 203


state 174

    (55) var_access -> var_access [ expr_list ] .

    ASSIGN          reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    [               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    *               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    /               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    DIV             reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    MOD             reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    AND             reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    +               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    -               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    OR              reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    =               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    NE              reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    <               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    >               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    LE              reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    GE              reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    THEN            reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    DO              reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    END             reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    ;               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    ELSE            reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    ]               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    ,               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    )               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    :               reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    TO              reduce using rule 55 (var_access -> var_access [ expr_list ] .)
    DOWNTO          reduce using rule 55 (var_access -> var_access [ expr_list ] .)


state 175

    (57) expr_list -> expr_list , . expr
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    expr                           shift and go to state 204
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 176

    (104) proc_statement -> ID ( expr_list ) .

    END             reduce using rule 104 (proc_statement -> ID ( expr_list ) .)
    ;               reduce using rule 104 (proc_statement -> ID ( expr_list ) .)
    ELSE            reduce using rule 104 (proc_statement -> ID ( expr_list ) .)


state 177

    (106) read_statement -> READ ( var_access_list ) .

    END             reduce using rule 106 (read_statement -> READ ( var_access_list ) .)
    ;               reduce using rule 106 (read_statement -> READ ( var_access_list ) .)
    ELSE            reduce using rule 106 (read_statement -> READ ( var_access_list ) .)


state 178

    (113) var_access_list -> var_access_list , . var_access
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    ID              shift and go to state 133

    var_access                     shift and go to state 205

state 179

    (108) read_statement -> READLN ( var_access_list ) .

    END             reduce using rule 108 (read_statement -> READLN ( var_access_list ) .)
    ;               reduce using rule 108 (read_statement -> READLN ( var_access_list ) .)
    ELSE            reduce using rule 108 (read_statement -> READLN ( var_access_list ) .)


state 180

    (109) write_statement -> WRITE ( write_list ) .

    END             reduce using rule 109 (write_statement -> WRITE ( write_list ) .)
    ;               reduce using rule 109 (write_statement -> WRITE ( write_list ) .)
    ELSE            reduce using rule 109 (write_statement -> WRITE ( write_list ) .)


state 181

    (115) write_list -> write_list , . write_param
    (116) write_param -> . expr
    (117) write_param -> . expr : expr
    (118) write_param -> . expr : expr : expr
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    write_param                    shift and go to state 206
    expr                           shift and go to state 137
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 182

    (117) write_param -> expr : . expr
    (118) write_param -> expr : . expr : expr
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    expr                           shift and go to state 207
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 183

    (111) write_statement -> WRITELN ( write_list ) .

    END             reduce using rule 111 (write_statement -> WRITELN ( write_list ) .)
    ;               reduce using rule 111 (write_statement -> WRITELN ( write_list ) .)
    ELSE            reduce using rule 111 (write_statement -> WRITELN ( write_list ) .)


state 184

    (119) if_statement -> IF expr THEN statement .
    (120) if_statement -> IF expr THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    END             reduce using rule 119 (if_statement -> IF expr THEN statement .)
    ;               reduce using rule 119 (if_statement -> IF expr THEN statement .)
    ELSE            shift and go to state 208

  ! ELSE            [ reduce using rule 119 (if_statement -> IF expr THEN statement .) ]


state 185

    (59) expr -> simple_expr relation_op simple_expr .

    THEN            reduce using rule 59 (expr -> simple_expr relation_op simple_expr .)
    DO              reduce using rule 59 (expr -> simple_expr relation_op simple_expr .)
    END             reduce using rule 59 (expr -> simple_expr relation_op simple_expr .)
    ;               reduce using rule 59 (expr -> simple_expr relation_op simple_expr .)
    ELSE            reduce using rule 59 (expr -> simple_expr relation_op simple_expr .)
    ]               reduce using rule 59 (expr -> simple_expr relation_op simple_expr .)
    ,               reduce using rule 59 (expr -> simple_expr relation_op simple_expr .)
    )               reduce using rule 59 (expr -> simple_expr relation_op simple_expr .)
    :               reduce using rule 59 (expr -> simple_expr relation_op simple_expr .)
    TO              reduce using rule 59 (expr -> simple_expr relation_op simple_expr .)
    DOWNTO          reduce using rule 59 (expr -> simple_expr relation_op simple_expr .)


state 186

    (64) term_sequence -> add_op term . term_sequence
    (63) term_sequence -> .
    (64) term_sequence -> . add_op term term_sequence
    (75) add_op -> . +
    (76) add_op -> . -
    (77) add_op -> . OR

    =               reduce using rule 63 (term_sequence -> .)
    NE              reduce using rule 63 (term_sequence -> .)
    <               reduce using rule 63 (term_sequence -> .)
    >               reduce using rule 63 (term_sequence -> .)
    LE              reduce using rule 63 (term_sequence -> .)
    GE              reduce using rule 63 (term_sequence -> .)
    THEN            reduce using rule 63 (term_sequence -> .)
    DO              reduce using rule 63 (term_sequence -> .)
    END             reduce using rule 63 (term_sequence -> .)
    ;               reduce using rule 63 (term_sequence -> .)
    ELSE            reduce using rule 63 (term_sequence -> .)
    ]               reduce using rule 63 (term_sequence -> .)
    ,               reduce using rule 63 (term_sequence -> .)
    )               reduce using rule 63 (term_sequence -> .)
    :               reduce using rule 63 (term_sequence -> .)
    TO              reduce using rule 63 (term_sequence -> .)
    DOWNTO          reduce using rule 63 (term_sequence -> .)
    +               shift and go to state 150
    -               shift and go to state 151
    OR              shift and go to state 152

    add_op                         shift and go to state 149
    term_sequence                  shift and go to state 209

state 187

    (61) simple_expr -> sign term term_sequence .

    =               reduce using rule 61 (simple_expr -> sign term term_sequence .)
    NE              reduce using rule 61 (simple_expr -> sign term term_sequence .)
    <               reduce using rule 61 (simple_expr -> sign term term_sequence .)
    >               reduce using rule 61 (simple_expr -> sign term term_sequence .)
    LE              reduce using rule 61 (simple_expr -> sign term term_sequence .)
    GE              reduce using rule 61 (simple_expr -> sign term term_sequence .)
    THEN            reduce using rule 61 (simple_expr -> sign term term_sequence .)
    DO              reduce using rule 61 (simple_expr -> sign term term_sequence .)
    END             reduce using rule 61 (simple_expr -> sign term term_sequence .)
    ;               reduce using rule 61 (simple_expr -> sign term term_sequence .)
    ELSE            reduce using rule 61 (simple_expr -> sign term term_sequence .)
    ]               reduce using rule 61 (simple_expr -> sign term term_sequence .)
    ,               reduce using rule 61 (simple_expr -> sign term term_sequence .)
    )               reduce using rule 61 (simple_expr -> sign term term_sequence .)
    :               reduce using rule 61 (simple_expr -> sign term term_sequence .)
    TO              reduce using rule 61 (simple_expr -> sign term term_sequence .)
    DOWNTO          reduce using rule 61 (simple_expr -> sign term term_sequence .)


state 188

    (74) factor_sequence -> mul_op factor . factor_sequence
    (73) factor_sequence -> .
    (74) factor_sequence -> . mul_op factor factor_sequence
    (78) mul_op -> . *
    (79) mul_op -> . /
    (80) mul_op -> . DIV
    (81) mul_op -> . MOD
    (82) mul_op -> . AND

    +               reduce using rule 73 (factor_sequence -> .)
    -               reduce using rule 73 (factor_sequence -> .)
    OR              reduce using rule 73 (factor_sequence -> .)
    =               reduce using rule 73 (factor_sequence -> .)
    NE              reduce using rule 73 (factor_sequence -> .)
    <               reduce using rule 73 (factor_sequence -> .)
    >               reduce using rule 73 (factor_sequence -> .)
    LE              reduce using rule 73 (factor_sequence -> .)
    GE              reduce using rule 73 (factor_sequence -> .)
    THEN            reduce using rule 73 (factor_sequence -> .)
    DO              reduce using rule 73 (factor_sequence -> .)
    END             reduce using rule 73 (factor_sequence -> .)
    ;               reduce using rule 73 (factor_sequence -> .)
    ELSE            reduce using rule 73 (factor_sequence -> .)
    ]               reduce using rule 73 (factor_sequence -> .)
    ,               reduce using rule 73 (factor_sequence -> .)
    )               reduce using rule 73 (factor_sequence -> .)
    :               reduce using rule 73 (factor_sequence -> .)
    TO              reduce using rule 73 (factor_sequence -> .)
    DOWNTO          reduce using rule 73 (factor_sequence -> .)
    *               shift and go to state 156
    /               shift and go to state 157
    DIV             shift and go to state 158
    MOD             shift and go to state 159
    AND             shift and go to state 160

    mul_op                         shift and go to state 155
    factor_sequence                shift and go to state 210

state 189

    (70) factor -> ID ( expr_list . )
    (57) expr_list -> expr_list . , expr

    )               shift and go to state 211
    ,               shift and go to state 175


state 190

    (71) factor -> ( expr ) .

    *               reduce using rule 71 (factor -> ( expr ) .)
    /               reduce using rule 71 (factor -> ( expr ) .)
    DIV             reduce using rule 71 (factor -> ( expr ) .)
    MOD             reduce using rule 71 (factor -> ( expr ) .)
    AND             reduce using rule 71 (factor -> ( expr ) .)
    +               reduce using rule 71 (factor -> ( expr ) .)
    -               reduce using rule 71 (factor -> ( expr ) .)
    OR              reduce using rule 71 (factor -> ( expr ) .)
    =               reduce using rule 71 (factor -> ( expr ) .)
    NE              reduce using rule 71 (factor -> ( expr ) .)
    <               reduce using rule 71 (factor -> ( expr ) .)
    >               reduce using rule 71 (factor -> ( expr ) .)
    LE              reduce using rule 71 (factor -> ( expr ) .)
    GE              reduce using rule 71 (factor -> ( expr ) .)
    THEN            reduce using rule 71 (factor -> ( expr ) .)
    DO              reduce using rule 71 (factor -> ( expr ) .)
    END             reduce using rule 71 (factor -> ( expr ) .)
    ;               reduce using rule 71 (factor -> ( expr ) .)
    ELSE            reduce using rule 71 (factor -> ( expr ) .)
    ]               reduce using rule 71 (factor -> ( expr ) .)
    ,               reduce using rule 71 (factor -> ( expr ) .)
    )               reduce using rule 71 (factor -> ( expr ) .)
    :               reduce using rule 71 (factor -> ( expr ) .)
    TO              reduce using rule 71 (factor -> ( expr ) .)
    DOWNTO          reduce using rule 71 (factor -> ( expr ) .)


state 191

    (121) while_statement -> WHILE expr DO statement .

    END             reduce using rule 121 (while_statement -> WHILE expr DO statement .)
    ;               reduce using rule 121 (while_statement -> WHILE expr DO statement .)
    ELSE            reduce using rule 121 (while_statement -> WHILE expr DO statement .)


state 192

    (122) for_statement -> FOR ID ASSIGN expr . TO expr DO statement
    (123) for_statement -> FOR ID ASSIGN expr . DOWNTO expr DO statement

    TO              shift and go to state 212
    DOWNTO          shift and go to state 213


state 193

    (31) enumerated_type -> ( id_list ) .

    ;               reduce using rule 31 (enumerated_type -> ( id_list ) .)
    ]               reduce using rule 31 (enumerated_type -> ( id_list ) .)
    ,               reduce using rule 31 (enumerated_type -> ( id_list ) .)


state 194

    (32) subrange_type -> constant DOTDOT constant .

    ;               reduce using rule 32 (subrange_type -> constant DOTDOT constant .)
    ]               reduce using rule 32 (subrange_type -> constant DOTDOT constant .)
    ,               reduce using rule 32 (subrange_type -> constant DOTDOT constant .)


state 195

    (33) array_type -> ARRAY [ ordinal_type_list . ] OF tipo
    (38) ordinal_type_list -> ordinal_type_list . , ordinal_type

    ]               shift and go to state 214
    ,               shift and go to state 215


state 196

    (37) ordinal_type_list -> ordinal_type .

    ]               reduce using rule 37 (ordinal_type_list -> ordinal_type .)
    ,               reduce using rule 37 (ordinal_type_list -> ordinal_type .)


state 197

    (34) ordinal_type -> enumerated_type .

    ]               reduce using rule 34 (ordinal_type -> enumerated_type .)
    ,               reduce using rule 34 (ordinal_type -> enumerated_type .)


state 198

    (35) ordinal_type -> subrange_type .

    ]               reduce using rule 35 (ordinal_type -> subrange_type .)
    ,               reduce using rule 35 (ordinal_type -> subrange_type .)


state 199

    (36) ordinal_type -> ID .
    (16) constant -> ID .

    ]               reduce using rule 36 (ordinal_type -> ID .)
    ,               reduce using rule 36 (ordinal_type -> ID .)
    DOTDOT          reduce using rule 16 (constant -> ID .)


state 200

    (49) param_list -> param_list ; param .

    )               reduce using rule 49 (param_list -> param_list ; param .)
    ;               reduce using rule 49 (param_list -> param_list ; param .)


state 201

    (50) param -> id_list : ID .

    )               reduce using rule 50 (param -> id_list : ID .)
    ;               reduce using rule 50 (param -> id_list : ID .)


state 202

    (51) param -> VAR id_list : . ID

    ID              shift and go to state 216


state 203

    (47) func_heading -> FUNCTION ID ( param_list ) : . ID

    ID              shift and go to state 217


state 204

    (57) expr_list -> expr_list , expr .

    ]               reduce using rule 57 (expr_list -> expr_list , expr .)
    ,               reduce using rule 57 (expr_list -> expr_list , expr .)
    )               reduce using rule 57 (expr_list -> expr_list , expr .)


state 205

    (113) var_access_list -> var_access_list , var_access .
    (55) var_access -> var_access . [ expr_list ]

    )               reduce using rule 113 (var_access_list -> var_access_list , var_access .)
    ,               reduce using rule 113 (var_access_list -> var_access_list , var_access .)
    [               shift and go to state 84


state 206

    (115) write_list -> write_list , write_param .

    )               reduce using rule 115 (write_list -> write_list , write_param .)
    ,               reduce using rule 115 (write_list -> write_list , write_param .)


state 207

    (117) write_param -> expr : expr .
    (118) write_param -> expr : expr . : expr

    )               reduce using rule 117 (write_param -> expr : expr .)
    ,               reduce using rule 117 (write_param -> expr : expr .)
    :               shift and go to state 218


state 208

    (120) if_statement -> IF expr THEN statement ELSE . statement
    (92) statement -> .
    (93) statement -> . assignment_statement
    (94) statement -> . proc_statement
    (95) statement -> . read_statement
    (96) statement -> . write_statement
    (97) statement -> . labeled_statement
    (98) statement -> . compound_statement
    (99) statement -> . if_statement
    (100) statement -> . while_statement
    (101) statement -> . for_statement
    (102) assignment_statement -> . var_access ASSIGN expr
    (103) proc_statement -> . ID
    (104) proc_statement -> . ID ( expr_list )
    (106) read_statement -> . READ ( var_access_list )
    (107) read_statement -> . READLN
    (108) read_statement -> . READLN ( var_access_list )
    (109) write_statement -> . WRITE ( write_list )
    (110) write_statement -> . WRITELN
    (111) write_statement -> . WRITELN ( write_list )
    (105) labeled_statement -> . INT : statement
    (89) compound_statement -> . BEGIN statement_list END
    (119) if_statement -> . IF expr THEN statement
    (120) if_statement -> . IF expr THEN statement ELSE statement
    (121) while_statement -> . WHILE expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    END             reduce using rule 92 (statement -> .)
    ;               reduce using rule 92 (statement -> .)
    ELSE            reduce using rule 92 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 219
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 209

    (64) term_sequence -> add_op term term_sequence .

    =               reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    NE              reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    <               reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    >               reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    LE              reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    GE              reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    THEN            reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    DO              reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    END             reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    ;               reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    ELSE            reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    ]               reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    ,               reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    )               reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    :               reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    TO              reduce using rule 64 (term_sequence -> add_op term term_sequence .)
    DOWNTO          reduce using rule 64 (term_sequence -> add_op term term_sequence .)


state 210

    (74) factor_sequence -> mul_op factor factor_sequence .

    +               reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    -               reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    OR              reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    =               reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    NE              reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    <               reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    >               reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    LE              reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    GE              reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    THEN            reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    DO              reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    END             reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    ;               reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    ELSE            reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    ]               reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    ,               reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    )               reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    :               reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    TO              reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)
    DOWNTO          reduce using rule 74 (factor_sequence -> mul_op factor factor_sequence .)


state 211

    (70) factor -> ID ( expr_list ) .

    *               reduce using rule 70 (factor -> ID ( expr_list ) .)
    /               reduce using rule 70 (factor -> ID ( expr_list ) .)
    DIV             reduce using rule 70 (factor -> ID ( expr_list ) .)
    MOD             reduce using rule 70 (factor -> ID ( expr_list ) .)
    AND             reduce using rule 70 (factor -> ID ( expr_list ) .)
    +               reduce using rule 70 (factor -> ID ( expr_list ) .)
    -               reduce using rule 70 (factor -> ID ( expr_list ) .)
    OR              reduce using rule 70 (factor -> ID ( expr_list ) .)
    =               reduce using rule 70 (factor -> ID ( expr_list ) .)
    NE              reduce using rule 70 (factor -> ID ( expr_list ) .)
    <               reduce using rule 70 (factor -> ID ( expr_list ) .)
    >               reduce using rule 70 (factor -> ID ( expr_list ) .)
    LE              reduce using rule 70 (factor -> ID ( expr_list ) .)
    GE              reduce using rule 70 (factor -> ID ( expr_list ) .)
    THEN            reduce using rule 70 (factor -> ID ( expr_list ) .)
    DO              reduce using rule 70 (factor -> ID ( expr_list ) .)
    END             reduce using rule 70 (factor -> ID ( expr_list ) .)
    ;               reduce using rule 70 (factor -> ID ( expr_list ) .)
    ELSE            reduce using rule 70 (factor -> ID ( expr_list ) .)
    ]               reduce using rule 70 (factor -> ID ( expr_list ) .)
    ,               reduce using rule 70 (factor -> ID ( expr_list ) .)
    )               reduce using rule 70 (factor -> ID ( expr_list ) .)
    :               reduce using rule 70 (factor -> ID ( expr_list ) .)
    TO              reduce using rule 70 (factor -> ID ( expr_list ) .)
    DOWNTO          reduce using rule 70 (factor -> ID ( expr_list ) .)


state 212

    (122) for_statement -> FOR ID ASSIGN expr TO . expr DO statement
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    expr                           shift and go to state 220
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 213

    (123) for_statement -> FOR ID ASSIGN expr DOWNTO . expr DO statement
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    expr                           shift and go to state 221
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 214

    (33) array_type -> ARRAY [ ordinal_type_list ] . OF tipo

    OF              shift and go to state 222


state 215

    (38) ordinal_type_list -> ordinal_type_list , . ordinal_type
    (34) ordinal_type -> . enumerated_type
    (35) ordinal_type -> . subrange_type
    (36) ordinal_type -> . ID
    (31) enumerated_type -> . ( id_list )
    (32) subrange_type -> . constant DOTDOT constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    ID              shift and go to state 199
    (               shift and go to state 113
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    +               shift and go to state 47
    -               shift and go to state 48

    ordinal_type                   shift and go to state 223
    enumerated_type                shift and go to state 197
    subrange_type                  shift and go to state 198
    constant                       shift and go to state 114
    sign                           shift and go to state 42

state 216

    (51) param -> VAR id_list : ID .

    )               reduce using rule 51 (param -> VAR id_list : ID .)
    ;               reduce using rule 51 (param -> VAR id_list : ID .)


state 217

    (47) func_heading -> FUNCTION ID ( param_list ) : ID .

    ;               reduce using rule 47 (func_heading -> FUNCTION ID ( param_list ) : ID .)
    )               reduce using rule 47 (func_heading -> FUNCTION ID ( param_list ) : ID .)


state 218

    (118) write_param -> expr : expr : . expr
    (58) expr -> . simple_expr
    (59) expr -> . simple_expr relation_op simple_expr
    (60) simple_expr -> . term term_sequence
    (61) simple_expr -> . sign term term_sequence
    (62) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (65) factor -> . var_access
    (66) factor -> . INT
    (67) factor -> . REAL
    (68) factor -> . CHAR
    (69) factor -> . STRING
    (70) factor -> . ID ( expr_list )
    (71) factor -> . ( expr )
    (72) factor -> . NOT factor
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 97
    REAL            shift and go to state 98
    CHAR            shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 101
    (               shift and go to state 102
    NOT             shift and go to state 103

    expr                           shift and go to state 224
    simple_expr                    shift and go to state 92
    term                           shift and go to state 93
    sign                           shift and go to state 94
    factor                         shift and go to state 95
    var_access                     shift and go to state 96

state 219

    (120) if_statement -> IF expr THEN statement ELSE statement .

    END             reduce using rule 120 (if_statement -> IF expr THEN statement ELSE statement .)
    ;               reduce using rule 120 (if_statement -> IF expr THEN statement ELSE statement .)
    ELSE            reduce using rule 120 (if_statement -> IF expr THEN statement ELSE statement .)


state 220

    (122) for_statement -> FOR ID ASSIGN expr TO expr . DO statement

    DO              shift and go to state 225


state 221

    (123) for_statement -> FOR ID ASSIGN expr DOWNTO expr . DO statement

    DO              shift and go to state 226


state 222

    (33) array_type -> ARRAY [ ordinal_type_list ] OF . tipo
    (26) tipo -> . ID
    (27) tipo -> . new_type
    (28) new_type -> . enumerated_type
    (29) new_type -> . subrange_type
    (30) new_type -> . array_type
    (31) enumerated_type -> . ( id_list )
    (32) subrange_type -> . constant DOTDOT constant
    (33) array_type -> . ARRAY [ ordinal_type_list ] OF tipo
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    ID              shift and go to state 108
    (               shift and go to state 113
    ARRAY           shift and go to state 115
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    +               shift and go to state 47
    -               shift and go to state 48

    tipo                           shift and go to state 227
    new_type                       shift and go to state 109
    enumerated_type                shift and go to state 110
    subrange_type                  shift and go to state 111
    array_type                     shift and go to state 112
    constant                       shift and go to state 114
    sign                           shift and go to state 42

state 223

    (38) ordinal_type_list -> ordinal_type_list , ordinal_type .

    ]               reduce using rule 38 (ordinal_type_list -> ordinal_type_list , ordinal_type .)
    ,               reduce using rule 38 (ordinal_type_list -> ordinal_type_list , ordinal_type .)


state 224

    (118) write_param -> expr : expr : expr .

    )               reduce using rule 118 (write_param -> expr : expr : expr .)
    ,               reduce using rule 118 (write_param -> expr : expr : expr .)


state 225

    (122) for_statement -> FOR ID ASSIGN expr TO expr DO . statement
    (92) statement -> .
    (93) statement -> . assignment_statement
    (94) statement -> . proc_statement
    (95) statement -> . read_statement
    (96) statement -> . write_statement
    (97) statement -> . labeled_statement
    (98) statement -> . compound_statement
    (99) statement -> . if_statement
    (100) statement -> . while_statement
    (101) statement -> . for_statement
    (102) assignment_statement -> . var_access ASSIGN expr
    (103) proc_statement -> . ID
    (104) proc_statement -> . ID ( expr_list )
    (106) read_statement -> . READ ( var_access_list )
    (107) read_statement -> . READLN
    (108) read_statement -> . READLN ( var_access_list )
    (109) write_statement -> . WRITE ( write_list )
    (110) write_statement -> . WRITELN
    (111) write_statement -> . WRITELN ( write_list )
    (105) labeled_statement -> . INT : statement
    (89) compound_statement -> . BEGIN statement_list END
    (119) if_statement -> . IF expr THEN statement
    (120) if_statement -> . IF expr THEN statement ELSE statement
    (121) while_statement -> . WHILE expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    END             reduce using rule 92 (statement -> .)
    ;               reduce using rule 92 (statement -> .)
    ELSE            reduce using rule 92 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 228
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 226

    (123) for_statement -> FOR ID ASSIGN expr DOWNTO expr DO . statement
    (92) statement -> .
    (93) statement -> . assignment_statement
    (94) statement -> . proc_statement
    (95) statement -> . read_statement
    (96) statement -> . write_statement
    (97) statement -> . labeled_statement
    (98) statement -> . compound_statement
    (99) statement -> . if_statement
    (100) statement -> . while_statement
    (101) statement -> . for_statement
    (102) assignment_statement -> . var_access ASSIGN expr
    (103) proc_statement -> . ID
    (104) proc_statement -> . ID ( expr_list )
    (106) read_statement -> . READ ( var_access_list )
    (107) read_statement -> . READLN
    (108) read_statement -> . READLN ( var_access_list )
    (109) write_statement -> . WRITE ( write_list )
    (110) write_statement -> . WRITELN
    (111) write_statement -> . WRITELN ( write_list )
    (105) labeled_statement -> . INT : statement
    (89) compound_statement -> . BEGIN statement_list END
    (119) if_statement -> . IF expr THEN statement
    (120) if_statement -> . IF expr THEN statement ELSE statement
    (121) while_statement -> . WHILE expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (54) var_access -> . ID
    (55) var_access -> . var_access [ expr_list ]

    END             reduce using rule 92 (statement -> .)
    ;               reduce using rule 92 (statement -> .)
    ELSE            reduce using rule 92 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 229
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 227

    (33) array_type -> ARRAY [ ordinal_type_list ] OF tipo .

    ;               reduce using rule 33 (array_type -> ARRAY [ ordinal_type_list ] OF tipo .)


state 228

    (122) for_statement -> FOR ID ASSIGN expr TO expr DO statement .

    END             reduce using rule 122 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)
    ;               reduce using rule 122 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)
    ELSE            reduce using rule 122 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)


state 229

    (123) for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .

    END             reduce using rule 123 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)
    ;               reduce using rule 123 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)
    ELSE            reduce using rule 123 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 184 resolved as shift
