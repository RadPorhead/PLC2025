Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program_heading ; block .
Rule 2     program_heading -> PROGRAM ID ( id_list )
Rule 3     program_heading -> PROGRAM ID
Rule 4     block -> const_def_part type_def_part var_dec_part proc_func_dec_part compound_statement
Rule 5     const_def_part -> <empty>
Rule 6     const_def_part -> CONST const_def ; ccont
Rule 7     ccont -> <empty>
Rule 8     ccont -> const_def ; ccont
Rule 9     type_def_part -> <empty>
Rule 10    type_def_part -> TYPE type_def ; tcont
Rule 11    tcont -> <empty>
Rule 12    tcont -> type_def ; tcont
Rule 13    var_dec_part -> <empty>
Rule 14    var_dec_part -> VAR var_dec ; vcont
Rule 15    vcont -> <empty>
Rule 16    vcont -> var_dec ; vcont
Rule 17    proc_func_dec_part -> <empty>
Rule 18    proc_func_dec_part -> proc_dec ;
Rule 19    proc_func_dec_part -> func_dec ;
Rule 20    const_def -> ID = constant
Rule 21    sign -> +
Rule 22    sign -> -
Rule 23    constant -> sign INT
Rule 24    constant -> INT
Rule 25    constant -> sign REAL
Rule 26    constant -> REAL
Rule 27    constant -> ID
Rule 28    constant -> sign ID
Rule 29    constant -> CHAR
Rule 30    constant -> STRING
Rule 31    type_def -> ID = tipo
Rule 32    tipo -> ID
Rule 33    tipo -> new_type
Rule 34    new_type -> enumerated_type
Rule 35    new_type -> subrange_type
Rule 36    new_type -> array_type
Rule 37    enumerated_type -> ( id_list )
Rule 38    id_list -> ID
Rule 39    id_list -> ID , id_list
Rule 40    subrange_type -> constant DOTDOT constant
Rule 41    array_type -> ARRAY [ ordinal_type acont ] OF tipo
Rule 42    acont -> <empty>
Rule 43    acont -> , ordinal_type acont
Rule 44    ordinal_type -> enumerated_type
Rule 45    ordinal_type -> subrange_type
Rule 46    ordinal_type -> ID
Rule 47    var_dec -> id_list : tipo
Rule 48    var_access -> ID
Rule 49    var_access -> var_access [ expr expr_sequence ]
Rule 50    expr_sequence -> <empty>
Rule 51    expr_sequence -> , expr expr_sequence
Rule 52    expr -> simple_expr
Rule 53    expr -> simple_expr relation_op simple_expr
Rule 54    simple_expr -> term term_sequence
Rule 55    simple_expr -> sign term term_sequence
Rule 56    term -> factor factor_sequence
Rule 57    term_sequence -> <empty>
Rule 58    term_sequence -> add_op term term_sequence
Rule 59    factor -> var_access
Rule 60    factor -> INT
Rule 61    factor -> REAL
Rule 62    factor -> CHAR
Rule 63    factor -> STRING
Rule 64    factor -> ID actual_param_list
Rule 65    factor -> ( expr )
Rule 66    factor -> NOT factor
Rule 67    factor_sequence -> <empty>
Rule 68    factor_sequence -> mul_op factor factor_sequence
Rule 69    add_op -> +
Rule 70    add_op -> -
Rule 71    add_op -> OR
Rule 72    mul_op -> *
Rule 73    mul_op -> /
Rule 74    mul_op -> DIV
Rule 75    mul_op -> MOD
Rule 76    mul_op -> AND
Rule 77    relation_op -> =
Rule 78    relation_op -> NE
Rule 79    relation_op -> <
Rule 80    relation_op -> >
Rule 81    relation_op -> LE
Rule 82    relation_op -> GE
Rule 83    relation_op -> IN
Rule 84    compound_statement -> BEGIN statement statement_sequence END
Rule 85    statement_sequence -> <empty>
Rule 86    statement_sequence -> ; statement statement_sequence
Rule 87    statement -> simple_statement
Rule 88    statement -> structured_statement
Rule 89    statement -> INT : structured_statement
Rule 90    statement -> INT : simple_statement
Rule 91    simple_statement -> <empty>
Rule 92    simple_statement -> assignment_statement
Rule 93    simple_statement -> proc_statement
Rule 94    assignment_statement -> var_access ASSIGN expr
Rule 95    proc_statement -> ID proc_id_cont
Rule 96    proc_id_cont -> <empty>
Rule 97    proc_id_cont -> actual_param_list
Rule 98    proc_id_cont -> read_param_list
Rule 99    proc_id_cont -> readln_param_list
Rule 100   proc_id_cont -> write_param_list
Rule 101   proc_id_cont -> writeln_param_list
Rule 102   actual_param_list -> ( actual_param actual_param_cont )
Rule 103   actual_param_cont -> <empty>
Rule 104   actual_param_cont -> , actual_param
Rule 105   actual_param -> expr
Rule 106   actual_param -> var_access
Rule 107   read_param_list -> ( var_access var_access_sequence )
Rule 108   var_access_sequence -> <empty>
Rule 109   var_access_sequence -> , var_access var_access_sequence
Rule 110   readln_param_list -> <empty>
Rule 111   readln_param_list -> read_param_list
Rule 112   write_param_list -> ( var_access write_param_sequence )
Rule 113   write_param_list -> ( write_param write_param_sequence )
Rule 114   write_param_sequence -> <empty>
Rule 115   write_param_sequence -> , write_param write_param_sequence
Rule 116   write_param -> expr
Rule 117   write_param -> expr : expr
Rule 118   write_param -> expr : expr : expr
Rule 119   writeln_param_list -> <empty>
Rule 120   writeln_param_list -> write_param_list
Rule 121   structured_statement -> compound_statement
Rule 122   structured_statement -> if_statement
Rule 123   structured_statement -> while_statement
Rule 124   structured_statement -> for_statement
Rule 125   if_statement -> IF expr THEN statement
Rule 126   if_statement -> IF expr THEN statement ELSE statement
Rule 127   while_statement -> WHILE expr DO statement
Rule 128   for_statement -> FOR ID ASSIGN expr TO expr DO statement
Rule 129   for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement
Rule 130   proc_dec -> proc_heading ; block
Rule 131   proc_dec -> PROCEDURE ID ; block
Rule 132   proc_heading -> PROCEDURE ID
Rule 133   proc_heading -> PROCEDURE ID formal_param_list
Rule 134   func_dec -> FUNCTION ID ; block
Rule 135   func_dec -> func_heading ; block
Rule 136   func_heading -> FUNCTION ID : ID
Rule 137   func_heading -> FUNCTION ID formal_param_list : ID
Rule 138   formal_param_list -> ( formal_param_section fcont )
Rule 139   fcont -> <empty>
Rule 140   fcont -> ; formal_param_section fcont
Rule 141   formal_param_section -> id_list : ID
Rule 142   formal_param_section -> VAR id_list : ID
Rule 143   formal_param_section -> proc_heading
Rule 144   formal_param_section -> func_heading

Terminals, with rules where they appear

(                    : 2 37 65 102 107 112 113 138
)                    : 2 37 65 102 107 112 113 138
*                    : 72
+                    : 21 69
,                    : 39 43 51 104 109 115
-                    : 22 70
.                    : 1
/                    : 73
:                    : 47 89 90 117 118 118 136 137 141 142
;                    : 1 6 8 10 12 14 16 18 19 86 130 131 134 135 140
<                    : 79
=                    : 20 31 77
>                    : 80
AND                  : 76
ARRAY                : 41
ASSIGN               : 94 128 129
BEGIN                : 84
CHAR                 : 29 62
CONST                : 6
DIV                  : 74
DO                   : 127 128 129
DOTDOT               : 40
DOWNTO               : 129
ELSE                 : 126
END                  : 84
FOR                  : 128 129
FUNCTION             : 134 136 137
GE                   : 82
ID                   : 2 3 20 27 28 31 32 38 39 46 48 64 95 128 129 131 132 133 134 136 136 137 137 141 142
IF                   : 125 126
IN                   : 83
INT                  : 23 24 60 89 90
LE                   : 81
MOD                  : 75
NE                   : 78
NOT                  : 66
OF                   : 41
OR                   : 71
PROCEDURE            : 131 132 133
PROGRAM              : 2 3
REAL                 : 25 26 61
STRING               : 30 63
THEN                 : 125 126
TO                   : 128
TYPE                 : 10
VAR                  : 14 142
WHILE                : 127
[                    : 41 49
]                    : 41 49
error                : 

Nonterminals, with rules where they appear

acont                : 41 43
actual_param         : 102 104
actual_param_cont    : 102
actual_param_list    : 64 97
add_op               : 58
array_type           : 36
assignment_statement : 92
block                : 1 130 131 134 135
ccont                : 6 8
compound_statement   : 4 121
const_def            : 6 8
const_def_part       : 4
constant             : 20 40 40
enumerated_type      : 34 44
expr                 : 49 51 65 94 105 116 117 117 118 118 118 125 126 127 128 128 129 129
expr_sequence        : 49 51
factor               : 56 66 68
factor_sequence      : 56 68
fcont                : 138 140
for_statement        : 124
formal_param_list    : 133 137
formal_param_section : 138 140
func_dec             : 19
func_heading         : 135 144
id_list              : 2 37 39 47 141 142
if_statement         : 122
mul_op               : 68
new_type             : 33
ordinal_type         : 41 43
proc_dec             : 18
proc_func_dec_part   : 4
proc_heading         : 130 143
proc_id_cont         : 95
proc_statement       : 93
program              : 0
program_heading      : 1
read_param_list      : 98 111
readln_param_list    : 99
relation_op          : 53
sign                 : 23 25 28 55
simple_expr          : 52 53 53
simple_statement     : 87 90
statement            : 84 86 125 126 126 127 128 129
statement_sequence   : 84 86
structured_statement : 88 89
subrange_type        : 35 45
tcont                : 10 12
term                 : 54 55 58
term_sequence        : 54 55 58
tipo                 : 31 41 47
type_def             : 10 12
type_def_part        : 4
var_access           : 49 59 94 106 107 109 112
var_access_sequence  : 107 109
var_dec              : 14 16
var_dec_part         : 4
vcont                : 14 16
while_statement      : 123
write_param          : 113 115
write_param_list     : 100 120
write_param_sequence : 112 113 115
writeln_param_list   : 101

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program_heading ; block .
    (2) program_heading -> . PROGRAM ID ( id_list )
    (3) program_heading -> . PROGRAM ID

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    program_heading                shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> program_heading . ; block .

    ;               shift and go to state 4


state 3

    (2) program_heading -> PROGRAM . ID ( id_list )
    (3) program_heading -> PROGRAM . ID

    ID              shift and go to state 5


state 4

    (1) program -> program_heading ; . block .
    (4) block -> . const_def_part type_def_part var_dec_part proc_func_dec_part compound_statement
    (5) const_def_part -> .
    (6) const_def_part -> . CONST const_def ; ccont

    TYPE            reduce using rule 5 (const_def_part -> .)
    VAR             reduce using rule 5 (const_def_part -> .)
    PROCEDURE       reduce using rule 5 (const_def_part -> .)
    FUNCTION        reduce using rule 5 (const_def_part -> .)
    BEGIN           reduce using rule 5 (const_def_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 6
    const_def_part                 shift and go to state 7

state 5

    (2) program_heading -> PROGRAM ID . ( id_list )
    (3) program_heading -> PROGRAM ID .

    (               shift and go to state 9
    ;               reduce using rule 3 (program_heading -> PROGRAM ID .)


state 6

    (1) program -> program_heading ; block . .

    .               shift and go to state 10


state 7

    (4) block -> const_def_part . type_def_part var_dec_part proc_func_dec_part compound_statement
    (9) type_def_part -> .
    (10) type_def_part -> . TYPE type_def ; tcont

    VAR             reduce using rule 9 (type_def_part -> .)
    PROCEDURE       reduce using rule 9 (type_def_part -> .)
    FUNCTION        reduce using rule 9 (type_def_part -> .)
    BEGIN           reduce using rule 9 (type_def_part -> .)
    TYPE            shift and go to state 12

    type_def_part                  shift and go to state 11

state 8

    (6) const_def_part -> CONST . const_def ; ccont
    (20) const_def -> . ID = constant

    ID              shift and go to state 14

    const_def                      shift and go to state 13

state 9

    (2) program_heading -> PROGRAM ID ( . id_list )
    (38) id_list -> . ID
    (39) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 16

state 10

    (1) program -> program_heading ; block . .

    $end            reduce using rule 1 (program -> program_heading ; block . .)


state 11

    (4) block -> const_def_part type_def_part . var_dec_part proc_func_dec_part compound_statement
    (13) var_dec_part -> .
    (14) var_dec_part -> . VAR var_dec ; vcont

    PROCEDURE       reduce using rule 13 (var_dec_part -> .)
    FUNCTION        reduce using rule 13 (var_dec_part -> .)
    BEGIN           reduce using rule 13 (var_dec_part -> .)
    VAR             shift and go to state 18

    var_dec_part                   shift and go to state 17

state 12

    (10) type_def_part -> TYPE . type_def ; tcont
    (31) type_def -> . ID = tipo

    ID              shift and go to state 20

    type_def                       shift and go to state 19

state 13

    (6) const_def_part -> CONST const_def . ; ccont

    ;               shift and go to state 21


state 14

    (20) const_def -> ID . = constant

    =               shift and go to state 22


state 15

    (38) id_list -> ID .
    (39) id_list -> ID . , id_list

    )               reduce using rule 38 (id_list -> ID .)
    :               reduce using rule 38 (id_list -> ID .)
    ,               shift and go to state 23


state 16

    (2) program_heading -> PROGRAM ID ( id_list . )

    )               shift and go to state 24


state 17

    (4) block -> const_def_part type_def_part var_dec_part . proc_func_dec_part compound_statement
    (17) proc_func_dec_part -> .
    (18) proc_func_dec_part -> . proc_dec ;
    (19) proc_func_dec_part -> . func_dec ;
    (130) proc_dec -> . proc_heading ; block
    (131) proc_dec -> . PROCEDURE ID ; block
    (134) func_dec -> . FUNCTION ID ; block
    (135) func_dec -> . func_heading ; block
    (132) proc_heading -> . PROCEDURE ID
    (133) proc_heading -> . PROCEDURE ID formal_param_list
    (136) func_heading -> . FUNCTION ID : ID
    (137) func_heading -> . FUNCTION ID formal_param_list : ID

    BEGIN           reduce using rule 17 (proc_func_dec_part -> .)
    PROCEDURE       shift and go to state 29
    FUNCTION        shift and go to state 30

    proc_func_dec_part             shift and go to state 25
    proc_dec                       shift and go to state 26
    func_dec                       shift and go to state 27
    proc_heading                   shift and go to state 28
    func_heading                   shift and go to state 31

state 18

    (14) var_dec_part -> VAR . var_dec ; vcont
    (47) var_dec -> . id_list : tipo
    (38) id_list -> . ID
    (39) id_list -> . ID , id_list

    ID              shift and go to state 15

    var_dec                        shift and go to state 32
    id_list                        shift and go to state 33

state 19

    (10) type_def_part -> TYPE type_def . ; tcont

    ;               shift and go to state 34


state 20

    (31) type_def -> ID . = tipo

    =               shift and go to state 35


state 21

    (6) const_def_part -> CONST const_def ; . ccont
    (7) ccont -> .
    (8) ccont -> . const_def ; ccont
    (20) const_def -> . ID = constant

    TYPE            reduce using rule 7 (ccont -> .)
    VAR             reduce using rule 7 (ccont -> .)
    PROCEDURE       reduce using rule 7 (ccont -> .)
    FUNCTION        reduce using rule 7 (ccont -> .)
    BEGIN           reduce using rule 7 (ccont -> .)
    ID              shift and go to state 14

    const_def                      shift and go to state 36
    ccont                          shift and go to state 37

state 22

    (20) const_def -> ID = . constant
    (23) constant -> . sign INT
    (24) constant -> . INT
    (25) constant -> . sign REAL
    (26) constant -> . REAL
    (27) constant -> . ID
    (28) constant -> . sign ID
    (29) constant -> . CHAR
    (30) constant -> . STRING
    (21) sign -> . +
    (22) sign -> . -

    INT             shift and go to state 41
    REAL            shift and go to state 42
    ID              shift and go to state 38
    CHAR            shift and go to state 43
    STRING          shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

    constant                       shift and go to state 39
    sign                           shift and go to state 40

state 23

    (39) id_list -> ID , . id_list
    (38) id_list -> . ID
    (39) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 47

state 24

    (2) program_heading -> PROGRAM ID ( id_list ) .

    ;               reduce using rule 2 (program_heading -> PROGRAM ID ( id_list ) .)


state 25

    (4) block -> const_def_part type_def_part var_dec_part proc_func_dec_part . compound_statement
    (84) compound_statement -> . BEGIN statement statement_sequence END

    BEGIN           shift and go to state 49

    compound_statement             shift and go to state 48

state 26

    (18) proc_func_dec_part -> proc_dec . ;

    ;               shift and go to state 50


state 27

    (19) proc_func_dec_part -> func_dec . ;

    ;               shift and go to state 51


state 28

    (130) proc_dec -> proc_heading . ; block

    ;               shift and go to state 52


state 29

    (131) proc_dec -> PROCEDURE . ID ; block
    (132) proc_heading -> PROCEDURE . ID
    (133) proc_heading -> PROCEDURE . ID formal_param_list

    ID              shift and go to state 53


state 30

    (134) func_dec -> FUNCTION . ID ; block
    (136) func_heading -> FUNCTION . ID : ID
    (137) func_heading -> FUNCTION . ID formal_param_list : ID

    ID              shift and go to state 54


state 31

    (135) func_dec -> func_heading . ; block

    ;               shift and go to state 55


state 32

    (14) var_dec_part -> VAR var_dec . ; vcont

    ;               shift and go to state 56


state 33

    (47) var_dec -> id_list . : tipo

    :               shift and go to state 57


state 34

    (10) type_def_part -> TYPE type_def ; . tcont
    (11) tcont -> .
    (12) tcont -> . type_def ; tcont
    (31) type_def -> . ID = tipo

    VAR             reduce using rule 11 (tcont -> .)
    PROCEDURE       reduce using rule 11 (tcont -> .)
    FUNCTION        reduce using rule 11 (tcont -> .)
    BEGIN           reduce using rule 11 (tcont -> .)
    ID              shift and go to state 20

    type_def                       shift and go to state 58
    tcont                          shift and go to state 59

state 35

    (31) type_def -> ID = . tipo
    (32) tipo -> . ID
    (33) tipo -> . new_type
    (34) new_type -> . enumerated_type
    (35) new_type -> . subrange_type
    (36) new_type -> . array_type
    (37) enumerated_type -> . ( id_list )
    (40) subrange_type -> . constant DOTDOT constant
    (41) array_type -> . ARRAY [ ordinal_type acont ] OF tipo
    (23) constant -> . sign INT
    (24) constant -> . INT
    (25) constant -> . sign REAL
    (26) constant -> . REAL
    (27) constant -> . ID
    (28) constant -> . sign ID
    (29) constant -> . CHAR
    (30) constant -> . STRING
    (21) sign -> . +
    (22) sign -> . -

    ID              shift and go to state 60
    (               shift and go to state 66
    ARRAY           shift and go to state 68
    INT             shift and go to state 41
    REAL            shift and go to state 42
    CHAR            shift and go to state 43
    STRING          shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

    tipo                           shift and go to state 61
    new_type                       shift and go to state 62
    enumerated_type                shift and go to state 63
    subrange_type                  shift and go to state 64
    array_type                     shift and go to state 65
    constant                       shift and go to state 67
    sign                           shift and go to state 40

state 36

    (8) ccont -> const_def . ; ccont

    ;               shift and go to state 69


state 37

    (6) const_def_part -> CONST const_def ; ccont .

    TYPE            reduce using rule 6 (const_def_part -> CONST const_def ; ccont .)
    VAR             reduce using rule 6 (const_def_part -> CONST const_def ; ccont .)
    PROCEDURE       reduce using rule 6 (const_def_part -> CONST const_def ; ccont .)
    FUNCTION        reduce using rule 6 (const_def_part -> CONST const_def ; ccont .)
    BEGIN           reduce using rule 6 (const_def_part -> CONST const_def ; ccont .)


state 38

    (27) constant -> ID .

    ;               reduce using rule 27 (constant -> ID .)
    ,               reduce using rule 27 (constant -> ID .)
    ]               reduce using rule 27 (constant -> ID .)


state 39

    (20) const_def -> ID = constant .

    ;               reduce using rule 20 (const_def -> ID = constant .)


state 40

    (23) constant -> sign . INT
    (25) constant -> sign . REAL
    (28) constant -> sign . ID

    INT             shift and go to state 70
    REAL            shift and go to state 71
    ID              shift and go to state 72


state 41

    (24) constant -> INT .

    ;               reduce using rule 24 (constant -> INT .)
    DOTDOT          reduce using rule 24 (constant -> INT .)
    ,               reduce using rule 24 (constant -> INT .)
    ]               reduce using rule 24 (constant -> INT .)


state 42

    (26) constant -> REAL .

    ;               reduce using rule 26 (constant -> REAL .)
    DOTDOT          reduce using rule 26 (constant -> REAL .)
    ,               reduce using rule 26 (constant -> REAL .)
    ]               reduce using rule 26 (constant -> REAL .)


state 43

    (29) constant -> CHAR .

    ;               reduce using rule 29 (constant -> CHAR .)
    DOTDOT          reduce using rule 29 (constant -> CHAR .)
    ,               reduce using rule 29 (constant -> CHAR .)
    ]               reduce using rule 29 (constant -> CHAR .)


state 44

    (30) constant -> STRING .

    ;               reduce using rule 30 (constant -> STRING .)
    DOTDOT          reduce using rule 30 (constant -> STRING .)
    ,               reduce using rule 30 (constant -> STRING .)
    ]               reduce using rule 30 (constant -> STRING .)


state 45

    (21) sign -> + .

    INT             reduce using rule 21 (sign -> + .)
    REAL            reduce using rule 21 (sign -> + .)
    ID              reduce using rule 21 (sign -> + .)
    CHAR            reduce using rule 21 (sign -> + .)
    STRING          reduce using rule 21 (sign -> + .)
    (               reduce using rule 21 (sign -> + .)
    NOT             reduce using rule 21 (sign -> + .)


state 46

    (22) sign -> - .

    INT             reduce using rule 22 (sign -> - .)
    REAL            reduce using rule 22 (sign -> - .)
    ID              reduce using rule 22 (sign -> - .)
    CHAR            reduce using rule 22 (sign -> - .)
    STRING          reduce using rule 22 (sign -> - .)
    (               reduce using rule 22 (sign -> - .)
    NOT             reduce using rule 22 (sign -> - .)


state 47

    (39) id_list -> ID , id_list .

    )               reduce using rule 39 (id_list -> ID , id_list .)
    :               reduce using rule 39 (id_list -> ID , id_list .)


state 48

    (4) block -> const_def_part type_def_part var_dec_part proc_func_dec_part compound_statement .

    .               reduce using rule 4 (block -> const_def_part type_def_part var_dec_part proc_func_dec_part compound_statement .)
    ;               reduce using rule 4 (block -> const_def_part type_def_part var_dec_part proc_func_dec_part compound_statement .)


state 49

    (84) compound_statement -> BEGIN . statement statement_sequence END
    (87) statement -> . simple_statement
    (88) statement -> . structured_statement
    (89) statement -> . INT : structured_statement
    (90) statement -> . INT : simple_statement
    (91) simple_statement -> .
    (92) simple_statement -> . assignment_statement
    (93) simple_statement -> . proc_statement
    (121) structured_statement -> . compound_statement
    (122) structured_statement -> . if_statement
    (123) structured_statement -> . while_statement
    (124) structured_statement -> . for_statement
    (94) assignment_statement -> . var_access ASSIGN expr
    (95) proc_statement -> . ID proc_id_cont
    (84) compound_statement -> . BEGIN statement statement_sequence END
    (125) if_statement -> . IF expr THEN statement
    (126) if_statement -> . IF expr THEN statement ELSE statement
    (127) while_statement -> . WHILE expr DO statement
    (128) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (129) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    INT             shift and go to state 76
    ;               reduce using rule 91 (simple_statement -> .)
    END             reduce using rule 91 (simple_statement -> .)
    ID              shift and go to state 84
    BEGIN           shift and go to state 49
    IF              shift and go to state 85
    WHILE           shift and go to state 86
    FOR             shift and go to state 87

    statement                      shift and go to state 73
    simple_statement               shift and go to state 74
    structured_statement           shift and go to state 75
    assignment_statement           shift and go to state 77
    proc_statement                 shift and go to state 78
    compound_statement             shift and go to state 79
    if_statement                   shift and go to state 80
    while_statement                shift and go to state 81
    for_statement                  shift and go to state 82
    var_access                     shift and go to state 83

state 50

    (18) proc_func_dec_part -> proc_dec ; .

    BEGIN           reduce using rule 18 (proc_func_dec_part -> proc_dec ; .)


state 51

    (19) proc_func_dec_part -> func_dec ; .

    BEGIN           reduce using rule 19 (proc_func_dec_part -> func_dec ; .)


state 52

    (130) proc_dec -> proc_heading ; . block
    (4) block -> . const_def_part type_def_part var_dec_part proc_func_dec_part compound_statement
    (5) const_def_part -> .
    (6) const_def_part -> . CONST const_def ; ccont

    TYPE            reduce using rule 5 (const_def_part -> .)
    VAR             reduce using rule 5 (const_def_part -> .)
    PROCEDURE       reduce using rule 5 (const_def_part -> .)
    FUNCTION        reduce using rule 5 (const_def_part -> .)
    BEGIN           reduce using rule 5 (const_def_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 88
    const_def_part                 shift and go to state 7

state 53

    (131) proc_dec -> PROCEDURE ID . ; block
    (132) proc_heading -> PROCEDURE ID .
    (133) proc_heading -> PROCEDURE ID . formal_param_list
    (138) formal_param_list -> . ( formal_param_section fcont )

  ! shift/reduce conflict for ; resolved as shift
    ;               shift and go to state 89
    (               shift and go to state 91

  ! ;               [ reduce using rule 132 (proc_heading -> PROCEDURE ID .) ]

    formal_param_list              shift and go to state 90

state 54

    (134) func_dec -> FUNCTION ID . ; block
    (136) func_heading -> FUNCTION ID . : ID
    (137) func_heading -> FUNCTION ID . formal_param_list : ID
    (138) formal_param_list -> . ( formal_param_section fcont )

    ;               shift and go to state 92
    :               shift and go to state 93
    (               shift and go to state 91

    formal_param_list              shift and go to state 94

state 55

    (135) func_dec -> func_heading ; . block
    (4) block -> . const_def_part type_def_part var_dec_part proc_func_dec_part compound_statement
    (5) const_def_part -> .
    (6) const_def_part -> . CONST const_def ; ccont

    TYPE            reduce using rule 5 (const_def_part -> .)
    VAR             reduce using rule 5 (const_def_part -> .)
    PROCEDURE       reduce using rule 5 (const_def_part -> .)
    FUNCTION        reduce using rule 5 (const_def_part -> .)
    BEGIN           reduce using rule 5 (const_def_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 95
    const_def_part                 shift and go to state 7

state 56

    (14) var_dec_part -> VAR var_dec ; . vcont
    (15) vcont -> .
    (16) vcont -> . var_dec ; vcont
    (47) var_dec -> . id_list : tipo
    (38) id_list -> . ID
    (39) id_list -> . ID , id_list

    PROCEDURE       reduce using rule 15 (vcont -> .)
    FUNCTION        reduce using rule 15 (vcont -> .)
    BEGIN           reduce using rule 15 (vcont -> .)
    ID              shift and go to state 15

    var_dec                        shift and go to state 96
    vcont                          shift and go to state 97
    id_list                        shift and go to state 33

state 57

    (47) var_dec -> id_list : . tipo
    (32) tipo -> . ID
    (33) tipo -> . new_type
    (34) new_type -> . enumerated_type
    (35) new_type -> . subrange_type
    (36) new_type -> . array_type
    (37) enumerated_type -> . ( id_list )
    (40) subrange_type -> . constant DOTDOT constant
    (41) array_type -> . ARRAY [ ordinal_type acont ] OF tipo
    (23) constant -> . sign INT
    (24) constant -> . INT
    (25) constant -> . sign REAL
    (26) constant -> . REAL
    (27) constant -> . ID
    (28) constant -> . sign ID
    (29) constant -> . CHAR
    (30) constant -> . STRING
    (21) sign -> . +
    (22) sign -> . -

    ID              shift and go to state 60
    (               shift and go to state 66
    ARRAY           shift and go to state 68
    INT             shift and go to state 41
    REAL            shift and go to state 42
    CHAR            shift and go to state 43
    STRING          shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

    tipo                           shift and go to state 98
    new_type                       shift and go to state 62
    enumerated_type                shift and go to state 63
    subrange_type                  shift and go to state 64
    array_type                     shift and go to state 65
    constant                       shift and go to state 67
    sign                           shift and go to state 40

state 58

    (12) tcont -> type_def . ; tcont

    ;               shift and go to state 99


state 59

    (10) type_def_part -> TYPE type_def ; tcont .

    VAR             reduce using rule 10 (type_def_part -> TYPE type_def ; tcont .)
    PROCEDURE       reduce using rule 10 (type_def_part -> TYPE type_def ; tcont .)
    FUNCTION        reduce using rule 10 (type_def_part -> TYPE type_def ; tcont .)
    BEGIN           reduce using rule 10 (type_def_part -> TYPE type_def ; tcont .)


state 60

    (32) tipo -> ID .
    (27) constant -> ID .

    ;               reduce using rule 32 (tipo -> ID .)
    DOTDOT          reduce using rule 27 (constant -> ID .)


state 61

    (31) type_def -> ID = tipo .

    ;               reduce using rule 31 (type_def -> ID = tipo .)


state 62

    (33) tipo -> new_type .

    ;               reduce using rule 33 (tipo -> new_type .)


state 63

    (34) new_type -> enumerated_type .

    ;               reduce using rule 34 (new_type -> enumerated_type .)


state 64

    (35) new_type -> subrange_type .

    ;               reduce using rule 35 (new_type -> subrange_type .)


state 65

    (36) new_type -> array_type .

    ;               reduce using rule 36 (new_type -> array_type .)


state 66

    (37) enumerated_type -> ( . id_list )
    (38) id_list -> . ID
    (39) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 100

state 67

    (40) subrange_type -> constant . DOTDOT constant

    DOTDOT          shift and go to state 101


state 68

    (41) array_type -> ARRAY . [ ordinal_type acont ] OF tipo

    [               shift and go to state 102


state 69

    (8) ccont -> const_def ; . ccont
    (7) ccont -> .
    (8) ccont -> . const_def ; ccont
    (20) const_def -> . ID = constant

    TYPE            reduce using rule 7 (ccont -> .)
    VAR             reduce using rule 7 (ccont -> .)
    PROCEDURE       reduce using rule 7 (ccont -> .)
    FUNCTION        reduce using rule 7 (ccont -> .)
    BEGIN           reduce using rule 7 (ccont -> .)
    ID              shift and go to state 14

    const_def                      shift and go to state 36
    ccont                          shift and go to state 103

state 70

    (23) constant -> sign INT .

    ;               reduce using rule 23 (constant -> sign INT .)
    DOTDOT          reduce using rule 23 (constant -> sign INT .)
    ,               reduce using rule 23 (constant -> sign INT .)
    ]               reduce using rule 23 (constant -> sign INT .)


state 71

    (25) constant -> sign REAL .

    ;               reduce using rule 25 (constant -> sign REAL .)
    DOTDOT          reduce using rule 25 (constant -> sign REAL .)
    ,               reduce using rule 25 (constant -> sign REAL .)
    ]               reduce using rule 25 (constant -> sign REAL .)


state 72

    (28) constant -> sign ID .

    ;               reduce using rule 28 (constant -> sign ID .)
    DOTDOT          reduce using rule 28 (constant -> sign ID .)
    ,               reduce using rule 28 (constant -> sign ID .)
    ]               reduce using rule 28 (constant -> sign ID .)


state 73

    (84) compound_statement -> BEGIN statement . statement_sequence END
    (85) statement_sequence -> .
    (86) statement_sequence -> . ; statement statement_sequence

    END             reduce using rule 85 (statement_sequence -> .)
    ;               shift and go to state 105

    statement_sequence             shift and go to state 104

state 74

    (87) statement -> simple_statement .

    ;               reduce using rule 87 (statement -> simple_statement .)
    END             reduce using rule 87 (statement -> simple_statement .)
    ELSE            reduce using rule 87 (statement -> simple_statement .)


state 75

    (88) statement -> structured_statement .

    ;               reduce using rule 88 (statement -> structured_statement .)
    END             reduce using rule 88 (statement -> structured_statement .)
    ELSE            reduce using rule 88 (statement -> structured_statement .)


state 76

    (89) statement -> INT . : structured_statement
    (90) statement -> INT . : simple_statement

    :               shift and go to state 106


state 77

    (92) simple_statement -> assignment_statement .

    ;               reduce using rule 92 (simple_statement -> assignment_statement .)
    END             reduce using rule 92 (simple_statement -> assignment_statement .)
    ELSE            reduce using rule 92 (simple_statement -> assignment_statement .)


state 78

    (93) simple_statement -> proc_statement .

    ;               reduce using rule 93 (simple_statement -> proc_statement .)
    END             reduce using rule 93 (simple_statement -> proc_statement .)
    ELSE            reduce using rule 93 (simple_statement -> proc_statement .)


state 79

    (121) structured_statement -> compound_statement .

    ;               reduce using rule 121 (structured_statement -> compound_statement .)
    END             reduce using rule 121 (structured_statement -> compound_statement .)
    ELSE            reduce using rule 121 (structured_statement -> compound_statement .)


state 80

    (122) structured_statement -> if_statement .

    ;               reduce using rule 122 (structured_statement -> if_statement .)
    END             reduce using rule 122 (structured_statement -> if_statement .)
    ELSE            reduce using rule 122 (structured_statement -> if_statement .)


state 81

    (123) structured_statement -> while_statement .

    ;               reduce using rule 123 (structured_statement -> while_statement .)
    END             reduce using rule 123 (structured_statement -> while_statement .)
    ELSE            reduce using rule 123 (structured_statement -> while_statement .)


state 82

    (124) structured_statement -> for_statement .

    ;               reduce using rule 124 (structured_statement -> for_statement .)
    END             reduce using rule 124 (structured_statement -> for_statement .)
    ELSE            reduce using rule 124 (structured_statement -> for_statement .)


state 83

    (94) assignment_statement -> var_access . ASSIGN expr
    (49) var_access -> var_access . [ expr expr_sequence ]

    ASSIGN          shift and go to state 107
    [               shift and go to state 108


state 84

    (95) proc_statement -> ID . proc_id_cont
    (48) var_access -> ID .
    (96) proc_id_cont -> .
    (97) proc_id_cont -> . actual_param_list
    (98) proc_id_cont -> . read_param_list
    (99) proc_id_cont -> . readln_param_list
    (100) proc_id_cont -> . write_param_list
    (101) proc_id_cont -> . writeln_param_list
    (102) actual_param_list -> . ( actual_param actual_param_cont )
    (107) read_param_list -> . ( var_access var_access_sequence )
    (110) readln_param_list -> .
    (111) readln_param_list -> . read_param_list
    (112) write_param_list -> . ( var_access write_param_sequence )
    (113) write_param_list -> . ( write_param write_param_sequence )
    (119) writeln_param_list -> .
    (120) writeln_param_list -> . write_param_list

  ! reduce/reduce conflict for ; resolved using rule 96 (proc_id_cont -> .)
  ! reduce/reduce conflict for END resolved using rule 96 (proc_id_cont -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 96 (proc_id_cont -> .)
  ! reduce/reduce conflict for ; resolved using rule 96 (proc_id_cont -> .)
  ! reduce/reduce conflict for END resolved using rule 96 (proc_id_cont -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 96 (proc_id_cont -> .)
    ASSIGN          reduce using rule 48 (var_access -> ID .)
    [               reduce using rule 48 (var_access -> ID .)
    ;               reduce using rule 96 (proc_id_cont -> .)
    END             reduce using rule 96 (proc_id_cont -> .)
    ELSE            reduce using rule 96 (proc_id_cont -> .)
    (               shift and go to state 115

  ! ;               [ reduce using rule 110 (readln_param_list -> .) ]
  ! END             [ reduce using rule 110 (readln_param_list -> .) ]
  ! ELSE            [ reduce using rule 110 (readln_param_list -> .) ]
  ! ;               [ reduce using rule 119 (writeln_param_list -> .) ]
  ! END             [ reduce using rule 119 (writeln_param_list -> .) ]
  ! ELSE            [ reduce using rule 119 (writeln_param_list -> .) ]

    proc_id_cont                   shift and go to state 109
    actual_param_list              shift and go to state 110
    read_param_list                shift and go to state 111
    readln_param_list              shift and go to state 112
    write_param_list               shift and go to state 113
    writeln_param_list             shift and go to state 114

state 85

    (125) if_statement -> IF . expr THEN statement
    (126) if_statement -> IF . expr THEN statement ELSE statement
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    expr                           shift and go to state 116
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 86

    (127) while_statement -> WHILE . expr DO statement
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    expr                           shift and go to state 129
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 87

    (128) for_statement -> FOR . ID ASSIGN expr TO expr DO statement
    (129) for_statement -> FOR . ID ASSIGN expr DOWNTO expr DO statement

    ID              shift and go to state 130


state 88

    (130) proc_dec -> proc_heading ; block .

    ;               reduce using rule 130 (proc_dec -> proc_heading ; block .)


state 89

    (131) proc_dec -> PROCEDURE ID ; . block
    (4) block -> . const_def_part type_def_part var_dec_part proc_func_dec_part compound_statement
    (5) const_def_part -> .
    (6) const_def_part -> . CONST const_def ; ccont

    TYPE            reduce using rule 5 (const_def_part -> .)
    VAR             reduce using rule 5 (const_def_part -> .)
    PROCEDURE       reduce using rule 5 (const_def_part -> .)
    FUNCTION        reduce using rule 5 (const_def_part -> .)
    BEGIN           reduce using rule 5 (const_def_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 131
    const_def_part                 shift and go to state 7

state 90

    (133) proc_heading -> PROCEDURE ID formal_param_list .

    ;               reduce using rule 133 (proc_heading -> PROCEDURE ID formal_param_list .)
    )               reduce using rule 133 (proc_heading -> PROCEDURE ID formal_param_list .)


state 91

    (138) formal_param_list -> ( . formal_param_section fcont )
    (141) formal_param_section -> . id_list : ID
    (142) formal_param_section -> . VAR id_list : ID
    (143) formal_param_section -> . proc_heading
    (144) formal_param_section -> . func_heading
    (38) id_list -> . ID
    (39) id_list -> . ID , id_list
    (132) proc_heading -> . PROCEDURE ID
    (133) proc_heading -> . PROCEDURE ID formal_param_list
    (136) func_heading -> . FUNCTION ID : ID
    (137) func_heading -> . FUNCTION ID formal_param_list : ID

    VAR             shift and go to state 134
    ID              shift and go to state 15
    PROCEDURE       shift and go to state 137
    FUNCTION        shift and go to state 138

    formal_param_section           shift and go to state 132
    id_list                        shift and go to state 133
    proc_heading                   shift and go to state 135
    func_heading                   shift and go to state 136

state 92

    (134) func_dec -> FUNCTION ID ; . block
    (4) block -> . const_def_part type_def_part var_dec_part proc_func_dec_part compound_statement
    (5) const_def_part -> .
    (6) const_def_part -> . CONST const_def ; ccont

    TYPE            reduce using rule 5 (const_def_part -> .)
    VAR             reduce using rule 5 (const_def_part -> .)
    PROCEDURE       reduce using rule 5 (const_def_part -> .)
    FUNCTION        reduce using rule 5 (const_def_part -> .)
    BEGIN           reduce using rule 5 (const_def_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 139
    const_def_part                 shift and go to state 7

state 93

    (136) func_heading -> FUNCTION ID : . ID

    ID              shift and go to state 140


state 94

    (137) func_heading -> FUNCTION ID formal_param_list . : ID

    :               shift and go to state 141


state 95

    (135) func_dec -> func_heading ; block .

    ;               reduce using rule 135 (func_dec -> func_heading ; block .)


state 96

    (16) vcont -> var_dec . ; vcont

    ;               shift and go to state 142


state 97

    (14) var_dec_part -> VAR var_dec ; vcont .

    PROCEDURE       reduce using rule 14 (var_dec_part -> VAR var_dec ; vcont .)
    FUNCTION        reduce using rule 14 (var_dec_part -> VAR var_dec ; vcont .)
    BEGIN           reduce using rule 14 (var_dec_part -> VAR var_dec ; vcont .)


state 98

    (47) var_dec -> id_list : tipo .

    ;               reduce using rule 47 (var_dec -> id_list : tipo .)


state 99

    (12) tcont -> type_def ; . tcont
    (11) tcont -> .
    (12) tcont -> . type_def ; tcont
    (31) type_def -> . ID = tipo

    VAR             reduce using rule 11 (tcont -> .)
    PROCEDURE       reduce using rule 11 (tcont -> .)
    FUNCTION        reduce using rule 11 (tcont -> .)
    BEGIN           reduce using rule 11 (tcont -> .)
    ID              shift and go to state 20

    type_def                       shift and go to state 58
    tcont                          shift and go to state 143

state 100

    (37) enumerated_type -> ( id_list . )

    )               shift and go to state 144


state 101

    (40) subrange_type -> constant DOTDOT . constant
    (23) constant -> . sign INT
    (24) constant -> . INT
    (25) constant -> . sign REAL
    (26) constant -> . REAL
    (27) constant -> . ID
    (28) constant -> . sign ID
    (29) constant -> . CHAR
    (30) constant -> . STRING
    (21) sign -> . +
    (22) sign -> . -

    INT             shift and go to state 41
    REAL            shift and go to state 42
    ID              shift and go to state 38
    CHAR            shift and go to state 43
    STRING          shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

    constant                       shift and go to state 145
    sign                           shift and go to state 40

state 102

    (41) array_type -> ARRAY [ . ordinal_type acont ] OF tipo
    (44) ordinal_type -> . enumerated_type
    (45) ordinal_type -> . subrange_type
    (46) ordinal_type -> . ID
    (37) enumerated_type -> . ( id_list )
    (40) subrange_type -> . constant DOTDOT constant
    (23) constant -> . sign INT
    (24) constant -> . INT
    (25) constant -> . sign REAL
    (26) constant -> . REAL
    (27) constant -> . ID
    (28) constant -> . sign ID
    (29) constant -> . CHAR
    (30) constant -> . STRING
    (21) sign -> . +
    (22) sign -> . -

    ID              shift and go to state 149
    (               shift and go to state 66
    INT             shift and go to state 41
    REAL            shift and go to state 42
    CHAR            shift and go to state 43
    STRING          shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

    ordinal_type                   shift and go to state 146
    enumerated_type                shift and go to state 147
    subrange_type                  shift and go to state 148
    constant                       shift and go to state 67
    sign                           shift and go to state 40

state 103

    (8) ccont -> const_def ; ccont .

    TYPE            reduce using rule 8 (ccont -> const_def ; ccont .)
    VAR             reduce using rule 8 (ccont -> const_def ; ccont .)
    PROCEDURE       reduce using rule 8 (ccont -> const_def ; ccont .)
    FUNCTION        reduce using rule 8 (ccont -> const_def ; ccont .)
    BEGIN           reduce using rule 8 (ccont -> const_def ; ccont .)


state 104

    (84) compound_statement -> BEGIN statement statement_sequence . END

    END             shift and go to state 150


state 105

    (86) statement_sequence -> ; . statement statement_sequence
    (87) statement -> . simple_statement
    (88) statement -> . structured_statement
    (89) statement -> . INT : structured_statement
    (90) statement -> . INT : simple_statement
    (91) simple_statement -> .
    (92) simple_statement -> . assignment_statement
    (93) simple_statement -> . proc_statement
    (121) structured_statement -> . compound_statement
    (122) structured_statement -> . if_statement
    (123) structured_statement -> . while_statement
    (124) structured_statement -> . for_statement
    (94) assignment_statement -> . var_access ASSIGN expr
    (95) proc_statement -> . ID proc_id_cont
    (84) compound_statement -> . BEGIN statement statement_sequence END
    (125) if_statement -> . IF expr THEN statement
    (126) if_statement -> . IF expr THEN statement ELSE statement
    (127) while_statement -> . WHILE expr DO statement
    (128) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (129) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    INT             shift and go to state 76
    ;               reduce using rule 91 (simple_statement -> .)
    END             reduce using rule 91 (simple_statement -> .)
    ID              shift and go to state 84
    BEGIN           shift and go to state 49
    IF              shift and go to state 85
    WHILE           shift and go to state 86
    FOR             shift and go to state 87

    statement                      shift and go to state 151
    simple_statement               shift and go to state 74
    structured_statement           shift and go to state 75
    assignment_statement           shift and go to state 77
    proc_statement                 shift and go to state 78
    compound_statement             shift and go to state 79
    if_statement                   shift and go to state 80
    while_statement                shift and go to state 81
    for_statement                  shift and go to state 82
    var_access                     shift and go to state 83

state 106

    (89) statement -> INT : . structured_statement
    (90) statement -> INT : . simple_statement
    (121) structured_statement -> . compound_statement
    (122) structured_statement -> . if_statement
    (123) structured_statement -> . while_statement
    (124) structured_statement -> . for_statement
    (91) simple_statement -> .
    (92) simple_statement -> . assignment_statement
    (93) simple_statement -> . proc_statement
    (84) compound_statement -> . BEGIN statement statement_sequence END
    (125) if_statement -> . IF expr THEN statement
    (126) if_statement -> . IF expr THEN statement ELSE statement
    (127) while_statement -> . WHILE expr DO statement
    (128) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (129) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (94) assignment_statement -> . var_access ASSIGN expr
    (95) proc_statement -> . ID proc_id_cont
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    ;               reduce using rule 91 (simple_statement -> .)
    END             reduce using rule 91 (simple_statement -> .)
    ELSE            reduce using rule 91 (simple_statement -> .)
    BEGIN           shift and go to state 49
    IF              shift and go to state 85
    WHILE           shift and go to state 86
    FOR             shift and go to state 87
    ID              shift and go to state 84

    structured_statement           shift and go to state 152
    simple_statement               shift and go to state 153
    compound_statement             shift and go to state 79
    if_statement                   shift and go to state 80
    while_statement                shift and go to state 81
    for_statement                  shift and go to state 82
    assignment_statement           shift and go to state 77
    proc_statement                 shift and go to state 78
    var_access                     shift and go to state 83

state 107

    (94) assignment_statement -> var_access ASSIGN . expr
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    var_access                     shift and go to state 121
    expr                           shift and go to state 154
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120

state 108

    (49) var_access -> var_access [ . expr expr_sequence ]
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    var_access                     shift and go to state 121
    expr                           shift and go to state 155
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120

state 109

    (95) proc_statement -> ID proc_id_cont .

    ;               reduce using rule 95 (proc_statement -> ID proc_id_cont .)
    END             reduce using rule 95 (proc_statement -> ID proc_id_cont .)
    ELSE            reduce using rule 95 (proc_statement -> ID proc_id_cont .)


state 110

    (97) proc_id_cont -> actual_param_list .

    ;               reduce using rule 97 (proc_id_cont -> actual_param_list .)
    END             reduce using rule 97 (proc_id_cont -> actual_param_list .)
    ELSE            reduce using rule 97 (proc_id_cont -> actual_param_list .)


state 111

    (98) proc_id_cont -> read_param_list .
    (111) readln_param_list -> read_param_list .

  ! reduce/reduce conflict for ; resolved using rule 98 (proc_id_cont -> read_param_list .)
  ! reduce/reduce conflict for END resolved using rule 98 (proc_id_cont -> read_param_list .)
  ! reduce/reduce conflict for ELSE resolved using rule 98 (proc_id_cont -> read_param_list .)
    ;               reduce using rule 98 (proc_id_cont -> read_param_list .)
    END             reduce using rule 98 (proc_id_cont -> read_param_list .)
    ELSE            reduce using rule 98 (proc_id_cont -> read_param_list .)

  ! ;               [ reduce using rule 111 (readln_param_list -> read_param_list .) ]
  ! END             [ reduce using rule 111 (readln_param_list -> read_param_list .) ]
  ! ELSE            [ reduce using rule 111 (readln_param_list -> read_param_list .) ]


state 112

    (99) proc_id_cont -> readln_param_list .

    ;               reduce using rule 99 (proc_id_cont -> readln_param_list .)
    END             reduce using rule 99 (proc_id_cont -> readln_param_list .)
    ELSE            reduce using rule 99 (proc_id_cont -> readln_param_list .)


state 113

    (100) proc_id_cont -> write_param_list .
    (120) writeln_param_list -> write_param_list .

  ! reduce/reduce conflict for ; resolved using rule 100 (proc_id_cont -> write_param_list .)
  ! reduce/reduce conflict for END resolved using rule 100 (proc_id_cont -> write_param_list .)
  ! reduce/reduce conflict for ELSE resolved using rule 100 (proc_id_cont -> write_param_list .)
    ;               reduce using rule 100 (proc_id_cont -> write_param_list .)
    END             reduce using rule 100 (proc_id_cont -> write_param_list .)
    ELSE            reduce using rule 100 (proc_id_cont -> write_param_list .)

  ! ;               [ reduce using rule 120 (writeln_param_list -> write_param_list .) ]
  ! END             [ reduce using rule 120 (writeln_param_list -> write_param_list .) ]
  ! ELSE            [ reduce using rule 120 (writeln_param_list -> write_param_list .) ]


state 114

    (101) proc_id_cont -> writeln_param_list .

    ;               reduce using rule 101 (proc_id_cont -> writeln_param_list .)
    END             reduce using rule 101 (proc_id_cont -> writeln_param_list .)
    ELSE            reduce using rule 101 (proc_id_cont -> writeln_param_list .)


state 115

    (102) actual_param_list -> ( . actual_param actual_param_cont )
    (107) read_param_list -> ( . var_access var_access_sequence )
    (112) write_param_list -> ( . var_access write_param_sequence )
    (113) write_param_list -> ( . write_param write_param_sequence )
    (105) actual_param -> . expr
    (106) actual_param -> . var_access
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]
    (116) write_param -> . expr
    (117) write_param -> . expr : expr
    (118) write_param -> . expr : expr : expr
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor

    ID              shift and go to state 160
    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    (               shift and go to state 127
    NOT             shift and go to state 128

    actual_param                   shift and go to state 156
    var_access                     shift and go to state 157
    write_param                    shift and go to state 158
    expr                           shift and go to state 159
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120

state 116

    (125) if_statement -> IF expr . THEN statement
    (126) if_statement -> IF expr . THEN statement ELSE statement

    THEN            shift and go to state 161


state 117

    (52) expr -> simple_expr .
    (53) expr -> simple_expr . relation_op simple_expr
    (77) relation_op -> . =
    (78) relation_op -> . NE
    (79) relation_op -> . <
    (80) relation_op -> . >
    (81) relation_op -> . LE
    (82) relation_op -> . GE
    (83) relation_op -> . IN

    THEN            reduce using rule 52 (expr -> simple_expr .)
    DO              reduce using rule 52 (expr -> simple_expr .)
    ;               reduce using rule 52 (expr -> simple_expr .)
    END             reduce using rule 52 (expr -> simple_expr .)
    ELSE            reduce using rule 52 (expr -> simple_expr .)
    ,               reduce using rule 52 (expr -> simple_expr .)
    ]               reduce using rule 52 (expr -> simple_expr .)
    :               reduce using rule 52 (expr -> simple_expr .)
    )               reduce using rule 52 (expr -> simple_expr .)
    TO              reduce using rule 52 (expr -> simple_expr .)
    DOWNTO          reduce using rule 52 (expr -> simple_expr .)
    =               shift and go to state 163
    NE              shift and go to state 164
    <               shift and go to state 165
    >               shift and go to state 166
    LE              shift and go to state 167
    GE              shift and go to state 168
    IN              shift and go to state 169

    relation_op                    shift and go to state 162

state 118

    (54) simple_expr -> term . term_sequence
    (57) term_sequence -> .
    (58) term_sequence -> . add_op term term_sequence
    (69) add_op -> . +
    (70) add_op -> . -
    (71) add_op -> . OR

    =               reduce using rule 57 (term_sequence -> .)
    NE              reduce using rule 57 (term_sequence -> .)
    <               reduce using rule 57 (term_sequence -> .)
    >               reduce using rule 57 (term_sequence -> .)
    LE              reduce using rule 57 (term_sequence -> .)
    GE              reduce using rule 57 (term_sequence -> .)
    IN              reduce using rule 57 (term_sequence -> .)
    THEN            reduce using rule 57 (term_sequence -> .)
    DO              reduce using rule 57 (term_sequence -> .)
    ;               reduce using rule 57 (term_sequence -> .)
    END             reduce using rule 57 (term_sequence -> .)
    ELSE            reduce using rule 57 (term_sequence -> .)
    ,               reduce using rule 57 (term_sequence -> .)
    ]               reduce using rule 57 (term_sequence -> .)
    :               reduce using rule 57 (term_sequence -> .)
    )               reduce using rule 57 (term_sequence -> .)
    TO              reduce using rule 57 (term_sequence -> .)
    DOWNTO          reduce using rule 57 (term_sequence -> .)
    +               shift and go to state 172
    -               shift and go to state 173
    OR              shift and go to state 174

    term_sequence                  shift and go to state 170
    add_op                         shift and go to state 171

state 119

    (55) simple_expr -> sign . term term_sequence
    (56) term -> . factor factor_sequence
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    term                           shift and go to state 175
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 120

    (56) term -> factor . factor_sequence
    (67) factor_sequence -> .
    (68) factor_sequence -> . mul_op factor factor_sequence
    (72) mul_op -> . *
    (73) mul_op -> . /
    (74) mul_op -> . DIV
    (75) mul_op -> . MOD
    (76) mul_op -> . AND

    +               reduce using rule 67 (factor_sequence -> .)
    -               reduce using rule 67 (factor_sequence -> .)
    OR              reduce using rule 67 (factor_sequence -> .)
    =               reduce using rule 67 (factor_sequence -> .)
    NE              reduce using rule 67 (factor_sequence -> .)
    <               reduce using rule 67 (factor_sequence -> .)
    >               reduce using rule 67 (factor_sequence -> .)
    LE              reduce using rule 67 (factor_sequence -> .)
    GE              reduce using rule 67 (factor_sequence -> .)
    IN              reduce using rule 67 (factor_sequence -> .)
    THEN            reduce using rule 67 (factor_sequence -> .)
    DO              reduce using rule 67 (factor_sequence -> .)
    ;               reduce using rule 67 (factor_sequence -> .)
    END             reduce using rule 67 (factor_sequence -> .)
    ELSE            reduce using rule 67 (factor_sequence -> .)
    ,               reduce using rule 67 (factor_sequence -> .)
    ]               reduce using rule 67 (factor_sequence -> .)
    :               reduce using rule 67 (factor_sequence -> .)
    )               reduce using rule 67 (factor_sequence -> .)
    TO              reduce using rule 67 (factor_sequence -> .)
    DOWNTO          reduce using rule 67 (factor_sequence -> .)
    *               shift and go to state 178
    /               shift and go to state 179
    DIV             shift and go to state 180
    MOD             shift and go to state 181
    AND             shift and go to state 182

    factor_sequence                shift and go to state 176
    mul_op                         shift and go to state 177

state 121

    (59) factor -> var_access .
    (49) var_access -> var_access . [ expr expr_sequence ]

    *               reduce using rule 59 (factor -> var_access .)
    /               reduce using rule 59 (factor -> var_access .)
    DIV             reduce using rule 59 (factor -> var_access .)
    MOD             reduce using rule 59 (factor -> var_access .)
    AND             reduce using rule 59 (factor -> var_access .)
    +               reduce using rule 59 (factor -> var_access .)
    -               reduce using rule 59 (factor -> var_access .)
    OR              reduce using rule 59 (factor -> var_access .)
    =               reduce using rule 59 (factor -> var_access .)
    NE              reduce using rule 59 (factor -> var_access .)
    <               reduce using rule 59 (factor -> var_access .)
    >               reduce using rule 59 (factor -> var_access .)
    LE              reduce using rule 59 (factor -> var_access .)
    GE              reduce using rule 59 (factor -> var_access .)
    IN              reduce using rule 59 (factor -> var_access .)
    THEN            reduce using rule 59 (factor -> var_access .)
    DO              reduce using rule 59 (factor -> var_access .)
    ;               reduce using rule 59 (factor -> var_access .)
    END             reduce using rule 59 (factor -> var_access .)
    ELSE            reduce using rule 59 (factor -> var_access .)
    ,               reduce using rule 59 (factor -> var_access .)
    ]               reduce using rule 59 (factor -> var_access .)
    :               reduce using rule 59 (factor -> var_access .)
    )               reduce using rule 59 (factor -> var_access .)
    TO              reduce using rule 59 (factor -> var_access .)
    DOWNTO          reduce using rule 59 (factor -> var_access .)
    [               shift and go to state 108


state 122

    (60) factor -> INT .

    *               reduce using rule 60 (factor -> INT .)
    /               reduce using rule 60 (factor -> INT .)
    DIV             reduce using rule 60 (factor -> INT .)
    MOD             reduce using rule 60 (factor -> INT .)
    AND             reduce using rule 60 (factor -> INT .)
    +               reduce using rule 60 (factor -> INT .)
    -               reduce using rule 60 (factor -> INT .)
    OR              reduce using rule 60 (factor -> INT .)
    =               reduce using rule 60 (factor -> INT .)
    NE              reduce using rule 60 (factor -> INT .)
    <               reduce using rule 60 (factor -> INT .)
    >               reduce using rule 60 (factor -> INT .)
    LE              reduce using rule 60 (factor -> INT .)
    GE              reduce using rule 60 (factor -> INT .)
    IN              reduce using rule 60 (factor -> INT .)
    THEN            reduce using rule 60 (factor -> INT .)
    DO              reduce using rule 60 (factor -> INT .)
    ;               reduce using rule 60 (factor -> INT .)
    END             reduce using rule 60 (factor -> INT .)
    ELSE            reduce using rule 60 (factor -> INT .)
    ,               reduce using rule 60 (factor -> INT .)
    ]               reduce using rule 60 (factor -> INT .)
    :               reduce using rule 60 (factor -> INT .)
    )               reduce using rule 60 (factor -> INT .)
    TO              reduce using rule 60 (factor -> INT .)
    DOWNTO          reduce using rule 60 (factor -> INT .)


state 123

    (61) factor -> REAL .

    *               reduce using rule 61 (factor -> REAL .)
    /               reduce using rule 61 (factor -> REAL .)
    DIV             reduce using rule 61 (factor -> REAL .)
    MOD             reduce using rule 61 (factor -> REAL .)
    AND             reduce using rule 61 (factor -> REAL .)
    +               reduce using rule 61 (factor -> REAL .)
    -               reduce using rule 61 (factor -> REAL .)
    OR              reduce using rule 61 (factor -> REAL .)
    =               reduce using rule 61 (factor -> REAL .)
    NE              reduce using rule 61 (factor -> REAL .)
    <               reduce using rule 61 (factor -> REAL .)
    >               reduce using rule 61 (factor -> REAL .)
    LE              reduce using rule 61 (factor -> REAL .)
    GE              reduce using rule 61 (factor -> REAL .)
    IN              reduce using rule 61 (factor -> REAL .)
    THEN            reduce using rule 61 (factor -> REAL .)
    DO              reduce using rule 61 (factor -> REAL .)
    ;               reduce using rule 61 (factor -> REAL .)
    END             reduce using rule 61 (factor -> REAL .)
    ELSE            reduce using rule 61 (factor -> REAL .)
    ,               reduce using rule 61 (factor -> REAL .)
    ]               reduce using rule 61 (factor -> REAL .)
    :               reduce using rule 61 (factor -> REAL .)
    )               reduce using rule 61 (factor -> REAL .)
    TO              reduce using rule 61 (factor -> REAL .)
    DOWNTO          reduce using rule 61 (factor -> REAL .)


state 124

    (62) factor -> CHAR .

    *               reduce using rule 62 (factor -> CHAR .)
    /               reduce using rule 62 (factor -> CHAR .)
    DIV             reduce using rule 62 (factor -> CHAR .)
    MOD             reduce using rule 62 (factor -> CHAR .)
    AND             reduce using rule 62 (factor -> CHAR .)
    +               reduce using rule 62 (factor -> CHAR .)
    -               reduce using rule 62 (factor -> CHAR .)
    OR              reduce using rule 62 (factor -> CHAR .)
    =               reduce using rule 62 (factor -> CHAR .)
    NE              reduce using rule 62 (factor -> CHAR .)
    <               reduce using rule 62 (factor -> CHAR .)
    >               reduce using rule 62 (factor -> CHAR .)
    LE              reduce using rule 62 (factor -> CHAR .)
    GE              reduce using rule 62 (factor -> CHAR .)
    IN              reduce using rule 62 (factor -> CHAR .)
    THEN            reduce using rule 62 (factor -> CHAR .)
    DO              reduce using rule 62 (factor -> CHAR .)
    ;               reduce using rule 62 (factor -> CHAR .)
    END             reduce using rule 62 (factor -> CHAR .)
    ELSE            reduce using rule 62 (factor -> CHAR .)
    ,               reduce using rule 62 (factor -> CHAR .)
    ]               reduce using rule 62 (factor -> CHAR .)
    :               reduce using rule 62 (factor -> CHAR .)
    )               reduce using rule 62 (factor -> CHAR .)
    TO              reduce using rule 62 (factor -> CHAR .)
    DOWNTO          reduce using rule 62 (factor -> CHAR .)


state 125

    (63) factor -> STRING .

    *               reduce using rule 63 (factor -> STRING .)
    /               reduce using rule 63 (factor -> STRING .)
    DIV             reduce using rule 63 (factor -> STRING .)
    MOD             reduce using rule 63 (factor -> STRING .)
    AND             reduce using rule 63 (factor -> STRING .)
    +               reduce using rule 63 (factor -> STRING .)
    -               reduce using rule 63 (factor -> STRING .)
    OR              reduce using rule 63 (factor -> STRING .)
    =               reduce using rule 63 (factor -> STRING .)
    NE              reduce using rule 63 (factor -> STRING .)
    <               reduce using rule 63 (factor -> STRING .)
    >               reduce using rule 63 (factor -> STRING .)
    LE              reduce using rule 63 (factor -> STRING .)
    GE              reduce using rule 63 (factor -> STRING .)
    IN              reduce using rule 63 (factor -> STRING .)
    THEN            reduce using rule 63 (factor -> STRING .)
    DO              reduce using rule 63 (factor -> STRING .)
    ;               reduce using rule 63 (factor -> STRING .)
    END             reduce using rule 63 (factor -> STRING .)
    ELSE            reduce using rule 63 (factor -> STRING .)
    ,               reduce using rule 63 (factor -> STRING .)
    ]               reduce using rule 63 (factor -> STRING .)
    :               reduce using rule 63 (factor -> STRING .)
    )               reduce using rule 63 (factor -> STRING .)
    TO              reduce using rule 63 (factor -> STRING .)
    DOWNTO          reduce using rule 63 (factor -> STRING .)


state 126

    (64) factor -> ID . actual_param_list
    (48) var_access -> ID .
    (102) actual_param_list -> . ( actual_param actual_param_cont )

    [               reduce using rule 48 (var_access -> ID .)
    *               reduce using rule 48 (var_access -> ID .)
    /               reduce using rule 48 (var_access -> ID .)
    DIV             reduce using rule 48 (var_access -> ID .)
    MOD             reduce using rule 48 (var_access -> ID .)
    AND             reduce using rule 48 (var_access -> ID .)
    +               reduce using rule 48 (var_access -> ID .)
    -               reduce using rule 48 (var_access -> ID .)
    OR              reduce using rule 48 (var_access -> ID .)
    =               reduce using rule 48 (var_access -> ID .)
    NE              reduce using rule 48 (var_access -> ID .)
    <               reduce using rule 48 (var_access -> ID .)
    >               reduce using rule 48 (var_access -> ID .)
    LE              reduce using rule 48 (var_access -> ID .)
    GE              reduce using rule 48 (var_access -> ID .)
    IN              reduce using rule 48 (var_access -> ID .)
    THEN            reduce using rule 48 (var_access -> ID .)
    DO              reduce using rule 48 (var_access -> ID .)
    ;               reduce using rule 48 (var_access -> ID .)
    END             reduce using rule 48 (var_access -> ID .)
    ELSE            reduce using rule 48 (var_access -> ID .)
    ,               reduce using rule 48 (var_access -> ID .)
    ]               reduce using rule 48 (var_access -> ID .)
    :               reduce using rule 48 (var_access -> ID .)
    )               reduce using rule 48 (var_access -> ID .)
    TO              reduce using rule 48 (var_access -> ID .)
    DOWNTO          reduce using rule 48 (var_access -> ID .)
    (               shift and go to state 184

    actual_param_list              shift and go to state 183

state 127

    (65) factor -> ( . expr )
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    expr                           shift and go to state 185
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 128

    (66) factor -> NOT . factor
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    factor                         shift and go to state 186
    var_access                     shift and go to state 121

state 129

    (127) while_statement -> WHILE expr . DO statement

    DO              shift and go to state 187


state 130

    (128) for_statement -> FOR ID . ASSIGN expr TO expr DO statement
    (129) for_statement -> FOR ID . ASSIGN expr DOWNTO expr DO statement

    ASSIGN          shift and go to state 188


state 131

    (131) proc_dec -> PROCEDURE ID ; block .

    ;               reduce using rule 131 (proc_dec -> PROCEDURE ID ; block .)


state 132

    (138) formal_param_list -> ( formal_param_section . fcont )
    (139) fcont -> .
    (140) fcont -> . ; formal_param_section fcont

    )               reduce using rule 139 (fcont -> .)
    ;               shift and go to state 190

    fcont                          shift and go to state 189

state 133

    (141) formal_param_section -> id_list . : ID

    :               shift and go to state 191


state 134

    (142) formal_param_section -> VAR . id_list : ID
    (38) id_list -> . ID
    (39) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 192

state 135

    (143) formal_param_section -> proc_heading .

    ;               reduce using rule 143 (formal_param_section -> proc_heading .)
    )               reduce using rule 143 (formal_param_section -> proc_heading .)


state 136

    (144) formal_param_section -> func_heading .

    ;               reduce using rule 144 (formal_param_section -> func_heading .)
    )               reduce using rule 144 (formal_param_section -> func_heading .)


state 137

    (132) proc_heading -> PROCEDURE . ID
    (133) proc_heading -> PROCEDURE . ID formal_param_list

    ID              shift and go to state 193


state 138

    (136) func_heading -> FUNCTION . ID : ID
    (137) func_heading -> FUNCTION . ID formal_param_list : ID

    ID              shift and go to state 194


state 139

    (134) func_dec -> FUNCTION ID ; block .

    ;               reduce using rule 134 (func_dec -> FUNCTION ID ; block .)


state 140

    (136) func_heading -> FUNCTION ID : ID .

    ;               reduce using rule 136 (func_heading -> FUNCTION ID : ID .)
    )               reduce using rule 136 (func_heading -> FUNCTION ID : ID .)


state 141

    (137) func_heading -> FUNCTION ID formal_param_list : . ID

    ID              shift and go to state 195


state 142

    (16) vcont -> var_dec ; . vcont
    (15) vcont -> .
    (16) vcont -> . var_dec ; vcont
    (47) var_dec -> . id_list : tipo
    (38) id_list -> . ID
    (39) id_list -> . ID , id_list

    PROCEDURE       reduce using rule 15 (vcont -> .)
    FUNCTION        reduce using rule 15 (vcont -> .)
    BEGIN           reduce using rule 15 (vcont -> .)
    ID              shift and go to state 15

    var_dec                        shift and go to state 96
    vcont                          shift and go to state 196
    id_list                        shift and go to state 33

state 143

    (12) tcont -> type_def ; tcont .

    VAR             reduce using rule 12 (tcont -> type_def ; tcont .)
    PROCEDURE       reduce using rule 12 (tcont -> type_def ; tcont .)
    FUNCTION        reduce using rule 12 (tcont -> type_def ; tcont .)
    BEGIN           reduce using rule 12 (tcont -> type_def ; tcont .)


state 144

    (37) enumerated_type -> ( id_list ) .

    ;               reduce using rule 37 (enumerated_type -> ( id_list ) .)
    ,               reduce using rule 37 (enumerated_type -> ( id_list ) .)
    ]               reduce using rule 37 (enumerated_type -> ( id_list ) .)


state 145

    (40) subrange_type -> constant DOTDOT constant .

    ;               reduce using rule 40 (subrange_type -> constant DOTDOT constant .)
    ,               reduce using rule 40 (subrange_type -> constant DOTDOT constant .)
    ]               reduce using rule 40 (subrange_type -> constant DOTDOT constant .)


state 146

    (41) array_type -> ARRAY [ ordinal_type . acont ] OF tipo
    (42) acont -> .
    (43) acont -> . , ordinal_type acont

    ]               reduce using rule 42 (acont -> .)
    ,               shift and go to state 198

    acont                          shift and go to state 197

state 147

    (44) ordinal_type -> enumerated_type .

    ,               reduce using rule 44 (ordinal_type -> enumerated_type .)
    ]               reduce using rule 44 (ordinal_type -> enumerated_type .)


state 148

    (45) ordinal_type -> subrange_type .

    ,               reduce using rule 45 (ordinal_type -> subrange_type .)
    ]               reduce using rule 45 (ordinal_type -> subrange_type .)


state 149

    (46) ordinal_type -> ID .
    (27) constant -> ID .

    ,               reduce using rule 46 (ordinal_type -> ID .)
    ]               reduce using rule 46 (ordinal_type -> ID .)
    DOTDOT          reduce using rule 27 (constant -> ID .)


state 150

    (84) compound_statement -> BEGIN statement statement_sequence END .

    .               reduce using rule 84 (compound_statement -> BEGIN statement statement_sequence END .)
    ;               reduce using rule 84 (compound_statement -> BEGIN statement statement_sequence END .)
    END             reduce using rule 84 (compound_statement -> BEGIN statement statement_sequence END .)
    ELSE            reduce using rule 84 (compound_statement -> BEGIN statement statement_sequence END .)


state 151

    (86) statement_sequence -> ; statement . statement_sequence
    (85) statement_sequence -> .
    (86) statement_sequence -> . ; statement statement_sequence

    END             reduce using rule 85 (statement_sequence -> .)
    ;               shift and go to state 105

    statement_sequence             shift and go to state 199

state 152

    (89) statement -> INT : structured_statement .

    ;               reduce using rule 89 (statement -> INT : structured_statement .)
    END             reduce using rule 89 (statement -> INT : structured_statement .)
    ELSE            reduce using rule 89 (statement -> INT : structured_statement .)


state 153

    (90) statement -> INT : simple_statement .

    ;               reduce using rule 90 (statement -> INT : simple_statement .)
    END             reduce using rule 90 (statement -> INT : simple_statement .)
    ELSE            reduce using rule 90 (statement -> INT : simple_statement .)


state 154

    (94) assignment_statement -> var_access ASSIGN expr .

    ;               reduce using rule 94 (assignment_statement -> var_access ASSIGN expr .)
    END             reduce using rule 94 (assignment_statement -> var_access ASSIGN expr .)
    ELSE            reduce using rule 94 (assignment_statement -> var_access ASSIGN expr .)


state 155

    (49) var_access -> var_access [ expr . expr_sequence ]
    (50) expr_sequence -> .
    (51) expr_sequence -> . , expr expr_sequence

    ]               reduce using rule 50 (expr_sequence -> .)
    ,               shift and go to state 201

    expr_sequence                  shift and go to state 200

state 156

    (102) actual_param_list -> ( actual_param . actual_param_cont )
    (103) actual_param_cont -> .
    (104) actual_param_cont -> . , actual_param

    )               reduce using rule 103 (actual_param_cont -> .)
    ,               shift and go to state 203

    actual_param_cont              shift and go to state 202

state 157

    (107) read_param_list -> ( var_access . var_access_sequence )
    (112) write_param_list -> ( var_access . write_param_sequence )
    (106) actual_param -> var_access .
    (49) var_access -> var_access . [ expr expr_sequence ]
    (59) factor -> var_access .
    (108) var_access_sequence -> .
    (109) var_access_sequence -> . , var_access var_access_sequence
    (114) write_param_sequence -> .
    (115) write_param_sequence -> . , write_param write_param_sequence

  ! reduce/reduce conflict for , resolved using rule 59 (factor -> var_access .)
  ! reduce/reduce conflict for ) resolved using rule 59 (factor -> var_access .)
  ! reduce/reduce conflict for ) resolved using rule 59 (factor -> var_access .)
  ! shift/reduce conflict for , resolved as shift
  ! reduce/reduce conflict for ) resolved using rule 59 (factor -> var_access .)
    [               shift and go to state 108
    *               reduce using rule 59 (factor -> var_access .)
    /               reduce using rule 59 (factor -> var_access .)
    DIV             reduce using rule 59 (factor -> var_access .)
    MOD             reduce using rule 59 (factor -> var_access .)
    AND             reduce using rule 59 (factor -> var_access .)
    +               reduce using rule 59 (factor -> var_access .)
    -               reduce using rule 59 (factor -> var_access .)
    OR              reduce using rule 59 (factor -> var_access .)
    =               reduce using rule 59 (factor -> var_access .)
    NE              reduce using rule 59 (factor -> var_access .)
    <               reduce using rule 59 (factor -> var_access .)
    >               reduce using rule 59 (factor -> var_access .)
    LE              reduce using rule 59 (factor -> var_access .)
    GE              reduce using rule 59 (factor -> var_access .)
    IN              reduce using rule 59 (factor -> var_access .)
    :               reduce using rule 59 (factor -> var_access .)
    )               reduce using rule 59 (factor -> var_access .)
    ,               shift and go to state 206

  ! ,               [ reduce using rule 106 (actual_param -> var_access .) ]
  ! )               [ reduce using rule 106 (actual_param -> var_access .) ]
  ! ,               [ reduce using rule 59 (factor -> var_access .) ]
  ! )               [ reduce using rule 108 (var_access_sequence -> .) ]
  ! )               [ reduce using rule 114 (write_param_sequence -> .) ]

    var_access_sequence            shift and go to state 204
    write_param_sequence           shift and go to state 205

state 158

    (113) write_param_list -> ( write_param . write_param_sequence )
    (114) write_param_sequence -> .
    (115) write_param_sequence -> . , write_param write_param_sequence

    )               reduce using rule 114 (write_param_sequence -> .)
    ,               shift and go to state 208

    write_param_sequence           shift and go to state 207

state 159

    (105) actual_param -> expr .
    (116) write_param -> expr .
    (117) write_param -> expr . : expr
    (118) write_param -> expr . : expr : expr

  ! reduce/reduce conflict for , resolved using rule 105 (actual_param -> expr .)
  ! reduce/reduce conflict for ) resolved using rule 105 (actual_param -> expr .)
    ,               reduce using rule 105 (actual_param -> expr .)
    )               reduce using rule 105 (actual_param -> expr .)
    :               shift and go to state 209

  ! ,               [ reduce using rule 116 (write_param -> expr .) ]
  ! )               [ reduce using rule 116 (write_param -> expr .) ]


state 160

    (48) var_access -> ID .
    (64) factor -> ID . actual_param_list
    (102) actual_param_list -> . ( actual_param actual_param_cont )

    [               reduce using rule 48 (var_access -> ID .)
    ,               reduce using rule 48 (var_access -> ID .)
    )               reduce using rule 48 (var_access -> ID .)
    *               reduce using rule 48 (var_access -> ID .)
    /               reduce using rule 48 (var_access -> ID .)
    DIV             reduce using rule 48 (var_access -> ID .)
    MOD             reduce using rule 48 (var_access -> ID .)
    AND             reduce using rule 48 (var_access -> ID .)
    +               reduce using rule 48 (var_access -> ID .)
    -               reduce using rule 48 (var_access -> ID .)
    OR              reduce using rule 48 (var_access -> ID .)
    =               reduce using rule 48 (var_access -> ID .)
    NE              reduce using rule 48 (var_access -> ID .)
    <               reduce using rule 48 (var_access -> ID .)
    >               reduce using rule 48 (var_access -> ID .)
    LE              reduce using rule 48 (var_access -> ID .)
    GE              reduce using rule 48 (var_access -> ID .)
    IN              reduce using rule 48 (var_access -> ID .)
    :               reduce using rule 48 (var_access -> ID .)
    (               shift and go to state 184

    actual_param_list              shift and go to state 183

state 161

    (125) if_statement -> IF expr THEN . statement
    (126) if_statement -> IF expr THEN . statement ELSE statement
    (87) statement -> . simple_statement
    (88) statement -> . structured_statement
    (89) statement -> . INT : structured_statement
    (90) statement -> . INT : simple_statement
    (91) simple_statement -> .
    (92) simple_statement -> . assignment_statement
    (93) simple_statement -> . proc_statement
    (121) structured_statement -> . compound_statement
    (122) structured_statement -> . if_statement
    (123) structured_statement -> . while_statement
    (124) structured_statement -> . for_statement
    (94) assignment_statement -> . var_access ASSIGN expr
    (95) proc_statement -> . ID proc_id_cont
    (84) compound_statement -> . BEGIN statement statement_sequence END
    (125) if_statement -> . IF expr THEN statement
    (126) if_statement -> . IF expr THEN statement ELSE statement
    (127) while_statement -> . WHILE expr DO statement
    (128) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (129) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    INT             shift and go to state 76
    ELSE            reduce using rule 91 (simple_statement -> .)
    ;               reduce using rule 91 (simple_statement -> .)
    END             reduce using rule 91 (simple_statement -> .)
    ID              shift and go to state 84
    BEGIN           shift and go to state 49
    IF              shift and go to state 85
    WHILE           shift and go to state 86
    FOR             shift and go to state 87

    statement                      shift and go to state 210
    simple_statement               shift and go to state 74
    structured_statement           shift and go to state 75
    assignment_statement           shift and go to state 77
    proc_statement                 shift and go to state 78
    compound_statement             shift and go to state 79
    if_statement                   shift and go to state 80
    while_statement                shift and go to state 81
    for_statement                  shift and go to state 82
    var_access                     shift and go to state 83

state 162

    (53) expr -> simple_expr relation_op . simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    simple_expr                    shift and go to state 211
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 163

    (77) relation_op -> = .

    +               reduce using rule 77 (relation_op -> = .)
    -               reduce using rule 77 (relation_op -> = .)
    INT             reduce using rule 77 (relation_op -> = .)
    REAL            reduce using rule 77 (relation_op -> = .)
    CHAR            reduce using rule 77 (relation_op -> = .)
    STRING          reduce using rule 77 (relation_op -> = .)
    ID              reduce using rule 77 (relation_op -> = .)
    (               reduce using rule 77 (relation_op -> = .)
    NOT             reduce using rule 77 (relation_op -> = .)


state 164

    (78) relation_op -> NE .

    +               reduce using rule 78 (relation_op -> NE .)
    -               reduce using rule 78 (relation_op -> NE .)
    INT             reduce using rule 78 (relation_op -> NE .)
    REAL            reduce using rule 78 (relation_op -> NE .)
    CHAR            reduce using rule 78 (relation_op -> NE .)
    STRING          reduce using rule 78 (relation_op -> NE .)
    ID              reduce using rule 78 (relation_op -> NE .)
    (               reduce using rule 78 (relation_op -> NE .)
    NOT             reduce using rule 78 (relation_op -> NE .)


state 165

    (79) relation_op -> < .

    +               reduce using rule 79 (relation_op -> < .)
    -               reduce using rule 79 (relation_op -> < .)
    INT             reduce using rule 79 (relation_op -> < .)
    REAL            reduce using rule 79 (relation_op -> < .)
    CHAR            reduce using rule 79 (relation_op -> < .)
    STRING          reduce using rule 79 (relation_op -> < .)
    ID              reduce using rule 79 (relation_op -> < .)
    (               reduce using rule 79 (relation_op -> < .)
    NOT             reduce using rule 79 (relation_op -> < .)


state 166

    (80) relation_op -> > .

    +               reduce using rule 80 (relation_op -> > .)
    -               reduce using rule 80 (relation_op -> > .)
    INT             reduce using rule 80 (relation_op -> > .)
    REAL            reduce using rule 80 (relation_op -> > .)
    CHAR            reduce using rule 80 (relation_op -> > .)
    STRING          reduce using rule 80 (relation_op -> > .)
    ID              reduce using rule 80 (relation_op -> > .)
    (               reduce using rule 80 (relation_op -> > .)
    NOT             reduce using rule 80 (relation_op -> > .)


state 167

    (81) relation_op -> LE .

    +               reduce using rule 81 (relation_op -> LE .)
    -               reduce using rule 81 (relation_op -> LE .)
    INT             reduce using rule 81 (relation_op -> LE .)
    REAL            reduce using rule 81 (relation_op -> LE .)
    CHAR            reduce using rule 81 (relation_op -> LE .)
    STRING          reduce using rule 81 (relation_op -> LE .)
    ID              reduce using rule 81 (relation_op -> LE .)
    (               reduce using rule 81 (relation_op -> LE .)
    NOT             reduce using rule 81 (relation_op -> LE .)


state 168

    (82) relation_op -> GE .

    +               reduce using rule 82 (relation_op -> GE .)
    -               reduce using rule 82 (relation_op -> GE .)
    INT             reduce using rule 82 (relation_op -> GE .)
    REAL            reduce using rule 82 (relation_op -> GE .)
    CHAR            reduce using rule 82 (relation_op -> GE .)
    STRING          reduce using rule 82 (relation_op -> GE .)
    ID              reduce using rule 82 (relation_op -> GE .)
    (               reduce using rule 82 (relation_op -> GE .)
    NOT             reduce using rule 82 (relation_op -> GE .)


state 169

    (83) relation_op -> IN .

    +               reduce using rule 83 (relation_op -> IN .)
    -               reduce using rule 83 (relation_op -> IN .)
    INT             reduce using rule 83 (relation_op -> IN .)
    REAL            reduce using rule 83 (relation_op -> IN .)
    CHAR            reduce using rule 83 (relation_op -> IN .)
    STRING          reduce using rule 83 (relation_op -> IN .)
    ID              reduce using rule 83 (relation_op -> IN .)
    (               reduce using rule 83 (relation_op -> IN .)
    NOT             reduce using rule 83 (relation_op -> IN .)


state 170

    (54) simple_expr -> term term_sequence .

    =               reduce using rule 54 (simple_expr -> term term_sequence .)
    NE              reduce using rule 54 (simple_expr -> term term_sequence .)
    <               reduce using rule 54 (simple_expr -> term term_sequence .)
    >               reduce using rule 54 (simple_expr -> term term_sequence .)
    LE              reduce using rule 54 (simple_expr -> term term_sequence .)
    GE              reduce using rule 54 (simple_expr -> term term_sequence .)
    IN              reduce using rule 54 (simple_expr -> term term_sequence .)
    THEN            reduce using rule 54 (simple_expr -> term term_sequence .)
    DO              reduce using rule 54 (simple_expr -> term term_sequence .)
    ;               reduce using rule 54 (simple_expr -> term term_sequence .)
    END             reduce using rule 54 (simple_expr -> term term_sequence .)
    ELSE            reduce using rule 54 (simple_expr -> term term_sequence .)
    ,               reduce using rule 54 (simple_expr -> term term_sequence .)
    ]               reduce using rule 54 (simple_expr -> term term_sequence .)
    :               reduce using rule 54 (simple_expr -> term term_sequence .)
    )               reduce using rule 54 (simple_expr -> term term_sequence .)
    TO              reduce using rule 54 (simple_expr -> term term_sequence .)
    DOWNTO          reduce using rule 54 (simple_expr -> term term_sequence .)


state 171

    (58) term_sequence -> add_op . term term_sequence
    (56) term -> . factor factor_sequence
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    term                           shift and go to state 212
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 172

    (69) add_op -> + .

    INT             reduce using rule 69 (add_op -> + .)
    REAL            reduce using rule 69 (add_op -> + .)
    CHAR            reduce using rule 69 (add_op -> + .)
    STRING          reduce using rule 69 (add_op -> + .)
    ID              reduce using rule 69 (add_op -> + .)
    (               reduce using rule 69 (add_op -> + .)
    NOT             reduce using rule 69 (add_op -> + .)


state 173

    (70) add_op -> - .

    INT             reduce using rule 70 (add_op -> - .)
    REAL            reduce using rule 70 (add_op -> - .)
    CHAR            reduce using rule 70 (add_op -> - .)
    STRING          reduce using rule 70 (add_op -> - .)
    ID              reduce using rule 70 (add_op -> - .)
    (               reduce using rule 70 (add_op -> - .)
    NOT             reduce using rule 70 (add_op -> - .)


state 174

    (71) add_op -> OR .

    INT             reduce using rule 71 (add_op -> OR .)
    REAL            reduce using rule 71 (add_op -> OR .)
    CHAR            reduce using rule 71 (add_op -> OR .)
    STRING          reduce using rule 71 (add_op -> OR .)
    ID              reduce using rule 71 (add_op -> OR .)
    (               reduce using rule 71 (add_op -> OR .)
    NOT             reduce using rule 71 (add_op -> OR .)


state 175

    (55) simple_expr -> sign term . term_sequence
    (57) term_sequence -> .
    (58) term_sequence -> . add_op term term_sequence
    (69) add_op -> . +
    (70) add_op -> . -
    (71) add_op -> . OR

    =               reduce using rule 57 (term_sequence -> .)
    NE              reduce using rule 57 (term_sequence -> .)
    <               reduce using rule 57 (term_sequence -> .)
    >               reduce using rule 57 (term_sequence -> .)
    LE              reduce using rule 57 (term_sequence -> .)
    GE              reduce using rule 57 (term_sequence -> .)
    IN              reduce using rule 57 (term_sequence -> .)
    THEN            reduce using rule 57 (term_sequence -> .)
    DO              reduce using rule 57 (term_sequence -> .)
    ;               reduce using rule 57 (term_sequence -> .)
    END             reduce using rule 57 (term_sequence -> .)
    ELSE            reduce using rule 57 (term_sequence -> .)
    ,               reduce using rule 57 (term_sequence -> .)
    ]               reduce using rule 57 (term_sequence -> .)
    :               reduce using rule 57 (term_sequence -> .)
    )               reduce using rule 57 (term_sequence -> .)
    TO              reduce using rule 57 (term_sequence -> .)
    DOWNTO          reduce using rule 57 (term_sequence -> .)
    +               shift and go to state 172
    -               shift and go to state 173
    OR              shift and go to state 174

    term_sequence                  shift and go to state 213
    add_op                         shift and go to state 171

state 176

    (56) term -> factor factor_sequence .

    +               reduce using rule 56 (term -> factor factor_sequence .)
    -               reduce using rule 56 (term -> factor factor_sequence .)
    OR              reduce using rule 56 (term -> factor factor_sequence .)
    =               reduce using rule 56 (term -> factor factor_sequence .)
    NE              reduce using rule 56 (term -> factor factor_sequence .)
    <               reduce using rule 56 (term -> factor factor_sequence .)
    >               reduce using rule 56 (term -> factor factor_sequence .)
    LE              reduce using rule 56 (term -> factor factor_sequence .)
    GE              reduce using rule 56 (term -> factor factor_sequence .)
    IN              reduce using rule 56 (term -> factor factor_sequence .)
    THEN            reduce using rule 56 (term -> factor factor_sequence .)
    DO              reduce using rule 56 (term -> factor factor_sequence .)
    ;               reduce using rule 56 (term -> factor factor_sequence .)
    END             reduce using rule 56 (term -> factor factor_sequence .)
    ELSE            reduce using rule 56 (term -> factor factor_sequence .)
    ,               reduce using rule 56 (term -> factor factor_sequence .)
    ]               reduce using rule 56 (term -> factor factor_sequence .)
    :               reduce using rule 56 (term -> factor factor_sequence .)
    )               reduce using rule 56 (term -> factor factor_sequence .)
    TO              reduce using rule 56 (term -> factor factor_sequence .)
    DOWNTO          reduce using rule 56 (term -> factor factor_sequence .)


state 177

    (68) factor_sequence -> mul_op . factor factor_sequence
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    factor                         shift and go to state 214
    var_access                     shift and go to state 121

state 178

    (72) mul_op -> * .

    INT             reduce using rule 72 (mul_op -> * .)
    REAL            reduce using rule 72 (mul_op -> * .)
    CHAR            reduce using rule 72 (mul_op -> * .)
    STRING          reduce using rule 72 (mul_op -> * .)
    ID              reduce using rule 72 (mul_op -> * .)
    (               reduce using rule 72 (mul_op -> * .)
    NOT             reduce using rule 72 (mul_op -> * .)


state 179

    (73) mul_op -> / .

    INT             reduce using rule 73 (mul_op -> / .)
    REAL            reduce using rule 73 (mul_op -> / .)
    CHAR            reduce using rule 73 (mul_op -> / .)
    STRING          reduce using rule 73 (mul_op -> / .)
    ID              reduce using rule 73 (mul_op -> / .)
    (               reduce using rule 73 (mul_op -> / .)
    NOT             reduce using rule 73 (mul_op -> / .)


state 180

    (74) mul_op -> DIV .

    INT             reduce using rule 74 (mul_op -> DIV .)
    REAL            reduce using rule 74 (mul_op -> DIV .)
    CHAR            reduce using rule 74 (mul_op -> DIV .)
    STRING          reduce using rule 74 (mul_op -> DIV .)
    ID              reduce using rule 74 (mul_op -> DIV .)
    (               reduce using rule 74 (mul_op -> DIV .)
    NOT             reduce using rule 74 (mul_op -> DIV .)


state 181

    (75) mul_op -> MOD .

    INT             reduce using rule 75 (mul_op -> MOD .)
    REAL            reduce using rule 75 (mul_op -> MOD .)
    CHAR            reduce using rule 75 (mul_op -> MOD .)
    STRING          reduce using rule 75 (mul_op -> MOD .)
    ID              reduce using rule 75 (mul_op -> MOD .)
    (               reduce using rule 75 (mul_op -> MOD .)
    NOT             reduce using rule 75 (mul_op -> MOD .)


state 182

    (76) mul_op -> AND .

    INT             reduce using rule 76 (mul_op -> AND .)
    REAL            reduce using rule 76 (mul_op -> AND .)
    CHAR            reduce using rule 76 (mul_op -> AND .)
    STRING          reduce using rule 76 (mul_op -> AND .)
    ID              reduce using rule 76 (mul_op -> AND .)
    (               reduce using rule 76 (mul_op -> AND .)
    NOT             reduce using rule 76 (mul_op -> AND .)


state 183

    (64) factor -> ID actual_param_list .

    *               reduce using rule 64 (factor -> ID actual_param_list .)
    /               reduce using rule 64 (factor -> ID actual_param_list .)
    DIV             reduce using rule 64 (factor -> ID actual_param_list .)
    MOD             reduce using rule 64 (factor -> ID actual_param_list .)
    AND             reduce using rule 64 (factor -> ID actual_param_list .)
    +               reduce using rule 64 (factor -> ID actual_param_list .)
    -               reduce using rule 64 (factor -> ID actual_param_list .)
    OR              reduce using rule 64 (factor -> ID actual_param_list .)
    =               reduce using rule 64 (factor -> ID actual_param_list .)
    NE              reduce using rule 64 (factor -> ID actual_param_list .)
    <               reduce using rule 64 (factor -> ID actual_param_list .)
    >               reduce using rule 64 (factor -> ID actual_param_list .)
    LE              reduce using rule 64 (factor -> ID actual_param_list .)
    GE              reduce using rule 64 (factor -> ID actual_param_list .)
    IN              reduce using rule 64 (factor -> ID actual_param_list .)
    THEN            reduce using rule 64 (factor -> ID actual_param_list .)
    DO              reduce using rule 64 (factor -> ID actual_param_list .)
    ;               reduce using rule 64 (factor -> ID actual_param_list .)
    END             reduce using rule 64 (factor -> ID actual_param_list .)
    ELSE            reduce using rule 64 (factor -> ID actual_param_list .)
    ,               reduce using rule 64 (factor -> ID actual_param_list .)
    ]               reduce using rule 64 (factor -> ID actual_param_list .)
    :               reduce using rule 64 (factor -> ID actual_param_list .)
    )               reduce using rule 64 (factor -> ID actual_param_list .)
    TO              reduce using rule 64 (factor -> ID actual_param_list .)
    DOWNTO          reduce using rule 64 (factor -> ID actual_param_list .)


state 184

    (102) actual_param_list -> ( . actual_param actual_param_cont )
    (105) actual_param -> . expr
    (106) actual_param -> . var_access
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor

    ID              shift and go to state 160
    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    (               shift and go to state 127
    NOT             shift and go to state 128

    actual_param                   shift and go to state 156
    expr                           shift and go to state 215
    var_access                     shift and go to state 216
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120

state 185

    (65) factor -> ( expr . )

    )               shift and go to state 217


state 186

    (66) factor -> NOT factor .

    *               reduce using rule 66 (factor -> NOT factor .)
    /               reduce using rule 66 (factor -> NOT factor .)
    DIV             reduce using rule 66 (factor -> NOT factor .)
    MOD             reduce using rule 66 (factor -> NOT factor .)
    AND             reduce using rule 66 (factor -> NOT factor .)
    +               reduce using rule 66 (factor -> NOT factor .)
    -               reduce using rule 66 (factor -> NOT factor .)
    OR              reduce using rule 66 (factor -> NOT factor .)
    =               reduce using rule 66 (factor -> NOT factor .)
    NE              reduce using rule 66 (factor -> NOT factor .)
    <               reduce using rule 66 (factor -> NOT factor .)
    >               reduce using rule 66 (factor -> NOT factor .)
    LE              reduce using rule 66 (factor -> NOT factor .)
    GE              reduce using rule 66 (factor -> NOT factor .)
    IN              reduce using rule 66 (factor -> NOT factor .)
    THEN            reduce using rule 66 (factor -> NOT factor .)
    DO              reduce using rule 66 (factor -> NOT factor .)
    ;               reduce using rule 66 (factor -> NOT factor .)
    END             reduce using rule 66 (factor -> NOT factor .)
    ELSE            reduce using rule 66 (factor -> NOT factor .)
    ,               reduce using rule 66 (factor -> NOT factor .)
    ]               reduce using rule 66 (factor -> NOT factor .)
    :               reduce using rule 66 (factor -> NOT factor .)
    )               reduce using rule 66 (factor -> NOT factor .)
    TO              reduce using rule 66 (factor -> NOT factor .)
    DOWNTO          reduce using rule 66 (factor -> NOT factor .)


state 187

    (127) while_statement -> WHILE expr DO . statement
    (87) statement -> . simple_statement
    (88) statement -> . structured_statement
    (89) statement -> . INT : structured_statement
    (90) statement -> . INT : simple_statement
    (91) simple_statement -> .
    (92) simple_statement -> . assignment_statement
    (93) simple_statement -> . proc_statement
    (121) structured_statement -> . compound_statement
    (122) structured_statement -> . if_statement
    (123) structured_statement -> . while_statement
    (124) structured_statement -> . for_statement
    (94) assignment_statement -> . var_access ASSIGN expr
    (95) proc_statement -> . ID proc_id_cont
    (84) compound_statement -> . BEGIN statement statement_sequence END
    (125) if_statement -> . IF expr THEN statement
    (126) if_statement -> . IF expr THEN statement ELSE statement
    (127) while_statement -> . WHILE expr DO statement
    (128) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (129) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    INT             shift and go to state 76
    ELSE            reduce using rule 91 (simple_statement -> .)
    ;               reduce using rule 91 (simple_statement -> .)
    END             reduce using rule 91 (simple_statement -> .)
    ID              shift and go to state 84
    BEGIN           shift and go to state 49
    IF              shift and go to state 85
    WHILE           shift and go to state 86
    FOR             shift and go to state 87

    statement                      shift and go to state 218
    simple_statement               shift and go to state 74
    structured_statement           shift and go to state 75
    assignment_statement           shift and go to state 77
    proc_statement                 shift and go to state 78
    compound_statement             shift and go to state 79
    if_statement                   shift and go to state 80
    while_statement                shift and go to state 81
    for_statement                  shift and go to state 82
    var_access                     shift and go to state 83

state 188

    (128) for_statement -> FOR ID ASSIGN . expr TO expr DO statement
    (129) for_statement -> FOR ID ASSIGN . expr DOWNTO expr DO statement
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    expr                           shift and go to state 219
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 189

    (138) formal_param_list -> ( formal_param_section fcont . )

    )               shift and go to state 220


state 190

    (140) fcont -> ; . formal_param_section fcont
    (141) formal_param_section -> . id_list : ID
    (142) formal_param_section -> . VAR id_list : ID
    (143) formal_param_section -> . proc_heading
    (144) formal_param_section -> . func_heading
    (38) id_list -> . ID
    (39) id_list -> . ID , id_list
    (132) proc_heading -> . PROCEDURE ID
    (133) proc_heading -> . PROCEDURE ID formal_param_list
    (136) func_heading -> . FUNCTION ID : ID
    (137) func_heading -> . FUNCTION ID formal_param_list : ID

    VAR             shift and go to state 134
    ID              shift and go to state 15
    PROCEDURE       shift and go to state 137
    FUNCTION        shift and go to state 138

    formal_param_section           shift and go to state 221
    id_list                        shift and go to state 133
    proc_heading                   shift and go to state 135
    func_heading                   shift and go to state 136

state 191

    (141) formal_param_section -> id_list : . ID

    ID              shift and go to state 222


state 192

    (142) formal_param_section -> VAR id_list . : ID

    :               shift and go to state 223


state 193

    (132) proc_heading -> PROCEDURE ID .
    (133) proc_heading -> PROCEDURE ID . formal_param_list
    (138) formal_param_list -> . ( formal_param_section fcont )

    ;               reduce using rule 132 (proc_heading -> PROCEDURE ID .)
    )               reduce using rule 132 (proc_heading -> PROCEDURE ID .)
    (               shift and go to state 91

    formal_param_list              shift and go to state 90

state 194

    (136) func_heading -> FUNCTION ID . : ID
    (137) func_heading -> FUNCTION ID . formal_param_list : ID
    (138) formal_param_list -> . ( formal_param_section fcont )

    :               shift and go to state 93
    (               shift and go to state 91

    formal_param_list              shift and go to state 94

state 195

    (137) func_heading -> FUNCTION ID formal_param_list : ID .

    ;               reduce using rule 137 (func_heading -> FUNCTION ID formal_param_list : ID .)
    )               reduce using rule 137 (func_heading -> FUNCTION ID formal_param_list : ID .)


state 196

    (16) vcont -> var_dec ; vcont .

    PROCEDURE       reduce using rule 16 (vcont -> var_dec ; vcont .)
    FUNCTION        reduce using rule 16 (vcont -> var_dec ; vcont .)
    BEGIN           reduce using rule 16 (vcont -> var_dec ; vcont .)


state 197

    (41) array_type -> ARRAY [ ordinal_type acont . ] OF tipo

    ]               shift and go to state 224


state 198

    (43) acont -> , . ordinal_type acont
    (44) ordinal_type -> . enumerated_type
    (45) ordinal_type -> . subrange_type
    (46) ordinal_type -> . ID
    (37) enumerated_type -> . ( id_list )
    (40) subrange_type -> . constant DOTDOT constant
    (23) constant -> . sign INT
    (24) constant -> . INT
    (25) constant -> . sign REAL
    (26) constant -> . REAL
    (27) constant -> . ID
    (28) constant -> . sign ID
    (29) constant -> . CHAR
    (30) constant -> . STRING
    (21) sign -> . +
    (22) sign -> . -

    ID              shift and go to state 149
    (               shift and go to state 66
    INT             shift and go to state 41
    REAL            shift and go to state 42
    CHAR            shift and go to state 43
    STRING          shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

    ordinal_type                   shift and go to state 225
    enumerated_type                shift and go to state 147
    subrange_type                  shift and go to state 148
    constant                       shift and go to state 67
    sign                           shift and go to state 40

state 199

    (86) statement_sequence -> ; statement statement_sequence .

    END             reduce using rule 86 (statement_sequence -> ; statement statement_sequence .)


state 200

    (49) var_access -> var_access [ expr expr_sequence . ]

    ]               shift and go to state 226


state 201

    (51) expr_sequence -> , . expr expr_sequence
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    expr                           shift and go to state 227
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 202

    (102) actual_param_list -> ( actual_param actual_param_cont . )

    )               shift and go to state 228


state 203

    (104) actual_param_cont -> , . actual_param
    (105) actual_param -> . expr
    (106) actual_param -> . var_access
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor

    ID              shift and go to state 160
    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    (               shift and go to state 127
    NOT             shift and go to state 128

    actual_param                   shift and go to state 229
    expr                           shift and go to state 215
    var_access                     shift and go to state 216
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120

state 204

    (107) read_param_list -> ( var_access var_access_sequence . )

    )               shift and go to state 230


state 205

    (112) write_param_list -> ( var_access write_param_sequence . )

    )               shift and go to state 231


state 206

    (109) var_access_sequence -> , . var_access var_access_sequence
    (115) write_param_sequence -> , . write_param write_param_sequence
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]
    (116) write_param -> . expr
    (117) write_param -> . expr : expr
    (118) write_param -> . expr : expr : expr
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor

    ID              shift and go to state 160
    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    (               shift and go to state 127
    NOT             shift and go to state 128

    var_access                     shift and go to state 232
    write_param                    shift and go to state 233
    expr                           shift and go to state 234
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120

state 207

    (113) write_param_list -> ( write_param write_param_sequence . )

    )               shift and go to state 235


state 208

    (115) write_param_sequence -> , . write_param write_param_sequence
    (116) write_param -> . expr
    (117) write_param -> . expr : expr
    (118) write_param -> . expr : expr : expr
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    write_param                    shift and go to state 233
    expr                           shift and go to state 234
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 209

    (117) write_param -> expr : . expr
    (118) write_param -> expr : . expr : expr
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    expr                           shift and go to state 236
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 210

    (125) if_statement -> IF expr THEN statement .
    (126) if_statement -> IF expr THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    ;               reduce using rule 125 (if_statement -> IF expr THEN statement .)
    END             reduce using rule 125 (if_statement -> IF expr THEN statement .)
    ELSE            shift and go to state 237

  ! ELSE            [ reduce using rule 125 (if_statement -> IF expr THEN statement .) ]


state 211

    (53) expr -> simple_expr relation_op simple_expr .

    THEN            reduce using rule 53 (expr -> simple_expr relation_op simple_expr .)
    DO              reduce using rule 53 (expr -> simple_expr relation_op simple_expr .)
    ;               reduce using rule 53 (expr -> simple_expr relation_op simple_expr .)
    END             reduce using rule 53 (expr -> simple_expr relation_op simple_expr .)
    ELSE            reduce using rule 53 (expr -> simple_expr relation_op simple_expr .)
    ,               reduce using rule 53 (expr -> simple_expr relation_op simple_expr .)
    ]               reduce using rule 53 (expr -> simple_expr relation_op simple_expr .)
    :               reduce using rule 53 (expr -> simple_expr relation_op simple_expr .)
    )               reduce using rule 53 (expr -> simple_expr relation_op simple_expr .)
    TO              reduce using rule 53 (expr -> simple_expr relation_op simple_expr .)
    DOWNTO          reduce using rule 53 (expr -> simple_expr relation_op simple_expr .)


state 212

    (58) term_sequence -> add_op term . term_sequence
    (57) term_sequence -> .
    (58) term_sequence -> . add_op term term_sequence
    (69) add_op -> . +
    (70) add_op -> . -
    (71) add_op -> . OR

    =               reduce using rule 57 (term_sequence -> .)
    NE              reduce using rule 57 (term_sequence -> .)
    <               reduce using rule 57 (term_sequence -> .)
    >               reduce using rule 57 (term_sequence -> .)
    LE              reduce using rule 57 (term_sequence -> .)
    GE              reduce using rule 57 (term_sequence -> .)
    IN              reduce using rule 57 (term_sequence -> .)
    THEN            reduce using rule 57 (term_sequence -> .)
    DO              reduce using rule 57 (term_sequence -> .)
    ;               reduce using rule 57 (term_sequence -> .)
    END             reduce using rule 57 (term_sequence -> .)
    ELSE            reduce using rule 57 (term_sequence -> .)
    ,               reduce using rule 57 (term_sequence -> .)
    ]               reduce using rule 57 (term_sequence -> .)
    :               reduce using rule 57 (term_sequence -> .)
    )               reduce using rule 57 (term_sequence -> .)
    TO              reduce using rule 57 (term_sequence -> .)
    DOWNTO          reduce using rule 57 (term_sequence -> .)
    +               shift and go to state 172
    -               shift and go to state 173
    OR              shift and go to state 174

    add_op                         shift and go to state 171
    term_sequence                  shift and go to state 238

state 213

    (55) simple_expr -> sign term term_sequence .

    =               reduce using rule 55 (simple_expr -> sign term term_sequence .)
    NE              reduce using rule 55 (simple_expr -> sign term term_sequence .)
    <               reduce using rule 55 (simple_expr -> sign term term_sequence .)
    >               reduce using rule 55 (simple_expr -> sign term term_sequence .)
    LE              reduce using rule 55 (simple_expr -> sign term term_sequence .)
    GE              reduce using rule 55 (simple_expr -> sign term term_sequence .)
    IN              reduce using rule 55 (simple_expr -> sign term term_sequence .)
    THEN            reduce using rule 55 (simple_expr -> sign term term_sequence .)
    DO              reduce using rule 55 (simple_expr -> sign term term_sequence .)
    ;               reduce using rule 55 (simple_expr -> sign term term_sequence .)
    END             reduce using rule 55 (simple_expr -> sign term term_sequence .)
    ELSE            reduce using rule 55 (simple_expr -> sign term term_sequence .)
    ,               reduce using rule 55 (simple_expr -> sign term term_sequence .)
    ]               reduce using rule 55 (simple_expr -> sign term term_sequence .)
    :               reduce using rule 55 (simple_expr -> sign term term_sequence .)
    )               reduce using rule 55 (simple_expr -> sign term term_sequence .)
    TO              reduce using rule 55 (simple_expr -> sign term term_sequence .)
    DOWNTO          reduce using rule 55 (simple_expr -> sign term term_sequence .)


state 214

    (68) factor_sequence -> mul_op factor . factor_sequence
    (67) factor_sequence -> .
    (68) factor_sequence -> . mul_op factor factor_sequence
    (72) mul_op -> . *
    (73) mul_op -> . /
    (74) mul_op -> . DIV
    (75) mul_op -> . MOD
    (76) mul_op -> . AND

    +               reduce using rule 67 (factor_sequence -> .)
    -               reduce using rule 67 (factor_sequence -> .)
    OR              reduce using rule 67 (factor_sequence -> .)
    =               reduce using rule 67 (factor_sequence -> .)
    NE              reduce using rule 67 (factor_sequence -> .)
    <               reduce using rule 67 (factor_sequence -> .)
    >               reduce using rule 67 (factor_sequence -> .)
    LE              reduce using rule 67 (factor_sequence -> .)
    GE              reduce using rule 67 (factor_sequence -> .)
    IN              reduce using rule 67 (factor_sequence -> .)
    THEN            reduce using rule 67 (factor_sequence -> .)
    DO              reduce using rule 67 (factor_sequence -> .)
    ;               reduce using rule 67 (factor_sequence -> .)
    END             reduce using rule 67 (factor_sequence -> .)
    ELSE            reduce using rule 67 (factor_sequence -> .)
    ,               reduce using rule 67 (factor_sequence -> .)
    ]               reduce using rule 67 (factor_sequence -> .)
    :               reduce using rule 67 (factor_sequence -> .)
    )               reduce using rule 67 (factor_sequence -> .)
    TO              reduce using rule 67 (factor_sequence -> .)
    DOWNTO          reduce using rule 67 (factor_sequence -> .)
    *               shift and go to state 178
    /               shift and go to state 179
    DIV             shift and go to state 180
    MOD             shift and go to state 181
    AND             shift and go to state 182

    mul_op                         shift and go to state 177
    factor_sequence                shift and go to state 239

state 215

    (105) actual_param -> expr .

    ,               reduce using rule 105 (actual_param -> expr .)
    )               reduce using rule 105 (actual_param -> expr .)


state 216

    (106) actual_param -> var_access .
    (49) var_access -> var_access . [ expr expr_sequence ]
    (59) factor -> var_access .

  ! reduce/reduce conflict for , resolved using rule 59 (factor -> var_access .)
  ! reduce/reduce conflict for ) resolved using rule 59 (factor -> var_access .)
    [               shift and go to state 108
    *               reduce using rule 59 (factor -> var_access .)
    /               reduce using rule 59 (factor -> var_access .)
    DIV             reduce using rule 59 (factor -> var_access .)
    MOD             reduce using rule 59 (factor -> var_access .)
    AND             reduce using rule 59 (factor -> var_access .)
    +               reduce using rule 59 (factor -> var_access .)
    -               reduce using rule 59 (factor -> var_access .)
    OR              reduce using rule 59 (factor -> var_access .)
    =               reduce using rule 59 (factor -> var_access .)
    NE              reduce using rule 59 (factor -> var_access .)
    <               reduce using rule 59 (factor -> var_access .)
    >               reduce using rule 59 (factor -> var_access .)
    LE              reduce using rule 59 (factor -> var_access .)
    GE              reduce using rule 59 (factor -> var_access .)
    IN              reduce using rule 59 (factor -> var_access .)
    ,               reduce using rule 59 (factor -> var_access .)
    )               reduce using rule 59 (factor -> var_access .)

  ! ,               [ reduce using rule 106 (actual_param -> var_access .) ]
  ! )               [ reduce using rule 106 (actual_param -> var_access .) ]


state 217

    (65) factor -> ( expr ) .

    *               reduce using rule 65 (factor -> ( expr ) .)
    /               reduce using rule 65 (factor -> ( expr ) .)
    DIV             reduce using rule 65 (factor -> ( expr ) .)
    MOD             reduce using rule 65 (factor -> ( expr ) .)
    AND             reduce using rule 65 (factor -> ( expr ) .)
    +               reduce using rule 65 (factor -> ( expr ) .)
    -               reduce using rule 65 (factor -> ( expr ) .)
    OR              reduce using rule 65 (factor -> ( expr ) .)
    =               reduce using rule 65 (factor -> ( expr ) .)
    NE              reduce using rule 65 (factor -> ( expr ) .)
    <               reduce using rule 65 (factor -> ( expr ) .)
    >               reduce using rule 65 (factor -> ( expr ) .)
    LE              reduce using rule 65 (factor -> ( expr ) .)
    GE              reduce using rule 65 (factor -> ( expr ) .)
    IN              reduce using rule 65 (factor -> ( expr ) .)
    THEN            reduce using rule 65 (factor -> ( expr ) .)
    DO              reduce using rule 65 (factor -> ( expr ) .)
    ;               reduce using rule 65 (factor -> ( expr ) .)
    END             reduce using rule 65 (factor -> ( expr ) .)
    ELSE            reduce using rule 65 (factor -> ( expr ) .)
    ,               reduce using rule 65 (factor -> ( expr ) .)
    ]               reduce using rule 65 (factor -> ( expr ) .)
    :               reduce using rule 65 (factor -> ( expr ) .)
    )               reduce using rule 65 (factor -> ( expr ) .)
    TO              reduce using rule 65 (factor -> ( expr ) .)
    DOWNTO          reduce using rule 65 (factor -> ( expr ) .)


state 218

    (127) while_statement -> WHILE expr DO statement .

    ;               reduce using rule 127 (while_statement -> WHILE expr DO statement .)
    END             reduce using rule 127 (while_statement -> WHILE expr DO statement .)
    ELSE            reduce using rule 127 (while_statement -> WHILE expr DO statement .)


state 219

    (128) for_statement -> FOR ID ASSIGN expr . TO expr DO statement
    (129) for_statement -> FOR ID ASSIGN expr . DOWNTO expr DO statement

    TO              shift and go to state 240
    DOWNTO          shift and go to state 241


state 220

    (138) formal_param_list -> ( formal_param_section fcont ) .

    ;               reduce using rule 138 (formal_param_list -> ( formal_param_section fcont ) .)
    :               reduce using rule 138 (formal_param_list -> ( formal_param_section fcont ) .)
    )               reduce using rule 138 (formal_param_list -> ( formal_param_section fcont ) .)


state 221

    (140) fcont -> ; formal_param_section . fcont
    (139) fcont -> .
    (140) fcont -> . ; formal_param_section fcont

    )               reduce using rule 139 (fcont -> .)
    ;               shift and go to state 190

    fcont                          shift and go to state 242

state 222

    (141) formal_param_section -> id_list : ID .

    ;               reduce using rule 141 (formal_param_section -> id_list : ID .)
    )               reduce using rule 141 (formal_param_section -> id_list : ID .)


state 223

    (142) formal_param_section -> VAR id_list : . ID

    ID              shift and go to state 243


state 224

    (41) array_type -> ARRAY [ ordinal_type acont ] . OF tipo

    OF              shift and go to state 244


state 225

    (43) acont -> , ordinal_type . acont
    (42) acont -> .
    (43) acont -> . , ordinal_type acont

    ]               reduce using rule 42 (acont -> .)
    ,               shift and go to state 198

    acont                          shift and go to state 245

state 226

    (49) var_access -> var_access [ expr expr_sequence ] .

    ASSIGN          reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    [               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    *               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    /               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    DIV             reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    MOD             reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    AND             reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    +               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    -               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    OR              reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    =               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    NE              reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    <               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    >               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    LE              reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    GE              reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    IN              reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    THEN            reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    DO              reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    ;               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    END             reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    ELSE            reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    ,               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    ]               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    )               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    :               reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    TO              reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)
    DOWNTO          reduce using rule 49 (var_access -> var_access [ expr expr_sequence ] .)


state 227

    (51) expr_sequence -> , expr . expr_sequence
    (50) expr_sequence -> .
    (51) expr_sequence -> . , expr expr_sequence

    ]               reduce using rule 50 (expr_sequence -> .)
    ,               shift and go to state 201

    expr_sequence                  shift and go to state 246

state 228

    (102) actual_param_list -> ( actual_param actual_param_cont ) .

    ;               reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    END             reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    ELSE            reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    *               reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    /               reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    DIV             reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    MOD             reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    AND             reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    +               reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    -               reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    OR              reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    =               reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    NE              reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    <               reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    >               reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    LE              reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    GE              reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    IN              reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    THEN            reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    DO              reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    ,               reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    ]               reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    :               reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    )               reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    TO              reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)
    DOWNTO          reduce using rule 102 (actual_param_list -> ( actual_param actual_param_cont ) .)


state 229

    (104) actual_param_cont -> , actual_param .

    )               reduce using rule 104 (actual_param_cont -> , actual_param .)


state 230

    (107) read_param_list -> ( var_access var_access_sequence ) .

    ;               reduce using rule 107 (read_param_list -> ( var_access var_access_sequence ) .)
    END             reduce using rule 107 (read_param_list -> ( var_access var_access_sequence ) .)
    ELSE            reduce using rule 107 (read_param_list -> ( var_access var_access_sequence ) .)


state 231

    (112) write_param_list -> ( var_access write_param_sequence ) .

    ;               reduce using rule 112 (write_param_list -> ( var_access write_param_sequence ) .)
    END             reduce using rule 112 (write_param_list -> ( var_access write_param_sequence ) .)
    ELSE            reduce using rule 112 (write_param_list -> ( var_access write_param_sequence ) .)


state 232

    (109) var_access_sequence -> , var_access . var_access_sequence
    (49) var_access -> var_access . [ expr expr_sequence ]
    (59) factor -> var_access .
    (108) var_access_sequence -> .
    (109) var_access_sequence -> . , var_access var_access_sequence

  ! reduce/reduce conflict for ) resolved using rule 59 (factor -> var_access .)
  ! shift/reduce conflict for , resolved as shift
    [               shift and go to state 108
    *               reduce using rule 59 (factor -> var_access .)
    /               reduce using rule 59 (factor -> var_access .)
    DIV             reduce using rule 59 (factor -> var_access .)
    MOD             reduce using rule 59 (factor -> var_access .)
    AND             reduce using rule 59 (factor -> var_access .)
    +               reduce using rule 59 (factor -> var_access .)
    -               reduce using rule 59 (factor -> var_access .)
    OR              reduce using rule 59 (factor -> var_access .)
    =               reduce using rule 59 (factor -> var_access .)
    NE              reduce using rule 59 (factor -> var_access .)
    <               reduce using rule 59 (factor -> var_access .)
    >               reduce using rule 59 (factor -> var_access .)
    LE              reduce using rule 59 (factor -> var_access .)
    GE              reduce using rule 59 (factor -> var_access .)
    IN              reduce using rule 59 (factor -> var_access .)
    :               reduce using rule 59 (factor -> var_access .)
    )               reduce using rule 59 (factor -> var_access .)
    ,               shift and go to state 247

  ! ,               [ reduce using rule 59 (factor -> var_access .) ]
  ! )               [ reduce using rule 108 (var_access_sequence -> .) ]

    var_access_sequence            shift and go to state 248

state 233

    (115) write_param_sequence -> , write_param . write_param_sequence
    (114) write_param_sequence -> .
    (115) write_param_sequence -> . , write_param write_param_sequence

    )               reduce using rule 114 (write_param_sequence -> .)
    ,               shift and go to state 208

    write_param_sequence           shift and go to state 249

state 234

    (116) write_param -> expr .
    (117) write_param -> expr . : expr
    (118) write_param -> expr . : expr : expr

    ,               reduce using rule 116 (write_param -> expr .)
    )               reduce using rule 116 (write_param -> expr .)
    :               shift and go to state 209


state 235

    (113) write_param_list -> ( write_param write_param_sequence ) .

    ;               reduce using rule 113 (write_param_list -> ( write_param write_param_sequence ) .)
    END             reduce using rule 113 (write_param_list -> ( write_param write_param_sequence ) .)
    ELSE            reduce using rule 113 (write_param_list -> ( write_param write_param_sequence ) .)


state 236

    (117) write_param -> expr : expr .
    (118) write_param -> expr : expr . : expr

    ,               reduce using rule 117 (write_param -> expr : expr .)
    )               reduce using rule 117 (write_param -> expr : expr .)
    :               shift and go to state 250


state 237

    (126) if_statement -> IF expr THEN statement ELSE . statement
    (87) statement -> . simple_statement
    (88) statement -> . structured_statement
    (89) statement -> . INT : structured_statement
    (90) statement -> . INT : simple_statement
    (91) simple_statement -> .
    (92) simple_statement -> . assignment_statement
    (93) simple_statement -> . proc_statement
    (121) structured_statement -> . compound_statement
    (122) structured_statement -> . if_statement
    (123) structured_statement -> . while_statement
    (124) structured_statement -> . for_statement
    (94) assignment_statement -> . var_access ASSIGN expr
    (95) proc_statement -> . ID proc_id_cont
    (84) compound_statement -> . BEGIN statement statement_sequence END
    (125) if_statement -> . IF expr THEN statement
    (126) if_statement -> . IF expr THEN statement ELSE statement
    (127) while_statement -> . WHILE expr DO statement
    (128) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (129) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    INT             shift and go to state 76
    ELSE            reduce using rule 91 (simple_statement -> .)
    ;               reduce using rule 91 (simple_statement -> .)
    END             reduce using rule 91 (simple_statement -> .)
    ID              shift and go to state 84
    BEGIN           shift and go to state 49
    IF              shift and go to state 85
    WHILE           shift and go to state 86
    FOR             shift and go to state 87

    statement                      shift and go to state 251
    simple_statement               shift and go to state 74
    structured_statement           shift and go to state 75
    assignment_statement           shift and go to state 77
    proc_statement                 shift and go to state 78
    compound_statement             shift and go to state 79
    if_statement                   shift and go to state 80
    while_statement                shift and go to state 81
    for_statement                  shift and go to state 82
    var_access                     shift and go to state 83

state 238

    (58) term_sequence -> add_op term term_sequence .

    =               reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    NE              reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    <               reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    >               reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    LE              reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    GE              reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    IN              reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    THEN            reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    DO              reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    ;               reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    END             reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    ELSE            reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    ,               reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    ]               reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    :               reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    )               reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    TO              reduce using rule 58 (term_sequence -> add_op term term_sequence .)
    DOWNTO          reduce using rule 58 (term_sequence -> add_op term term_sequence .)


state 239

    (68) factor_sequence -> mul_op factor factor_sequence .

    +               reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    -               reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    OR              reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    =               reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    NE              reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    <               reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    >               reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    LE              reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    GE              reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    IN              reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    THEN            reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    DO              reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    ;               reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    END             reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    ELSE            reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    ,               reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    ]               reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    :               reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    )               reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    TO              reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)
    DOWNTO          reduce using rule 68 (factor_sequence -> mul_op factor factor_sequence .)


state 240

    (128) for_statement -> FOR ID ASSIGN expr TO . expr DO statement
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    expr                           shift and go to state 252
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 241

    (129) for_statement -> FOR ID ASSIGN expr DOWNTO . expr DO statement
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    expr                           shift and go to state 253
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 242

    (140) fcont -> ; formal_param_section fcont .

    )               reduce using rule 140 (fcont -> ; formal_param_section fcont .)


state 243

    (142) formal_param_section -> VAR id_list : ID .

    ;               reduce using rule 142 (formal_param_section -> VAR id_list : ID .)
    )               reduce using rule 142 (formal_param_section -> VAR id_list : ID .)


state 244

    (41) array_type -> ARRAY [ ordinal_type acont ] OF . tipo
    (32) tipo -> . ID
    (33) tipo -> . new_type
    (34) new_type -> . enumerated_type
    (35) new_type -> . subrange_type
    (36) new_type -> . array_type
    (37) enumerated_type -> . ( id_list )
    (40) subrange_type -> . constant DOTDOT constant
    (41) array_type -> . ARRAY [ ordinal_type acont ] OF tipo
    (23) constant -> . sign INT
    (24) constant -> . INT
    (25) constant -> . sign REAL
    (26) constant -> . REAL
    (27) constant -> . ID
    (28) constant -> . sign ID
    (29) constant -> . CHAR
    (30) constant -> . STRING
    (21) sign -> . +
    (22) sign -> . -

    ID              shift and go to state 60
    (               shift and go to state 66
    ARRAY           shift and go to state 68
    INT             shift and go to state 41
    REAL            shift and go to state 42
    CHAR            shift and go to state 43
    STRING          shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

    tipo                           shift and go to state 254
    new_type                       shift and go to state 62
    enumerated_type                shift and go to state 63
    subrange_type                  shift and go to state 64
    array_type                     shift and go to state 65
    constant                       shift and go to state 67
    sign                           shift and go to state 40

state 245

    (43) acont -> , ordinal_type acont .

    ]               reduce using rule 43 (acont -> , ordinal_type acont .)


state 246

    (51) expr_sequence -> , expr expr_sequence .

    ]               reduce using rule 51 (expr_sequence -> , expr expr_sequence .)


state 247

    (109) var_access_sequence -> , . var_access var_access_sequence
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    ID              shift and go to state 256

    var_access                     shift and go to state 255

state 248

    (109) var_access_sequence -> , var_access var_access_sequence .

    )               reduce using rule 109 (var_access_sequence -> , var_access var_access_sequence .)


state 249

    (115) write_param_sequence -> , write_param write_param_sequence .

    )               reduce using rule 115 (write_param_sequence -> , write_param write_param_sequence .)


state 250

    (118) write_param -> expr : expr : . expr
    (52) expr -> . simple_expr
    (53) expr -> . simple_expr relation_op simple_expr
    (54) simple_expr -> . term term_sequence
    (55) simple_expr -> . sign term term_sequence
    (56) term -> . factor factor_sequence
    (21) sign -> . +
    (22) sign -> . -
    (59) factor -> . var_access
    (60) factor -> . INT
    (61) factor -> . REAL
    (62) factor -> . CHAR
    (63) factor -> . STRING
    (64) factor -> . ID actual_param_list
    (65) factor -> . ( expr )
    (66) factor -> . NOT factor
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    +               shift and go to state 45
    -               shift and go to state 46
    INT             shift and go to state 122
    REAL            shift and go to state 123
    CHAR            shift and go to state 124
    STRING          shift and go to state 125
    ID              shift and go to state 126
    (               shift and go to state 127
    NOT             shift and go to state 128

    expr                           shift and go to state 257
    simple_expr                    shift and go to state 117
    term                           shift and go to state 118
    sign                           shift and go to state 119
    factor                         shift and go to state 120
    var_access                     shift and go to state 121

state 251

    (126) if_statement -> IF expr THEN statement ELSE statement .

    ;               reduce using rule 126 (if_statement -> IF expr THEN statement ELSE statement .)
    END             reduce using rule 126 (if_statement -> IF expr THEN statement ELSE statement .)
    ELSE            reduce using rule 126 (if_statement -> IF expr THEN statement ELSE statement .)


state 252

    (128) for_statement -> FOR ID ASSIGN expr TO expr . DO statement

    DO              shift and go to state 258


state 253

    (129) for_statement -> FOR ID ASSIGN expr DOWNTO expr . DO statement

    DO              shift and go to state 259


state 254

    (41) array_type -> ARRAY [ ordinal_type acont ] OF tipo .

    ;               reduce using rule 41 (array_type -> ARRAY [ ordinal_type acont ] OF tipo .)


state 255

    (109) var_access_sequence -> , var_access . var_access_sequence
    (49) var_access -> var_access . [ expr expr_sequence ]
    (108) var_access_sequence -> .
    (109) var_access_sequence -> . , var_access var_access_sequence

    [               shift and go to state 108
    )               reduce using rule 108 (var_access_sequence -> .)
    ,               shift and go to state 247

    var_access_sequence            shift and go to state 248

state 256

    (48) var_access -> ID .

    [               reduce using rule 48 (var_access -> ID .)
    ,               reduce using rule 48 (var_access -> ID .)
    )               reduce using rule 48 (var_access -> ID .)


state 257

    (118) write_param -> expr : expr : expr .

    ,               reduce using rule 118 (write_param -> expr : expr : expr .)
    )               reduce using rule 118 (write_param -> expr : expr : expr .)


state 258

    (128) for_statement -> FOR ID ASSIGN expr TO expr DO . statement
    (87) statement -> . simple_statement
    (88) statement -> . structured_statement
    (89) statement -> . INT : structured_statement
    (90) statement -> . INT : simple_statement
    (91) simple_statement -> .
    (92) simple_statement -> . assignment_statement
    (93) simple_statement -> . proc_statement
    (121) structured_statement -> . compound_statement
    (122) structured_statement -> . if_statement
    (123) structured_statement -> . while_statement
    (124) structured_statement -> . for_statement
    (94) assignment_statement -> . var_access ASSIGN expr
    (95) proc_statement -> . ID proc_id_cont
    (84) compound_statement -> . BEGIN statement statement_sequence END
    (125) if_statement -> . IF expr THEN statement
    (126) if_statement -> . IF expr THEN statement ELSE statement
    (127) while_statement -> . WHILE expr DO statement
    (128) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (129) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    INT             shift and go to state 76
    ELSE            reduce using rule 91 (simple_statement -> .)
    ;               reduce using rule 91 (simple_statement -> .)
    END             reduce using rule 91 (simple_statement -> .)
    ID              shift and go to state 84
    BEGIN           shift and go to state 49
    IF              shift and go to state 85
    WHILE           shift and go to state 86
    FOR             shift and go to state 87

    statement                      shift and go to state 260
    simple_statement               shift and go to state 74
    structured_statement           shift and go to state 75
    assignment_statement           shift and go to state 77
    proc_statement                 shift and go to state 78
    compound_statement             shift and go to state 79
    if_statement                   shift and go to state 80
    while_statement                shift and go to state 81
    for_statement                  shift and go to state 82
    var_access                     shift and go to state 83

state 259

    (129) for_statement -> FOR ID ASSIGN expr DOWNTO expr DO . statement
    (87) statement -> . simple_statement
    (88) statement -> . structured_statement
    (89) statement -> . INT : structured_statement
    (90) statement -> . INT : simple_statement
    (91) simple_statement -> .
    (92) simple_statement -> . assignment_statement
    (93) simple_statement -> . proc_statement
    (121) structured_statement -> . compound_statement
    (122) structured_statement -> . if_statement
    (123) structured_statement -> . while_statement
    (124) structured_statement -> . for_statement
    (94) assignment_statement -> . var_access ASSIGN expr
    (95) proc_statement -> . ID proc_id_cont
    (84) compound_statement -> . BEGIN statement statement_sequence END
    (125) if_statement -> . IF expr THEN statement
    (126) if_statement -> . IF expr THEN statement ELSE statement
    (127) while_statement -> . WHILE expr DO statement
    (128) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (129) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (48) var_access -> . ID
    (49) var_access -> . var_access [ expr expr_sequence ]

    INT             shift and go to state 76
    ELSE            reduce using rule 91 (simple_statement -> .)
    ;               reduce using rule 91 (simple_statement -> .)
    END             reduce using rule 91 (simple_statement -> .)
    ID              shift and go to state 84
    BEGIN           shift and go to state 49
    IF              shift and go to state 85
    WHILE           shift and go to state 86
    FOR             shift and go to state 87

    statement                      shift and go to state 261
    simple_statement               shift and go to state 74
    structured_statement           shift and go to state 75
    assignment_statement           shift and go to state 77
    proc_statement                 shift and go to state 78
    compound_statement             shift and go to state 79
    if_statement                   shift and go to state 80
    while_statement                shift and go to state 81
    for_statement                  shift and go to state 82
    var_access                     shift and go to state 83

state 260

    (128) for_statement -> FOR ID ASSIGN expr TO expr DO statement .

    ;               reduce using rule 128 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)
    END             reduce using rule 128 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)
    ELSE            reduce using rule 128 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)


state 261

    (129) for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .

    ;               reduce using rule 129 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)
    END             reduce using rule 129 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)
    ELSE            reduce using rule 129 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ; in state 53 resolved as shift
WARNING: shift/reduce conflict for , in state 157 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 210 resolved as shift
WARNING: shift/reduce conflict for , in state 232 resolved as shift
WARNING: reduce/reduce conflict in state 84 resolved using rule (proc_id_cont -> <empty>)
WARNING: rejected rule (readln_param_list -> <empty>) in state 84
WARNING: reduce/reduce conflict in state 84 resolved using rule (proc_id_cont -> <empty>)
WARNING: rejected rule (writeln_param_list -> <empty>) in state 84
WARNING: reduce/reduce conflict in state 111 resolved using rule (proc_id_cont -> read_param_list)
WARNING: rejected rule (readln_param_list -> read_param_list) in state 111
WARNING: reduce/reduce conflict in state 113 resolved using rule (proc_id_cont -> write_param_list)
WARNING: rejected rule (writeln_param_list -> write_param_list) in state 113
WARNING: reduce/reduce conflict in state 157 resolved using rule (factor -> var_access)
WARNING: rejected rule (actual_param -> var_access) in state 157
WARNING: reduce/reduce conflict in state 157 resolved using rule (factor -> var_access)
WARNING: rejected rule (var_access_sequence -> <empty>) in state 157
WARNING: reduce/reduce conflict in state 157 resolved using rule (factor -> var_access)
WARNING: rejected rule (write_param_sequence -> <empty>) in state 157
WARNING: reduce/reduce conflict in state 159 resolved using rule (actual_param -> expr)
WARNING: rejected rule (write_param -> expr) in state 159
WARNING: reduce/reduce conflict in state 216 resolved using rule (factor -> var_access)
WARNING: rejected rule (actual_param -> var_access) in state 216
WARNING: reduce/reduce conflict in state 232 resolved using rule (factor -> var_access)
WARNING: rejected rule (var_access_sequence -> <empty>) in state 232
WARNING: Rule (readln_param_list -> <empty>) is never reduced
WARNING: Rule (writeln_param_list -> <empty>) is never reduced
WARNING: Rule (readln_param_list -> read_param_list) is never reduced
WARNING: Rule (writeln_param_list -> write_param_list) is never reduced
WARNING: Rule (actual_param -> var_access) is never reduced
