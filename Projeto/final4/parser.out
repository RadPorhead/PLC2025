Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program_heading ; block .
Rule 2     program_heading -> PROGRAM ID ( id_list )
Rule 3     program_heading -> PROGRAM ID
Rule 4     block -> const_part procfunc_part var_part compound_statement
Rule 5     const_part -> <empty>
Rule 6     const_part -> CONST const_list
Rule 7     const_list -> const_def ;
Rule 8     const_list -> const_list const_def ;
Rule 9     const_def -> ID = constant
Rule 10    constant -> sign INT
Rule 11    constant -> INT
Rule 12    constant -> sign REAL
Rule 13    constant -> REAL
Rule 14    constant -> CHAR
Rule 15    constant -> STRING
Rule 16    constant -> ID
Rule 17    sign -> +
Rule 18    sign -> -
Rule 19    var_part -> <empty>
Rule 20    var_part -> VAR var_list
Rule 21    var_list -> var_dec ;
Rule 22    var_list -> var_list var_dec ;
Rule 23    var_dec -> id_list : tipo
Rule 24    id_list -> ID
Rule 25    id_list -> ID , id_list
Rule 26    tipo -> ID
Rule 27    tipo -> new_type
Rule 28    new_type -> enumerated_type
Rule 29    new_type -> subrange_type
Rule 30    new_type -> array_type
Rule 31    enumerated_type -> ( id_list )
Rule 32    subrange_type -> constant DOTDOT constant
Rule 33    array_type -> ARRAY [ ordinal_type_list ] OF tipo
Rule 34    ordinal_type -> enumerated_type
Rule 35    ordinal_type -> subrange_type
Rule 36    ordinal_type -> ID
Rule 37    ordinal_type_list -> ordinal_type
Rule 38    ordinal_type_list -> ordinal_type_list , ordinal_type
Rule 39    procfunc_part -> <empty>
Rule 40    procfunc_part -> procfunc_part proc_dec
Rule 41    procfunc_part -> procfunc_part func_dec
Rule 42    proc_dec -> proc_heading ; block ;
Rule 43    func_dec -> func_heading ; block ;
Rule 44    proc_heading -> PROCEDURE ID
Rule 45    proc_heading -> PROCEDURE ID ( param_list )
Rule 46    func_heading -> FUNCTION ID : ID
Rule 47    func_heading -> FUNCTION ID ( param_list ) : ID
Rule 48    param_list -> param
Rule 49    param_list -> param_list ; param
Rule 50    param -> id_list : ID
Rule 51    param -> VAR id_list : ID
Rule 52    var_access -> ID var_suffix
Rule 53    var_suffix -> <empty>
Rule 54    var_suffix -> [ expr_list ] var_suffix
Rule 55    expr_list -> expr
Rule 56    expr_list -> expr_list , expr
Rule 57    expr -> simple_expr
Rule 58    expr -> simple_expr relation_op simple_expr
Rule 59    simple_expr -> term term_sequence
Rule 60    simple_expr -> sign term term_sequence
Rule 61    term -> factor factor_sequence
Rule 62    term_sequence -> <empty>
Rule 63    term_sequence -> add_op term term_sequence
Rule 64    factor_sequence -> <empty>
Rule 65    factor_sequence -> mul_op factor factor_sequence
Rule 66    factor -> var_access
Rule 67    factor -> INT
Rule 68    factor -> REAL
Rule 69    factor -> CHAR
Rule 70    factor -> STRING
Rule 71    factor -> ID ( expr_list )
Rule 72    factor -> ( expr )
Rule 73    factor -> NOT factor
Rule 74    factor -> TRUE
Rule 75    factor -> FALSE
Rule 76    add_op -> +
Rule 77    add_op -> -
Rule 78    add_op -> OR
Rule 79    mul_op -> *
Rule 80    mul_op -> /
Rule 81    mul_op -> DIV
Rule 82    mul_op -> MOD
Rule 83    mul_op -> AND
Rule 84    relation_op -> =
Rule 85    relation_op -> NE
Rule 86    relation_op -> LT
Rule 87    relation_op -> GT
Rule 88    relation_op -> LE
Rule 89    relation_op -> GE
Rule 90    compound_statement -> BEGIN statement_list END
Rule 91    statement_list -> statement
Rule 92    statement_list -> statement_list ; statement
Rule 93    statement -> <empty>
Rule 94    statement -> assignment_statement
Rule 95    statement -> proc_statement
Rule 96    statement -> read_statement
Rule 97    statement -> write_statement
Rule 98    statement -> labeled_statement
Rule 99    statement -> compound_statement
Rule 100   statement -> if_statement
Rule 101   statement -> while_statement
Rule 102   statement -> for_statement
Rule 103   assignment_statement -> var_access ASSIGN expr
Rule 104   proc_statement -> ID
Rule 105   proc_statement -> ID ( expr_list )
Rule 106   labeled_statement -> INT : statement
Rule 107   read_statement -> READ ( var_access_list )
Rule 108   read_statement -> READLN
Rule 109   read_statement -> READLN ( var_access_list )
Rule 110   var_access_list -> var_access
Rule 111   var_access_list -> var_access_list , var_access
Rule 112   write_statement -> WRITE ( write_list )
Rule 113   write_statement -> WRITELN
Rule 114   write_statement -> WRITELN ( write_list )
Rule 115   write_list -> write_param
Rule 116   write_list -> write_list , write_param
Rule 117   write_param -> expr
Rule 118   write_param -> expr : expr
Rule 119   write_param -> expr : expr : expr
Rule 120   if_statement -> IF expr THEN statement
Rule 121   if_statement -> IF expr THEN statement ELSE statement
Rule 122   while_statement -> WHILE expr DO statement
Rule 123   for_statement -> FOR ID ASSIGN expr TO expr DO statement
Rule 124   for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement

Terminals, with rules where they appear

(                    : 2 31 45 47 71 72 105 107 109 112 114
)                    : 2 31 45 47 71 72 105 107 109 112 114
*                    : 79
+                    : 17 76
,                    : 25 38 56 111 116
-                    : 18 77
.                    : 1
/                    : 80
:                    : 23 46 47 50 51 106 118 119 119
;                    : 1 7 8 21 22 42 42 43 43 49 92
=                    : 9 84
AND                  : 83
ARRAY                : 33
ASSIGN               : 103 123 124
BEGIN                : 90
CHAR                 : 14 69
CONST                : 6
DIV                  : 81
DO                   : 122 123 124
DOTDOT               : 32
DOWNTO               : 124
ELSE                 : 121
END                  : 90
FALSE                : 75
FOR                  : 123 124
FUNCTION             : 46 47
GE                   : 89
GT                   : 87
ID                   : 2 3 9 16 24 25 26 36 44 45 46 46 47 47 50 51 52 71 104 105 123 124
IF                   : 120 121
INT                  : 10 11 67 106
LE                   : 88
LT                   : 86
MOD                  : 82
NE                   : 85
NOT                  : 73
OF                   : 33
OR                   : 78
PROCEDURE            : 44 45
PROGRAM              : 2 3
READ                 : 107
READLN               : 108 109
REAL                 : 12 13 68
STRING               : 15 70
THEN                 : 120 121
TO                   : 123
TRUE                 : 74
VAR                  : 20 51
WHILE                : 122
WRITE                : 112
WRITELN              : 113 114
[                    : 33 54
]                    : 33 54
error                : 

Nonterminals, with rules where they appear

add_op               : 63
array_type           : 30
assignment_statement : 94
block                : 1 42 43
compound_statement   : 4 99
const_def            : 7 8
const_list           : 6 8
const_part           : 4
constant             : 9 32 32
enumerated_type      : 28 34
expr                 : 55 56 72 103 117 118 118 119 119 119 120 121 122 123 123 124 124
expr_list            : 54 56 71 105
factor               : 61 65 73
factor_sequence      : 61 65
for_statement        : 102
func_dec             : 41
func_heading         : 43
id_list              : 2 23 25 31 50 51
if_statement         : 100
labeled_statement    : 98
mul_op               : 65
new_type             : 27
ordinal_type         : 37 38
ordinal_type_list    : 33 38
param                : 48 49
param_list           : 45 47 49
proc_dec             : 40
proc_heading         : 42
proc_statement       : 95
procfunc_part        : 4 40 41
program              : 0
program_heading      : 1
read_statement       : 96
relation_op          : 58
sign                 : 10 12 60
simple_expr          : 57 58 58
statement            : 91 92 106 120 121 121 122 123 124
statement_list       : 90 92
subrange_type        : 29 35
term                 : 59 60 63
term_sequence        : 59 60 63
tipo                 : 23 33
var_access           : 66 103 110 111
var_access_list      : 107 109 111
var_dec              : 21 22
var_list             : 20 22
var_part             : 4
var_suffix           : 52 54
while_statement      : 101
write_list           : 112 114 116
write_param          : 115 116
write_statement      : 97

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program_heading ; block .
    (2) program_heading -> . PROGRAM ID ( id_list )
    (3) program_heading -> . PROGRAM ID

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    program_heading                shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> program_heading . ; block .

    ;               shift and go to state 4


state 3

    (2) program_heading -> PROGRAM . ID ( id_list )
    (3) program_heading -> PROGRAM . ID

    ID              shift and go to state 5


state 4

    (1) program -> program_heading ; . block .
    (4) block -> . const_part procfunc_part var_part compound_statement
    (5) const_part -> .
    (6) const_part -> . CONST const_list

    VAR             reduce using rule 5 (const_part -> .)
    PROCEDURE       reduce using rule 5 (const_part -> .)
    FUNCTION        reduce using rule 5 (const_part -> .)
    BEGIN           reduce using rule 5 (const_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 6
    const_part                     shift and go to state 7

state 5

    (2) program_heading -> PROGRAM ID . ( id_list )
    (3) program_heading -> PROGRAM ID .

    (               shift and go to state 9
    ;               reduce using rule 3 (program_heading -> PROGRAM ID .)


state 6

    (1) program -> program_heading ; block . .

    .               shift and go to state 10


state 7

    (4) block -> const_part . procfunc_part var_part compound_statement
    (39) procfunc_part -> .
    (40) procfunc_part -> . procfunc_part proc_dec
    (41) procfunc_part -> . procfunc_part func_dec

    VAR             reduce using rule 39 (procfunc_part -> .)
    PROCEDURE       reduce using rule 39 (procfunc_part -> .)
    FUNCTION        reduce using rule 39 (procfunc_part -> .)
    BEGIN           reduce using rule 39 (procfunc_part -> .)

    procfunc_part                  shift and go to state 11

state 8

    (6) const_part -> CONST . const_list
    (7) const_list -> . const_def ;
    (8) const_list -> . const_list const_def ;
    (9) const_def -> . ID = constant

    ID              shift and go to state 14

    const_list                     shift and go to state 12
    const_def                      shift and go to state 13

state 9

    (2) program_heading -> PROGRAM ID ( . id_list )
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 16

state 10

    (1) program -> program_heading ; block . .

    $end            reduce using rule 1 (program -> program_heading ; block . .)


state 11

    (4) block -> const_part procfunc_part . var_part compound_statement
    (40) procfunc_part -> procfunc_part . proc_dec
    (41) procfunc_part -> procfunc_part . func_dec
    (19) var_part -> .
    (20) var_part -> . VAR var_list
    (42) proc_dec -> . proc_heading ; block ;
    (43) func_dec -> . func_heading ; block ;
    (44) proc_heading -> . PROCEDURE ID
    (45) proc_heading -> . PROCEDURE ID ( param_list )
    (46) func_heading -> . FUNCTION ID : ID
    (47) func_heading -> . FUNCTION ID ( param_list ) : ID

    BEGIN           reduce using rule 19 (var_part -> .)
    VAR             shift and go to state 20
    PROCEDURE       shift and go to state 23
    FUNCTION        shift and go to state 24

    var_part                       shift and go to state 17
    proc_dec                       shift and go to state 18
    func_dec                       shift and go to state 19
    proc_heading                   shift and go to state 21
    func_heading                   shift and go to state 22

state 12

    (6) const_part -> CONST const_list .
    (8) const_list -> const_list . const_def ;
    (9) const_def -> . ID = constant

    VAR             reduce using rule 6 (const_part -> CONST const_list .)
    PROCEDURE       reduce using rule 6 (const_part -> CONST const_list .)
    FUNCTION        reduce using rule 6 (const_part -> CONST const_list .)
    BEGIN           reduce using rule 6 (const_part -> CONST const_list .)
    ID              shift and go to state 14

    const_def                      shift and go to state 25

state 13

    (7) const_list -> const_def . ;

    ;               shift and go to state 26


state 14

    (9) const_def -> ID . = constant

    =               shift and go to state 27


state 15

    (24) id_list -> ID .
    (25) id_list -> ID . , id_list

    )               reduce using rule 24 (id_list -> ID .)
    :               reduce using rule 24 (id_list -> ID .)
    ,               shift and go to state 28


state 16

    (2) program_heading -> PROGRAM ID ( id_list . )

    )               shift and go to state 29


state 17

    (4) block -> const_part procfunc_part var_part . compound_statement
    (90) compound_statement -> . BEGIN statement_list END

    BEGIN           shift and go to state 31

    compound_statement             shift and go to state 30

state 18

    (40) procfunc_part -> procfunc_part proc_dec .

    VAR             reduce using rule 40 (procfunc_part -> procfunc_part proc_dec .)
    PROCEDURE       reduce using rule 40 (procfunc_part -> procfunc_part proc_dec .)
    FUNCTION        reduce using rule 40 (procfunc_part -> procfunc_part proc_dec .)
    BEGIN           reduce using rule 40 (procfunc_part -> procfunc_part proc_dec .)


state 19

    (41) procfunc_part -> procfunc_part func_dec .

    VAR             reduce using rule 41 (procfunc_part -> procfunc_part func_dec .)
    PROCEDURE       reduce using rule 41 (procfunc_part -> procfunc_part func_dec .)
    FUNCTION        reduce using rule 41 (procfunc_part -> procfunc_part func_dec .)
    BEGIN           reduce using rule 41 (procfunc_part -> procfunc_part func_dec .)


state 20

    (20) var_part -> VAR . var_list
    (21) var_list -> . var_dec ;
    (22) var_list -> . var_list var_dec ;
    (23) var_dec -> . id_list : tipo
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    var_list                       shift and go to state 32
    var_dec                        shift and go to state 33
    id_list                        shift and go to state 34

state 21

    (42) proc_dec -> proc_heading . ; block ;

    ;               shift and go to state 35


state 22

    (43) func_dec -> func_heading . ; block ;

    ;               shift and go to state 36


state 23

    (44) proc_heading -> PROCEDURE . ID
    (45) proc_heading -> PROCEDURE . ID ( param_list )

    ID              shift and go to state 37


state 24

    (46) func_heading -> FUNCTION . ID : ID
    (47) func_heading -> FUNCTION . ID ( param_list ) : ID

    ID              shift and go to state 38


state 25

    (8) const_list -> const_list const_def . ;

    ;               shift and go to state 39


state 26

    (7) const_list -> const_def ; .

    ID              reduce using rule 7 (const_list -> const_def ; .)
    VAR             reduce using rule 7 (const_list -> const_def ; .)
    PROCEDURE       reduce using rule 7 (const_list -> const_def ; .)
    FUNCTION        reduce using rule 7 (const_list -> const_def ; .)
    BEGIN           reduce using rule 7 (const_list -> const_def ; .)


state 27

    (9) const_def -> ID = . constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    ID              shift and go to state 40
    +               shift and go to state 47
    -               shift and go to state 48

    constant                       shift and go to state 41
    sign                           shift and go to state 42

state 28

    (25) id_list -> ID , . id_list
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 49

state 29

    (2) program_heading -> PROGRAM ID ( id_list ) .

    ;               reduce using rule 2 (program_heading -> PROGRAM ID ( id_list ) .)


state 30

    (4) block -> const_part procfunc_part var_part compound_statement .

    .               reduce using rule 4 (block -> const_part procfunc_part var_part compound_statement .)
    ;               reduce using rule 4 (block -> const_part procfunc_part var_part compound_statement .)


state 31

    (90) compound_statement -> BEGIN . statement_list END
    (91) statement_list -> . statement
    (92) statement_list -> . statement_list ; statement
    (93) statement -> .
    (94) statement -> . assignment_statement
    (95) statement -> . proc_statement
    (96) statement -> . read_statement
    (97) statement -> . write_statement
    (98) statement -> . labeled_statement
    (99) statement -> . compound_statement
    (100) statement -> . if_statement
    (101) statement -> . while_statement
    (102) statement -> . for_statement
    (103) assignment_statement -> . var_access ASSIGN expr
    (104) proc_statement -> . ID
    (105) proc_statement -> . ID ( expr_list )
    (107) read_statement -> . READ ( var_access_list )
    (108) read_statement -> . READLN
    (109) read_statement -> . READLN ( var_access_list )
    (112) write_statement -> . WRITE ( write_list )
    (113) write_statement -> . WRITELN
    (114) write_statement -> . WRITELN ( write_list )
    (106) labeled_statement -> . INT : statement
    (90) compound_statement -> . BEGIN statement_list END
    (120) if_statement -> . IF expr THEN statement
    (121) if_statement -> . IF expr THEN statement ELSE statement
    (122) while_statement -> . WHILE expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (124) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 93 (statement -> .)
    ;               reduce using rule 93 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement_list                 shift and go to state 50
    statement                      shift and go to state 51
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 32

    (20) var_part -> VAR var_list .
    (22) var_list -> var_list . var_dec ;
    (23) var_dec -> . id_list : tipo
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    BEGIN           reduce using rule 20 (var_part -> VAR var_list .)
    ID              shift and go to state 15

    var_dec                        shift and go to state 71
    id_list                        shift and go to state 34

state 33

    (21) var_list -> var_dec . ;

    ;               shift and go to state 72


state 34

    (23) var_dec -> id_list . : tipo

    :               shift and go to state 73


state 35

    (42) proc_dec -> proc_heading ; . block ;
    (4) block -> . const_part procfunc_part var_part compound_statement
    (5) const_part -> .
    (6) const_part -> . CONST const_list

    VAR             reduce using rule 5 (const_part -> .)
    PROCEDURE       reduce using rule 5 (const_part -> .)
    FUNCTION        reduce using rule 5 (const_part -> .)
    BEGIN           reduce using rule 5 (const_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 74
    const_part                     shift and go to state 7

state 36

    (43) func_dec -> func_heading ; . block ;
    (4) block -> . const_part procfunc_part var_part compound_statement
    (5) const_part -> .
    (6) const_part -> . CONST const_list

    VAR             reduce using rule 5 (const_part -> .)
    PROCEDURE       reduce using rule 5 (const_part -> .)
    FUNCTION        reduce using rule 5 (const_part -> .)
    BEGIN           reduce using rule 5 (const_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 75
    const_part                     shift and go to state 7

state 37

    (44) proc_heading -> PROCEDURE ID .
    (45) proc_heading -> PROCEDURE ID . ( param_list )

    ;               reduce using rule 44 (proc_heading -> PROCEDURE ID .)
    (               shift and go to state 76


state 38

    (46) func_heading -> FUNCTION ID . : ID
    (47) func_heading -> FUNCTION ID . ( param_list ) : ID

    :               shift and go to state 77
    (               shift and go to state 78


state 39

    (8) const_list -> const_list const_def ; .

    ID              reduce using rule 8 (const_list -> const_list const_def ; .)
    VAR             reduce using rule 8 (const_list -> const_list const_def ; .)
    PROCEDURE       reduce using rule 8 (const_list -> const_list const_def ; .)
    FUNCTION        reduce using rule 8 (const_list -> const_list const_def ; .)
    BEGIN           reduce using rule 8 (const_list -> const_list const_def ; .)


state 40

    (16) constant -> ID .

    ;               reduce using rule 16 (constant -> ID .)
    ]               reduce using rule 16 (constant -> ID .)
    ,               reduce using rule 16 (constant -> ID .)


state 41

    (9) const_def -> ID = constant .

    ;               reduce using rule 9 (const_def -> ID = constant .)


state 42

    (10) constant -> sign . INT
    (12) constant -> sign . REAL

    INT             shift and go to state 79
    REAL            shift and go to state 80


state 43

    (11) constant -> INT .

    ;               reduce using rule 11 (constant -> INT .)
    DOTDOT          reduce using rule 11 (constant -> INT .)
    ]               reduce using rule 11 (constant -> INT .)
    ,               reduce using rule 11 (constant -> INT .)


state 44

    (13) constant -> REAL .

    ;               reduce using rule 13 (constant -> REAL .)
    DOTDOT          reduce using rule 13 (constant -> REAL .)
    ]               reduce using rule 13 (constant -> REAL .)
    ,               reduce using rule 13 (constant -> REAL .)


state 45

    (14) constant -> CHAR .

    ;               reduce using rule 14 (constant -> CHAR .)
    DOTDOT          reduce using rule 14 (constant -> CHAR .)
    ]               reduce using rule 14 (constant -> CHAR .)
    ,               reduce using rule 14 (constant -> CHAR .)


state 46

    (15) constant -> STRING .

    ;               reduce using rule 15 (constant -> STRING .)
    DOTDOT          reduce using rule 15 (constant -> STRING .)
    ]               reduce using rule 15 (constant -> STRING .)
    ,               reduce using rule 15 (constant -> STRING .)


state 47

    (17) sign -> + .

    INT             reduce using rule 17 (sign -> + .)
    REAL            reduce using rule 17 (sign -> + .)
    CHAR            reduce using rule 17 (sign -> + .)
    STRING          reduce using rule 17 (sign -> + .)
    ID              reduce using rule 17 (sign -> + .)
    (               reduce using rule 17 (sign -> + .)
    NOT             reduce using rule 17 (sign -> + .)
    TRUE            reduce using rule 17 (sign -> + .)
    FALSE           reduce using rule 17 (sign -> + .)


state 48

    (18) sign -> - .

    INT             reduce using rule 18 (sign -> - .)
    REAL            reduce using rule 18 (sign -> - .)
    CHAR            reduce using rule 18 (sign -> - .)
    STRING          reduce using rule 18 (sign -> - .)
    ID              reduce using rule 18 (sign -> - .)
    (               reduce using rule 18 (sign -> - .)
    NOT             reduce using rule 18 (sign -> - .)
    TRUE            reduce using rule 18 (sign -> - .)
    FALSE           reduce using rule 18 (sign -> - .)


state 49

    (25) id_list -> ID , id_list .

    )               reduce using rule 25 (id_list -> ID , id_list .)
    :               reduce using rule 25 (id_list -> ID , id_list .)


state 50

    (90) compound_statement -> BEGIN statement_list . END
    (92) statement_list -> statement_list . ; statement

    END             shift and go to state 81
    ;               shift and go to state 82


state 51

    (91) statement_list -> statement .

    END             reduce using rule 91 (statement_list -> statement .)
    ;               reduce using rule 91 (statement_list -> statement .)


state 52

    (94) statement -> assignment_statement .

    END             reduce using rule 94 (statement -> assignment_statement .)
    ;               reduce using rule 94 (statement -> assignment_statement .)
    ELSE            reduce using rule 94 (statement -> assignment_statement .)


state 53

    (95) statement -> proc_statement .

    END             reduce using rule 95 (statement -> proc_statement .)
    ;               reduce using rule 95 (statement -> proc_statement .)
    ELSE            reduce using rule 95 (statement -> proc_statement .)


state 54

    (96) statement -> read_statement .

    END             reduce using rule 96 (statement -> read_statement .)
    ;               reduce using rule 96 (statement -> read_statement .)
    ELSE            reduce using rule 96 (statement -> read_statement .)


state 55

    (97) statement -> write_statement .

    END             reduce using rule 97 (statement -> write_statement .)
    ;               reduce using rule 97 (statement -> write_statement .)
    ELSE            reduce using rule 97 (statement -> write_statement .)


state 56

    (98) statement -> labeled_statement .

    END             reduce using rule 98 (statement -> labeled_statement .)
    ;               reduce using rule 98 (statement -> labeled_statement .)
    ELSE            reduce using rule 98 (statement -> labeled_statement .)


state 57

    (99) statement -> compound_statement .

    END             reduce using rule 99 (statement -> compound_statement .)
    ;               reduce using rule 99 (statement -> compound_statement .)
    ELSE            reduce using rule 99 (statement -> compound_statement .)


state 58

    (100) statement -> if_statement .

    END             reduce using rule 100 (statement -> if_statement .)
    ;               reduce using rule 100 (statement -> if_statement .)
    ELSE            reduce using rule 100 (statement -> if_statement .)


state 59

    (101) statement -> while_statement .

    END             reduce using rule 101 (statement -> while_statement .)
    ;               reduce using rule 101 (statement -> while_statement .)
    ELSE            reduce using rule 101 (statement -> while_statement .)


state 60

    (102) statement -> for_statement .

    END             reduce using rule 102 (statement -> for_statement .)
    ;               reduce using rule 102 (statement -> for_statement .)
    ELSE            reduce using rule 102 (statement -> for_statement .)


state 61

    (103) assignment_statement -> var_access . ASSIGN expr

    ASSIGN          shift and go to state 83


state 62

    (104) proc_statement -> ID .
    (105) proc_statement -> ID . ( expr_list )
    (52) var_access -> ID . var_suffix
    (53) var_suffix -> .
    (54) var_suffix -> . [ expr_list ] var_suffix

    END             reduce using rule 104 (proc_statement -> ID .)
    ;               reduce using rule 104 (proc_statement -> ID .)
    ELSE            reduce using rule 104 (proc_statement -> ID .)
    (               shift and go to state 84
    ASSIGN          reduce using rule 53 (var_suffix -> .)
    [               shift and go to state 86

    var_suffix                     shift and go to state 85

state 63

    (107) read_statement -> READ . ( var_access_list )

    (               shift and go to state 87


state 64

    (108) read_statement -> READLN .
    (109) read_statement -> READLN . ( var_access_list )

    END             reduce using rule 108 (read_statement -> READLN .)
    ;               reduce using rule 108 (read_statement -> READLN .)
    ELSE            reduce using rule 108 (read_statement -> READLN .)
    (               shift and go to state 88


state 65

    (112) write_statement -> WRITE . ( write_list )

    (               shift and go to state 89


state 66

    (113) write_statement -> WRITELN .
    (114) write_statement -> WRITELN . ( write_list )

    END             reduce using rule 113 (write_statement -> WRITELN .)
    ;               reduce using rule 113 (write_statement -> WRITELN .)
    ELSE            reduce using rule 113 (write_statement -> WRITELN .)
    (               shift and go to state 90


state 67

    (106) labeled_statement -> INT . : statement

    :               shift and go to state 91


state 68

    (120) if_statement -> IF . expr THEN statement
    (121) if_statement -> IF . expr THEN statement ELSE statement
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    expr                           shift and go to state 92
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 69

    (122) while_statement -> WHILE . expr DO statement
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    expr                           shift and go to state 107
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 70

    (123) for_statement -> FOR . ID ASSIGN expr TO expr DO statement
    (124) for_statement -> FOR . ID ASSIGN expr DOWNTO expr DO statement

    ID              shift and go to state 108


state 71

    (22) var_list -> var_list var_dec . ;

    ;               shift and go to state 109


state 72

    (21) var_list -> var_dec ; .

    ID              reduce using rule 21 (var_list -> var_dec ; .)
    BEGIN           reduce using rule 21 (var_list -> var_dec ; .)


state 73

    (23) var_dec -> id_list : . tipo
    (26) tipo -> . ID
    (27) tipo -> . new_type
    (28) new_type -> . enumerated_type
    (29) new_type -> . subrange_type
    (30) new_type -> . array_type
    (31) enumerated_type -> . ( id_list )
    (32) subrange_type -> . constant DOTDOT constant
    (33) array_type -> . ARRAY [ ordinal_type_list ] OF tipo
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    ID              shift and go to state 111
    (               shift and go to state 116
    ARRAY           shift and go to state 118
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    +               shift and go to state 47
    -               shift and go to state 48

    tipo                           shift and go to state 110
    new_type                       shift and go to state 112
    enumerated_type                shift and go to state 113
    subrange_type                  shift and go to state 114
    array_type                     shift and go to state 115
    constant                       shift and go to state 117
    sign                           shift and go to state 42

state 74

    (42) proc_dec -> proc_heading ; block . ;

    ;               shift and go to state 119


state 75

    (43) func_dec -> func_heading ; block . ;

    ;               shift and go to state 120


state 76

    (45) proc_heading -> PROCEDURE ID ( . param_list )
    (48) param_list -> . param
    (49) param_list -> . param_list ; param
    (50) param -> . id_list : ID
    (51) param -> . VAR id_list : ID
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    VAR             shift and go to state 124
    ID              shift and go to state 15

    param_list                     shift and go to state 121
    param                          shift and go to state 122
    id_list                        shift and go to state 123

state 77

    (46) func_heading -> FUNCTION ID : . ID

    ID              shift and go to state 125


state 78

    (47) func_heading -> FUNCTION ID ( . param_list ) : ID
    (48) param_list -> . param
    (49) param_list -> . param_list ; param
    (50) param -> . id_list : ID
    (51) param -> . VAR id_list : ID
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    VAR             shift and go to state 124
    ID              shift and go to state 15

    param_list                     shift and go to state 126
    param                          shift and go to state 122
    id_list                        shift and go to state 123

state 79

    (10) constant -> sign INT .

    ;               reduce using rule 10 (constant -> sign INT .)
    DOTDOT          reduce using rule 10 (constant -> sign INT .)
    ]               reduce using rule 10 (constant -> sign INT .)
    ,               reduce using rule 10 (constant -> sign INT .)


state 80

    (12) constant -> sign REAL .

    ;               reduce using rule 12 (constant -> sign REAL .)
    DOTDOT          reduce using rule 12 (constant -> sign REAL .)
    ]               reduce using rule 12 (constant -> sign REAL .)
    ,               reduce using rule 12 (constant -> sign REAL .)


state 81

    (90) compound_statement -> BEGIN statement_list END .

    .               reduce using rule 90 (compound_statement -> BEGIN statement_list END .)
    ;               reduce using rule 90 (compound_statement -> BEGIN statement_list END .)
    END             reduce using rule 90 (compound_statement -> BEGIN statement_list END .)
    ELSE            reduce using rule 90 (compound_statement -> BEGIN statement_list END .)


state 82

    (92) statement_list -> statement_list ; . statement
    (93) statement -> .
    (94) statement -> . assignment_statement
    (95) statement -> . proc_statement
    (96) statement -> . read_statement
    (97) statement -> . write_statement
    (98) statement -> . labeled_statement
    (99) statement -> . compound_statement
    (100) statement -> . if_statement
    (101) statement -> . while_statement
    (102) statement -> . for_statement
    (103) assignment_statement -> . var_access ASSIGN expr
    (104) proc_statement -> . ID
    (105) proc_statement -> . ID ( expr_list )
    (107) read_statement -> . READ ( var_access_list )
    (108) read_statement -> . READLN
    (109) read_statement -> . READLN ( var_access_list )
    (112) write_statement -> . WRITE ( write_list )
    (113) write_statement -> . WRITELN
    (114) write_statement -> . WRITELN ( write_list )
    (106) labeled_statement -> . INT : statement
    (90) compound_statement -> . BEGIN statement_list END
    (120) if_statement -> . IF expr THEN statement
    (121) if_statement -> . IF expr THEN statement ELSE statement
    (122) while_statement -> . WHILE expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (124) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 93 (statement -> .)
    ;               reduce using rule 93 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 127
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 83

    (103) assignment_statement -> var_access ASSIGN . expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    var_access                     shift and go to state 97
    expr                           shift and go to state 128
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96

state 84

    (105) proc_statement -> ID ( . expr_list )
    (55) expr_list -> . expr
    (56) expr_list -> . expr_list , expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    expr_list                      shift and go to state 129
    expr                           shift and go to state 130
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 85

    (52) var_access -> ID var_suffix .

    ASSIGN          reduce using rule 52 (var_access -> ID var_suffix .)
    *               reduce using rule 52 (var_access -> ID var_suffix .)
    /               reduce using rule 52 (var_access -> ID var_suffix .)
    DIV             reduce using rule 52 (var_access -> ID var_suffix .)
    MOD             reduce using rule 52 (var_access -> ID var_suffix .)
    AND             reduce using rule 52 (var_access -> ID var_suffix .)
    +               reduce using rule 52 (var_access -> ID var_suffix .)
    -               reduce using rule 52 (var_access -> ID var_suffix .)
    OR              reduce using rule 52 (var_access -> ID var_suffix .)
    =               reduce using rule 52 (var_access -> ID var_suffix .)
    NE              reduce using rule 52 (var_access -> ID var_suffix .)
    LT              reduce using rule 52 (var_access -> ID var_suffix .)
    GT              reduce using rule 52 (var_access -> ID var_suffix .)
    LE              reduce using rule 52 (var_access -> ID var_suffix .)
    GE              reduce using rule 52 (var_access -> ID var_suffix .)
    THEN            reduce using rule 52 (var_access -> ID var_suffix .)
    DO              reduce using rule 52 (var_access -> ID var_suffix .)
    END             reduce using rule 52 (var_access -> ID var_suffix .)
    ;               reduce using rule 52 (var_access -> ID var_suffix .)
    ELSE            reduce using rule 52 (var_access -> ID var_suffix .)
    )               reduce using rule 52 (var_access -> ID var_suffix .)
    ,               reduce using rule 52 (var_access -> ID var_suffix .)
    ]               reduce using rule 52 (var_access -> ID var_suffix .)
    :               reduce using rule 52 (var_access -> ID var_suffix .)
    TO              reduce using rule 52 (var_access -> ID var_suffix .)
    DOWNTO          reduce using rule 52 (var_access -> ID var_suffix .)


state 86

    (54) var_suffix -> [ . expr_list ] var_suffix
    (55) expr_list -> . expr
    (56) expr_list -> . expr_list , expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    expr_list                      shift and go to state 131
    expr                           shift and go to state 130
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 87

    (107) read_statement -> READ ( . var_access_list )
    (110) var_access_list -> . var_access
    (111) var_access_list -> . var_access_list , var_access
    (52) var_access -> . ID var_suffix

    ID              shift and go to state 134

    var_access_list                shift and go to state 132
    var_access                     shift and go to state 133

state 88

    (109) read_statement -> READLN ( . var_access_list )
    (110) var_access_list -> . var_access
    (111) var_access_list -> . var_access_list , var_access
    (52) var_access -> . ID var_suffix

    ID              shift and go to state 134

    var_access_list                shift and go to state 135
    var_access                     shift and go to state 133

state 89

    (112) write_statement -> WRITE ( . write_list )
    (115) write_list -> . write_param
    (116) write_list -> . write_list , write_param
    (117) write_param -> . expr
    (118) write_param -> . expr : expr
    (119) write_param -> . expr : expr : expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    write_list                     shift and go to state 136
    write_param                    shift and go to state 137
    expr                           shift and go to state 138
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 90

    (114) write_statement -> WRITELN ( . write_list )
    (115) write_list -> . write_param
    (116) write_list -> . write_list , write_param
    (117) write_param -> . expr
    (118) write_param -> . expr : expr
    (119) write_param -> . expr : expr : expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    write_list                     shift and go to state 139
    write_param                    shift and go to state 137
    expr                           shift and go to state 138
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 91

    (106) labeled_statement -> INT : . statement
    (93) statement -> .
    (94) statement -> . assignment_statement
    (95) statement -> . proc_statement
    (96) statement -> . read_statement
    (97) statement -> . write_statement
    (98) statement -> . labeled_statement
    (99) statement -> . compound_statement
    (100) statement -> . if_statement
    (101) statement -> . while_statement
    (102) statement -> . for_statement
    (103) assignment_statement -> . var_access ASSIGN expr
    (104) proc_statement -> . ID
    (105) proc_statement -> . ID ( expr_list )
    (107) read_statement -> . READ ( var_access_list )
    (108) read_statement -> . READLN
    (109) read_statement -> . READLN ( var_access_list )
    (112) write_statement -> . WRITE ( write_list )
    (113) write_statement -> . WRITELN
    (114) write_statement -> . WRITELN ( write_list )
    (106) labeled_statement -> . INT : statement
    (90) compound_statement -> . BEGIN statement_list END
    (120) if_statement -> . IF expr THEN statement
    (121) if_statement -> . IF expr THEN statement ELSE statement
    (122) while_statement -> . WHILE expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (124) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 93 (statement -> .)
    ;               reduce using rule 93 (statement -> .)
    ELSE            reduce using rule 93 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 140
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 92

    (120) if_statement -> IF expr . THEN statement
    (121) if_statement -> IF expr . THEN statement ELSE statement

    THEN            shift and go to state 141


state 93

    (57) expr -> simple_expr .
    (58) expr -> simple_expr . relation_op simple_expr
    (84) relation_op -> . =
    (85) relation_op -> . NE
    (86) relation_op -> . LT
    (87) relation_op -> . GT
    (88) relation_op -> . LE
    (89) relation_op -> . GE

    THEN            reduce using rule 57 (expr -> simple_expr .)
    DO              reduce using rule 57 (expr -> simple_expr .)
    END             reduce using rule 57 (expr -> simple_expr .)
    ;               reduce using rule 57 (expr -> simple_expr .)
    ELSE            reduce using rule 57 (expr -> simple_expr .)
    )               reduce using rule 57 (expr -> simple_expr .)
    ,               reduce using rule 57 (expr -> simple_expr .)
    ]               reduce using rule 57 (expr -> simple_expr .)
    :               reduce using rule 57 (expr -> simple_expr .)
    TO              reduce using rule 57 (expr -> simple_expr .)
    DOWNTO          reduce using rule 57 (expr -> simple_expr .)
    =               shift and go to state 143
    NE              shift and go to state 144
    LT              shift and go to state 145
    GT              shift and go to state 146
    LE              shift and go to state 147
    GE              shift and go to state 148

    relation_op                    shift and go to state 142

state 94

    (59) simple_expr -> term . term_sequence
    (62) term_sequence -> .
    (63) term_sequence -> . add_op term term_sequence
    (76) add_op -> . +
    (77) add_op -> . -
    (78) add_op -> . OR

    =               reduce using rule 62 (term_sequence -> .)
    NE              reduce using rule 62 (term_sequence -> .)
    LT              reduce using rule 62 (term_sequence -> .)
    GT              reduce using rule 62 (term_sequence -> .)
    LE              reduce using rule 62 (term_sequence -> .)
    GE              reduce using rule 62 (term_sequence -> .)
    THEN            reduce using rule 62 (term_sequence -> .)
    DO              reduce using rule 62 (term_sequence -> .)
    END             reduce using rule 62 (term_sequence -> .)
    ;               reduce using rule 62 (term_sequence -> .)
    ELSE            reduce using rule 62 (term_sequence -> .)
    )               reduce using rule 62 (term_sequence -> .)
    ,               reduce using rule 62 (term_sequence -> .)
    ]               reduce using rule 62 (term_sequence -> .)
    :               reduce using rule 62 (term_sequence -> .)
    TO              reduce using rule 62 (term_sequence -> .)
    DOWNTO          reduce using rule 62 (term_sequence -> .)
    +               shift and go to state 151
    -               shift and go to state 152
    OR              shift and go to state 153

    term_sequence                  shift and go to state 149
    add_op                         shift and go to state 150

state 95

    (60) simple_expr -> sign . term term_sequence
    (61) term -> . factor factor_sequence
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    term                           shift and go to state 154
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 96

    (61) term -> factor . factor_sequence
    (64) factor_sequence -> .
    (65) factor_sequence -> . mul_op factor factor_sequence
    (79) mul_op -> . *
    (80) mul_op -> . /
    (81) mul_op -> . DIV
    (82) mul_op -> . MOD
    (83) mul_op -> . AND

    +               reduce using rule 64 (factor_sequence -> .)
    -               reduce using rule 64 (factor_sequence -> .)
    OR              reduce using rule 64 (factor_sequence -> .)
    =               reduce using rule 64 (factor_sequence -> .)
    NE              reduce using rule 64 (factor_sequence -> .)
    LT              reduce using rule 64 (factor_sequence -> .)
    GT              reduce using rule 64 (factor_sequence -> .)
    LE              reduce using rule 64 (factor_sequence -> .)
    GE              reduce using rule 64 (factor_sequence -> .)
    THEN            reduce using rule 64 (factor_sequence -> .)
    DO              reduce using rule 64 (factor_sequence -> .)
    END             reduce using rule 64 (factor_sequence -> .)
    ;               reduce using rule 64 (factor_sequence -> .)
    ELSE            reduce using rule 64 (factor_sequence -> .)
    )               reduce using rule 64 (factor_sequence -> .)
    ,               reduce using rule 64 (factor_sequence -> .)
    ]               reduce using rule 64 (factor_sequence -> .)
    :               reduce using rule 64 (factor_sequence -> .)
    TO              reduce using rule 64 (factor_sequence -> .)
    DOWNTO          reduce using rule 64 (factor_sequence -> .)
    *               shift and go to state 157
    /               shift and go to state 158
    DIV             shift and go to state 159
    MOD             shift and go to state 160
    AND             shift and go to state 161

    factor_sequence                shift and go to state 155
    mul_op                         shift and go to state 156

state 97

    (66) factor -> var_access .

    *               reduce using rule 66 (factor -> var_access .)
    /               reduce using rule 66 (factor -> var_access .)
    DIV             reduce using rule 66 (factor -> var_access .)
    MOD             reduce using rule 66 (factor -> var_access .)
    AND             reduce using rule 66 (factor -> var_access .)
    +               reduce using rule 66 (factor -> var_access .)
    -               reduce using rule 66 (factor -> var_access .)
    OR              reduce using rule 66 (factor -> var_access .)
    =               reduce using rule 66 (factor -> var_access .)
    NE              reduce using rule 66 (factor -> var_access .)
    LT              reduce using rule 66 (factor -> var_access .)
    GT              reduce using rule 66 (factor -> var_access .)
    LE              reduce using rule 66 (factor -> var_access .)
    GE              reduce using rule 66 (factor -> var_access .)
    THEN            reduce using rule 66 (factor -> var_access .)
    DO              reduce using rule 66 (factor -> var_access .)
    END             reduce using rule 66 (factor -> var_access .)
    ;               reduce using rule 66 (factor -> var_access .)
    ELSE            reduce using rule 66 (factor -> var_access .)
    )               reduce using rule 66 (factor -> var_access .)
    ,               reduce using rule 66 (factor -> var_access .)
    ]               reduce using rule 66 (factor -> var_access .)
    :               reduce using rule 66 (factor -> var_access .)
    TO              reduce using rule 66 (factor -> var_access .)
    DOWNTO          reduce using rule 66 (factor -> var_access .)


state 98

    (67) factor -> INT .

    *               reduce using rule 67 (factor -> INT .)
    /               reduce using rule 67 (factor -> INT .)
    DIV             reduce using rule 67 (factor -> INT .)
    MOD             reduce using rule 67 (factor -> INT .)
    AND             reduce using rule 67 (factor -> INT .)
    +               reduce using rule 67 (factor -> INT .)
    -               reduce using rule 67 (factor -> INT .)
    OR              reduce using rule 67 (factor -> INT .)
    =               reduce using rule 67 (factor -> INT .)
    NE              reduce using rule 67 (factor -> INT .)
    LT              reduce using rule 67 (factor -> INT .)
    GT              reduce using rule 67 (factor -> INT .)
    LE              reduce using rule 67 (factor -> INT .)
    GE              reduce using rule 67 (factor -> INT .)
    THEN            reduce using rule 67 (factor -> INT .)
    DO              reduce using rule 67 (factor -> INT .)
    END             reduce using rule 67 (factor -> INT .)
    ;               reduce using rule 67 (factor -> INT .)
    ELSE            reduce using rule 67 (factor -> INT .)
    )               reduce using rule 67 (factor -> INT .)
    ,               reduce using rule 67 (factor -> INT .)
    ]               reduce using rule 67 (factor -> INT .)
    :               reduce using rule 67 (factor -> INT .)
    TO              reduce using rule 67 (factor -> INT .)
    DOWNTO          reduce using rule 67 (factor -> INT .)


state 99

    (68) factor -> REAL .

    *               reduce using rule 68 (factor -> REAL .)
    /               reduce using rule 68 (factor -> REAL .)
    DIV             reduce using rule 68 (factor -> REAL .)
    MOD             reduce using rule 68 (factor -> REAL .)
    AND             reduce using rule 68 (factor -> REAL .)
    +               reduce using rule 68 (factor -> REAL .)
    -               reduce using rule 68 (factor -> REAL .)
    OR              reduce using rule 68 (factor -> REAL .)
    =               reduce using rule 68 (factor -> REAL .)
    NE              reduce using rule 68 (factor -> REAL .)
    LT              reduce using rule 68 (factor -> REAL .)
    GT              reduce using rule 68 (factor -> REAL .)
    LE              reduce using rule 68 (factor -> REAL .)
    GE              reduce using rule 68 (factor -> REAL .)
    THEN            reduce using rule 68 (factor -> REAL .)
    DO              reduce using rule 68 (factor -> REAL .)
    END             reduce using rule 68 (factor -> REAL .)
    ;               reduce using rule 68 (factor -> REAL .)
    ELSE            reduce using rule 68 (factor -> REAL .)
    )               reduce using rule 68 (factor -> REAL .)
    ,               reduce using rule 68 (factor -> REAL .)
    ]               reduce using rule 68 (factor -> REAL .)
    :               reduce using rule 68 (factor -> REAL .)
    TO              reduce using rule 68 (factor -> REAL .)
    DOWNTO          reduce using rule 68 (factor -> REAL .)


state 100

    (69) factor -> CHAR .

    *               reduce using rule 69 (factor -> CHAR .)
    /               reduce using rule 69 (factor -> CHAR .)
    DIV             reduce using rule 69 (factor -> CHAR .)
    MOD             reduce using rule 69 (factor -> CHAR .)
    AND             reduce using rule 69 (factor -> CHAR .)
    +               reduce using rule 69 (factor -> CHAR .)
    -               reduce using rule 69 (factor -> CHAR .)
    OR              reduce using rule 69 (factor -> CHAR .)
    =               reduce using rule 69 (factor -> CHAR .)
    NE              reduce using rule 69 (factor -> CHAR .)
    LT              reduce using rule 69 (factor -> CHAR .)
    GT              reduce using rule 69 (factor -> CHAR .)
    LE              reduce using rule 69 (factor -> CHAR .)
    GE              reduce using rule 69 (factor -> CHAR .)
    THEN            reduce using rule 69 (factor -> CHAR .)
    DO              reduce using rule 69 (factor -> CHAR .)
    END             reduce using rule 69 (factor -> CHAR .)
    ;               reduce using rule 69 (factor -> CHAR .)
    ELSE            reduce using rule 69 (factor -> CHAR .)
    )               reduce using rule 69 (factor -> CHAR .)
    ,               reduce using rule 69 (factor -> CHAR .)
    ]               reduce using rule 69 (factor -> CHAR .)
    :               reduce using rule 69 (factor -> CHAR .)
    TO              reduce using rule 69 (factor -> CHAR .)
    DOWNTO          reduce using rule 69 (factor -> CHAR .)


state 101

    (70) factor -> STRING .

    *               reduce using rule 70 (factor -> STRING .)
    /               reduce using rule 70 (factor -> STRING .)
    DIV             reduce using rule 70 (factor -> STRING .)
    MOD             reduce using rule 70 (factor -> STRING .)
    AND             reduce using rule 70 (factor -> STRING .)
    +               reduce using rule 70 (factor -> STRING .)
    -               reduce using rule 70 (factor -> STRING .)
    OR              reduce using rule 70 (factor -> STRING .)
    =               reduce using rule 70 (factor -> STRING .)
    NE              reduce using rule 70 (factor -> STRING .)
    LT              reduce using rule 70 (factor -> STRING .)
    GT              reduce using rule 70 (factor -> STRING .)
    LE              reduce using rule 70 (factor -> STRING .)
    GE              reduce using rule 70 (factor -> STRING .)
    THEN            reduce using rule 70 (factor -> STRING .)
    DO              reduce using rule 70 (factor -> STRING .)
    END             reduce using rule 70 (factor -> STRING .)
    ;               reduce using rule 70 (factor -> STRING .)
    ELSE            reduce using rule 70 (factor -> STRING .)
    )               reduce using rule 70 (factor -> STRING .)
    ,               reduce using rule 70 (factor -> STRING .)
    ]               reduce using rule 70 (factor -> STRING .)
    :               reduce using rule 70 (factor -> STRING .)
    TO              reduce using rule 70 (factor -> STRING .)
    DOWNTO          reduce using rule 70 (factor -> STRING .)


state 102

    (71) factor -> ID . ( expr_list )
    (52) var_access -> ID . var_suffix
    (53) var_suffix -> .
    (54) var_suffix -> . [ expr_list ] var_suffix

    (               shift and go to state 162
    *               reduce using rule 53 (var_suffix -> .)
    /               reduce using rule 53 (var_suffix -> .)
    DIV             reduce using rule 53 (var_suffix -> .)
    MOD             reduce using rule 53 (var_suffix -> .)
    AND             reduce using rule 53 (var_suffix -> .)
    +               reduce using rule 53 (var_suffix -> .)
    -               reduce using rule 53 (var_suffix -> .)
    OR              reduce using rule 53 (var_suffix -> .)
    =               reduce using rule 53 (var_suffix -> .)
    NE              reduce using rule 53 (var_suffix -> .)
    LT              reduce using rule 53 (var_suffix -> .)
    GT              reduce using rule 53 (var_suffix -> .)
    LE              reduce using rule 53 (var_suffix -> .)
    GE              reduce using rule 53 (var_suffix -> .)
    THEN            reduce using rule 53 (var_suffix -> .)
    DO              reduce using rule 53 (var_suffix -> .)
    END             reduce using rule 53 (var_suffix -> .)
    ;               reduce using rule 53 (var_suffix -> .)
    ELSE            reduce using rule 53 (var_suffix -> .)
    )               reduce using rule 53 (var_suffix -> .)
    ,               reduce using rule 53 (var_suffix -> .)
    ]               reduce using rule 53 (var_suffix -> .)
    :               reduce using rule 53 (var_suffix -> .)
    TO              reduce using rule 53 (var_suffix -> .)
    DOWNTO          reduce using rule 53 (var_suffix -> .)
    [               shift and go to state 86

    var_suffix                     shift and go to state 85

state 103

    (72) factor -> ( . expr )
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    expr                           shift and go to state 163
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 104

    (73) factor -> NOT . factor
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    factor                         shift and go to state 164
    var_access                     shift and go to state 97

state 105

    (74) factor -> TRUE .

    *               reduce using rule 74 (factor -> TRUE .)
    /               reduce using rule 74 (factor -> TRUE .)
    DIV             reduce using rule 74 (factor -> TRUE .)
    MOD             reduce using rule 74 (factor -> TRUE .)
    AND             reduce using rule 74 (factor -> TRUE .)
    +               reduce using rule 74 (factor -> TRUE .)
    -               reduce using rule 74 (factor -> TRUE .)
    OR              reduce using rule 74 (factor -> TRUE .)
    =               reduce using rule 74 (factor -> TRUE .)
    NE              reduce using rule 74 (factor -> TRUE .)
    LT              reduce using rule 74 (factor -> TRUE .)
    GT              reduce using rule 74 (factor -> TRUE .)
    LE              reduce using rule 74 (factor -> TRUE .)
    GE              reduce using rule 74 (factor -> TRUE .)
    THEN            reduce using rule 74 (factor -> TRUE .)
    DO              reduce using rule 74 (factor -> TRUE .)
    END             reduce using rule 74 (factor -> TRUE .)
    ;               reduce using rule 74 (factor -> TRUE .)
    ELSE            reduce using rule 74 (factor -> TRUE .)
    )               reduce using rule 74 (factor -> TRUE .)
    ,               reduce using rule 74 (factor -> TRUE .)
    ]               reduce using rule 74 (factor -> TRUE .)
    :               reduce using rule 74 (factor -> TRUE .)
    TO              reduce using rule 74 (factor -> TRUE .)
    DOWNTO          reduce using rule 74 (factor -> TRUE .)


state 106

    (75) factor -> FALSE .

    *               reduce using rule 75 (factor -> FALSE .)
    /               reduce using rule 75 (factor -> FALSE .)
    DIV             reduce using rule 75 (factor -> FALSE .)
    MOD             reduce using rule 75 (factor -> FALSE .)
    AND             reduce using rule 75 (factor -> FALSE .)
    +               reduce using rule 75 (factor -> FALSE .)
    -               reduce using rule 75 (factor -> FALSE .)
    OR              reduce using rule 75 (factor -> FALSE .)
    =               reduce using rule 75 (factor -> FALSE .)
    NE              reduce using rule 75 (factor -> FALSE .)
    LT              reduce using rule 75 (factor -> FALSE .)
    GT              reduce using rule 75 (factor -> FALSE .)
    LE              reduce using rule 75 (factor -> FALSE .)
    GE              reduce using rule 75 (factor -> FALSE .)
    THEN            reduce using rule 75 (factor -> FALSE .)
    DO              reduce using rule 75 (factor -> FALSE .)
    END             reduce using rule 75 (factor -> FALSE .)
    ;               reduce using rule 75 (factor -> FALSE .)
    ELSE            reduce using rule 75 (factor -> FALSE .)
    )               reduce using rule 75 (factor -> FALSE .)
    ,               reduce using rule 75 (factor -> FALSE .)
    ]               reduce using rule 75 (factor -> FALSE .)
    :               reduce using rule 75 (factor -> FALSE .)
    TO              reduce using rule 75 (factor -> FALSE .)
    DOWNTO          reduce using rule 75 (factor -> FALSE .)


state 107

    (122) while_statement -> WHILE expr . DO statement

    DO              shift and go to state 165


state 108

    (123) for_statement -> FOR ID . ASSIGN expr TO expr DO statement
    (124) for_statement -> FOR ID . ASSIGN expr DOWNTO expr DO statement

    ASSIGN          shift and go to state 166


state 109

    (22) var_list -> var_list var_dec ; .

    ID              reduce using rule 22 (var_list -> var_list var_dec ; .)
    BEGIN           reduce using rule 22 (var_list -> var_list var_dec ; .)


state 110

    (23) var_dec -> id_list : tipo .

    ;               reduce using rule 23 (var_dec -> id_list : tipo .)


state 111

    (26) tipo -> ID .
    (16) constant -> ID .

    ;               reduce using rule 26 (tipo -> ID .)
    DOTDOT          reduce using rule 16 (constant -> ID .)


state 112

    (27) tipo -> new_type .

    ;               reduce using rule 27 (tipo -> new_type .)


state 113

    (28) new_type -> enumerated_type .

    ;               reduce using rule 28 (new_type -> enumerated_type .)


state 114

    (29) new_type -> subrange_type .

    ;               reduce using rule 29 (new_type -> subrange_type .)


state 115

    (30) new_type -> array_type .

    ;               reduce using rule 30 (new_type -> array_type .)


state 116

    (31) enumerated_type -> ( . id_list )
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 167

state 117

    (32) subrange_type -> constant . DOTDOT constant

    DOTDOT          shift and go to state 168


state 118

    (33) array_type -> ARRAY . [ ordinal_type_list ] OF tipo

    [               shift and go to state 169


state 119

    (42) proc_dec -> proc_heading ; block ; .

    VAR             reduce using rule 42 (proc_dec -> proc_heading ; block ; .)
    PROCEDURE       reduce using rule 42 (proc_dec -> proc_heading ; block ; .)
    FUNCTION        reduce using rule 42 (proc_dec -> proc_heading ; block ; .)
    BEGIN           reduce using rule 42 (proc_dec -> proc_heading ; block ; .)


state 120

    (43) func_dec -> func_heading ; block ; .

    VAR             reduce using rule 43 (func_dec -> func_heading ; block ; .)
    PROCEDURE       reduce using rule 43 (func_dec -> func_heading ; block ; .)
    FUNCTION        reduce using rule 43 (func_dec -> func_heading ; block ; .)
    BEGIN           reduce using rule 43 (func_dec -> func_heading ; block ; .)


state 121

    (45) proc_heading -> PROCEDURE ID ( param_list . )
    (49) param_list -> param_list . ; param

    )               shift and go to state 170
    ;               shift and go to state 171


state 122

    (48) param_list -> param .

    )               reduce using rule 48 (param_list -> param .)
    ;               reduce using rule 48 (param_list -> param .)


state 123

    (50) param -> id_list . : ID

    :               shift and go to state 172


state 124

    (51) param -> VAR . id_list : ID
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 173

state 125

    (46) func_heading -> FUNCTION ID : ID .

    ;               reduce using rule 46 (func_heading -> FUNCTION ID : ID .)


state 126

    (47) func_heading -> FUNCTION ID ( param_list . ) : ID
    (49) param_list -> param_list . ; param

    )               shift and go to state 174
    ;               shift and go to state 171


state 127

    (92) statement_list -> statement_list ; statement .

    END             reduce using rule 92 (statement_list -> statement_list ; statement .)
    ;               reduce using rule 92 (statement_list -> statement_list ; statement .)


state 128

    (103) assignment_statement -> var_access ASSIGN expr .

    END             reduce using rule 103 (assignment_statement -> var_access ASSIGN expr .)
    ;               reduce using rule 103 (assignment_statement -> var_access ASSIGN expr .)
    ELSE            reduce using rule 103 (assignment_statement -> var_access ASSIGN expr .)


state 129

    (105) proc_statement -> ID ( expr_list . )
    (56) expr_list -> expr_list . , expr

    )               shift and go to state 175
    ,               shift and go to state 176


state 130

    (55) expr_list -> expr .

    )               reduce using rule 55 (expr_list -> expr .)
    ,               reduce using rule 55 (expr_list -> expr .)
    ]               reduce using rule 55 (expr_list -> expr .)


state 131

    (54) var_suffix -> [ expr_list . ] var_suffix
    (56) expr_list -> expr_list . , expr

    ]               shift and go to state 177
    ,               shift and go to state 176


state 132

    (107) read_statement -> READ ( var_access_list . )
    (111) var_access_list -> var_access_list . , var_access

    )               shift and go to state 178
    ,               shift and go to state 179


state 133

    (110) var_access_list -> var_access .

    )               reduce using rule 110 (var_access_list -> var_access .)
    ,               reduce using rule 110 (var_access_list -> var_access .)


state 134

    (52) var_access -> ID . var_suffix
    (53) var_suffix -> .
    (54) var_suffix -> . [ expr_list ] var_suffix

    )               reduce using rule 53 (var_suffix -> .)
    ,               reduce using rule 53 (var_suffix -> .)
    [               shift and go to state 86

    var_suffix                     shift and go to state 85

state 135

    (109) read_statement -> READLN ( var_access_list . )
    (111) var_access_list -> var_access_list . , var_access

    )               shift and go to state 180
    ,               shift and go to state 179


state 136

    (112) write_statement -> WRITE ( write_list . )
    (116) write_list -> write_list . , write_param

    )               shift and go to state 181
    ,               shift and go to state 182


state 137

    (115) write_list -> write_param .

    )               reduce using rule 115 (write_list -> write_param .)
    ,               reduce using rule 115 (write_list -> write_param .)


state 138

    (117) write_param -> expr .
    (118) write_param -> expr . : expr
    (119) write_param -> expr . : expr : expr

    )               reduce using rule 117 (write_param -> expr .)
    ,               reduce using rule 117 (write_param -> expr .)
    :               shift and go to state 183


state 139

    (114) write_statement -> WRITELN ( write_list . )
    (116) write_list -> write_list . , write_param

    )               shift and go to state 184
    ,               shift and go to state 182


state 140

    (106) labeled_statement -> INT : statement .

    END             reduce using rule 106 (labeled_statement -> INT : statement .)
    ;               reduce using rule 106 (labeled_statement -> INT : statement .)
    ELSE            reduce using rule 106 (labeled_statement -> INT : statement .)


state 141

    (120) if_statement -> IF expr THEN . statement
    (121) if_statement -> IF expr THEN . statement ELSE statement
    (93) statement -> .
    (94) statement -> . assignment_statement
    (95) statement -> . proc_statement
    (96) statement -> . read_statement
    (97) statement -> . write_statement
    (98) statement -> . labeled_statement
    (99) statement -> . compound_statement
    (100) statement -> . if_statement
    (101) statement -> . while_statement
    (102) statement -> . for_statement
    (103) assignment_statement -> . var_access ASSIGN expr
    (104) proc_statement -> . ID
    (105) proc_statement -> . ID ( expr_list )
    (107) read_statement -> . READ ( var_access_list )
    (108) read_statement -> . READLN
    (109) read_statement -> . READLN ( var_access_list )
    (112) write_statement -> . WRITE ( write_list )
    (113) write_statement -> . WRITELN
    (114) write_statement -> . WRITELN ( write_list )
    (106) labeled_statement -> . INT : statement
    (90) compound_statement -> . BEGIN statement_list END
    (120) if_statement -> . IF expr THEN statement
    (121) if_statement -> . IF expr THEN statement ELSE statement
    (122) while_statement -> . WHILE expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (124) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 93 (statement -> .)
    ;               reduce using rule 93 (statement -> .)
    ELSE            reduce using rule 93 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 185
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 142

    (58) expr -> simple_expr relation_op . simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    simple_expr                    shift and go to state 186
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 143

    (84) relation_op -> = .

    +               reduce using rule 84 (relation_op -> = .)
    -               reduce using rule 84 (relation_op -> = .)
    INT             reduce using rule 84 (relation_op -> = .)
    REAL            reduce using rule 84 (relation_op -> = .)
    CHAR            reduce using rule 84 (relation_op -> = .)
    STRING          reduce using rule 84 (relation_op -> = .)
    ID              reduce using rule 84 (relation_op -> = .)
    (               reduce using rule 84 (relation_op -> = .)
    NOT             reduce using rule 84 (relation_op -> = .)
    TRUE            reduce using rule 84 (relation_op -> = .)
    FALSE           reduce using rule 84 (relation_op -> = .)


state 144

    (85) relation_op -> NE .

    +               reduce using rule 85 (relation_op -> NE .)
    -               reduce using rule 85 (relation_op -> NE .)
    INT             reduce using rule 85 (relation_op -> NE .)
    REAL            reduce using rule 85 (relation_op -> NE .)
    CHAR            reduce using rule 85 (relation_op -> NE .)
    STRING          reduce using rule 85 (relation_op -> NE .)
    ID              reduce using rule 85 (relation_op -> NE .)
    (               reduce using rule 85 (relation_op -> NE .)
    NOT             reduce using rule 85 (relation_op -> NE .)
    TRUE            reduce using rule 85 (relation_op -> NE .)
    FALSE           reduce using rule 85 (relation_op -> NE .)


state 145

    (86) relation_op -> LT .

    +               reduce using rule 86 (relation_op -> LT .)
    -               reduce using rule 86 (relation_op -> LT .)
    INT             reduce using rule 86 (relation_op -> LT .)
    REAL            reduce using rule 86 (relation_op -> LT .)
    CHAR            reduce using rule 86 (relation_op -> LT .)
    STRING          reduce using rule 86 (relation_op -> LT .)
    ID              reduce using rule 86 (relation_op -> LT .)
    (               reduce using rule 86 (relation_op -> LT .)
    NOT             reduce using rule 86 (relation_op -> LT .)
    TRUE            reduce using rule 86 (relation_op -> LT .)
    FALSE           reduce using rule 86 (relation_op -> LT .)


state 146

    (87) relation_op -> GT .

    +               reduce using rule 87 (relation_op -> GT .)
    -               reduce using rule 87 (relation_op -> GT .)
    INT             reduce using rule 87 (relation_op -> GT .)
    REAL            reduce using rule 87 (relation_op -> GT .)
    CHAR            reduce using rule 87 (relation_op -> GT .)
    STRING          reduce using rule 87 (relation_op -> GT .)
    ID              reduce using rule 87 (relation_op -> GT .)
    (               reduce using rule 87 (relation_op -> GT .)
    NOT             reduce using rule 87 (relation_op -> GT .)
    TRUE            reduce using rule 87 (relation_op -> GT .)
    FALSE           reduce using rule 87 (relation_op -> GT .)


state 147

    (88) relation_op -> LE .

    +               reduce using rule 88 (relation_op -> LE .)
    -               reduce using rule 88 (relation_op -> LE .)
    INT             reduce using rule 88 (relation_op -> LE .)
    REAL            reduce using rule 88 (relation_op -> LE .)
    CHAR            reduce using rule 88 (relation_op -> LE .)
    STRING          reduce using rule 88 (relation_op -> LE .)
    ID              reduce using rule 88 (relation_op -> LE .)
    (               reduce using rule 88 (relation_op -> LE .)
    NOT             reduce using rule 88 (relation_op -> LE .)
    TRUE            reduce using rule 88 (relation_op -> LE .)
    FALSE           reduce using rule 88 (relation_op -> LE .)


state 148

    (89) relation_op -> GE .

    +               reduce using rule 89 (relation_op -> GE .)
    -               reduce using rule 89 (relation_op -> GE .)
    INT             reduce using rule 89 (relation_op -> GE .)
    REAL            reduce using rule 89 (relation_op -> GE .)
    CHAR            reduce using rule 89 (relation_op -> GE .)
    STRING          reduce using rule 89 (relation_op -> GE .)
    ID              reduce using rule 89 (relation_op -> GE .)
    (               reduce using rule 89 (relation_op -> GE .)
    NOT             reduce using rule 89 (relation_op -> GE .)
    TRUE            reduce using rule 89 (relation_op -> GE .)
    FALSE           reduce using rule 89 (relation_op -> GE .)


state 149

    (59) simple_expr -> term term_sequence .

    =               reduce using rule 59 (simple_expr -> term term_sequence .)
    NE              reduce using rule 59 (simple_expr -> term term_sequence .)
    LT              reduce using rule 59 (simple_expr -> term term_sequence .)
    GT              reduce using rule 59 (simple_expr -> term term_sequence .)
    LE              reduce using rule 59 (simple_expr -> term term_sequence .)
    GE              reduce using rule 59 (simple_expr -> term term_sequence .)
    THEN            reduce using rule 59 (simple_expr -> term term_sequence .)
    DO              reduce using rule 59 (simple_expr -> term term_sequence .)
    END             reduce using rule 59 (simple_expr -> term term_sequence .)
    ;               reduce using rule 59 (simple_expr -> term term_sequence .)
    ELSE            reduce using rule 59 (simple_expr -> term term_sequence .)
    )               reduce using rule 59 (simple_expr -> term term_sequence .)
    ,               reduce using rule 59 (simple_expr -> term term_sequence .)
    ]               reduce using rule 59 (simple_expr -> term term_sequence .)
    :               reduce using rule 59 (simple_expr -> term term_sequence .)
    TO              reduce using rule 59 (simple_expr -> term term_sequence .)
    DOWNTO          reduce using rule 59 (simple_expr -> term term_sequence .)


state 150

    (63) term_sequence -> add_op . term term_sequence
    (61) term -> . factor factor_sequence
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    term                           shift and go to state 187
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 151

    (76) add_op -> + .

    INT             reduce using rule 76 (add_op -> + .)
    REAL            reduce using rule 76 (add_op -> + .)
    CHAR            reduce using rule 76 (add_op -> + .)
    STRING          reduce using rule 76 (add_op -> + .)
    ID              reduce using rule 76 (add_op -> + .)
    (               reduce using rule 76 (add_op -> + .)
    NOT             reduce using rule 76 (add_op -> + .)
    TRUE            reduce using rule 76 (add_op -> + .)
    FALSE           reduce using rule 76 (add_op -> + .)


state 152

    (77) add_op -> - .

    INT             reduce using rule 77 (add_op -> - .)
    REAL            reduce using rule 77 (add_op -> - .)
    CHAR            reduce using rule 77 (add_op -> - .)
    STRING          reduce using rule 77 (add_op -> - .)
    ID              reduce using rule 77 (add_op -> - .)
    (               reduce using rule 77 (add_op -> - .)
    NOT             reduce using rule 77 (add_op -> - .)
    TRUE            reduce using rule 77 (add_op -> - .)
    FALSE           reduce using rule 77 (add_op -> - .)


state 153

    (78) add_op -> OR .

    INT             reduce using rule 78 (add_op -> OR .)
    REAL            reduce using rule 78 (add_op -> OR .)
    CHAR            reduce using rule 78 (add_op -> OR .)
    STRING          reduce using rule 78 (add_op -> OR .)
    ID              reduce using rule 78 (add_op -> OR .)
    (               reduce using rule 78 (add_op -> OR .)
    NOT             reduce using rule 78 (add_op -> OR .)
    TRUE            reduce using rule 78 (add_op -> OR .)
    FALSE           reduce using rule 78 (add_op -> OR .)


state 154

    (60) simple_expr -> sign term . term_sequence
    (62) term_sequence -> .
    (63) term_sequence -> . add_op term term_sequence
    (76) add_op -> . +
    (77) add_op -> . -
    (78) add_op -> . OR

    =               reduce using rule 62 (term_sequence -> .)
    NE              reduce using rule 62 (term_sequence -> .)
    LT              reduce using rule 62 (term_sequence -> .)
    GT              reduce using rule 62 (term_sequence -> .)
    LE              reduce using rule 62 (term_sequence -> .)
    GE              reduce using rule 62 (term_sequence -> .)
    THEN            reduce using rule 62 (term_sequence -> .)
    DO              reduce using rule 62 (term_sequence -> .)
    END             reduce using rule 62 (term_sequence -> .)
    ;               reduce using rule 62 (term_sequence -> .)
    ELSE            reduce using rule 62 (term_sequence -> .)
    )               reduce using rule 62 (term_sequence -> .)
    ,               reduce using rule 62 (term_sequence -> .)
    ]               reduce using rule 62 (term_sequence -> .)
    :               reduce using rule 62 (term_sequence -> .)
    TO              reduce using rule 62 (term_sequence -> .)
    DOWNTO          reduce using rule 62 (term_sequence -> .)
    +               shift and go to state 151
    -               shift and go to state 152
    OR              shift and go to state 153

    term_sequence                  shift and go to state 188
    add_op                         shift and go to state 150

state 155

    (61) term -> factor factor_sequence .

    +               reduce using rule 61 (term -> factor factor_sequence .)
    -               reduce using rule 61 (term -> factor factor_sequence .)
    OR              reduce using rule 61 (term -> factor factor_sequence .)
    =               reduce using rule 61 (term -> factor factor_sequence .)
    NE              reduce using rule 61 (term -> factor factor_sequence .)
    LT              reduce using rule 61 (term -> factor factor_sequence .)
    GT              reduce using rule 61 (term -> factor factor_sequence .)
    LE              reduce using rule 61 (term -> factor factor_sequence .)
    GE              reduce using rule 61 (term -> factor factor_sequence .)
    THEN            reduce using rule 61 (term -> factor factor_sequence .)
    DO              reduce using rule 61 (term -> factor factor_sequence .)
    END             reduce using rule 61 (term -> factor factor_sequence .)
    ;               reduce using rule 61 (term -> factor factor_sequence .)
    ELSE            reduce using rule 61 (term -> factor factor_sequence .)
    )               reduce using rule 61 (term -> factor factor_sequence .)
    ,               reduce using rule 61 (term -> factor factor_sequence .)
    ]               reduce using rule 61 (term -> factor factor_sequence .)
    :               reduce using rule 61 (term -> factor factor_sequence .)
    TO              reduce using rule 61 (term -> factor factor_sequence .)
    DOWNTO          reduce using rule 61 (term -> factor factor_sequence .)


state 156

    (65) factor_sequence -> mul_op . factor factor_sequence
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    factor                         shift and go to state 189
    var_access                     shift and go to state 97

state 157

    (79) mul_op -> * .

    INT             reduce using rule 79 (mul_op -> * .)
    REAL            reduce using rule 79 (mul_op -> * .)
    CHAR            reduce using rule 79 (mul_op -> * .)
    STRING          reduce using rule 79 (mul_op -> * .)
    ID              reduce using rule 79 (mul_op -> * .)
    (               reduce using rule 79 (mul_op -> * .)
    NOT             reduce using rule 79 (mul_op -> * .)
    TRUE            reduce using rule 79 (mul_op -> * .)
    FALSE           reduce using rule 79 (mul_op -> * .)


state 158

    (80) mul_op -> / .

    INT             reduce using rule 80 (mul_op -> / .)
    REAL            reduce using rule 80 (mul_op -> / .)
    CHAR            reduce using rule 80 (mul_op -> / .)
    STRING          reduce using rule 80 (mul_op -> / .)
    ID              reduce using rule 80 (mul_op -> / .)
    (               reduce using rule 80 (mul_op -> / .)
    NOT             reduce using rule 80 (mul_op -> / .)
    TRUE            reduce using rule 80 (mul_op -> / .)
    FALSE           reduce using rule 80 (mul_op -> / .)


state 159

    (81) mul_op -> DIV .

    INT             reduce using rule 81 (mul_op -> DIV .)
    REAL            reduce using rule 81 (mul_op -> DIV .)
    CHAR            reduce using rule 81 (mul_op -> DIV .)
    STRING          reduce using rule 81 (mul_op -> DIV .)
    ID              reduce using rule 81 (mul_op -> DIV .)
    (               reduce using rule 81 (mul_op -> DIV .)
    NOT             reduce using rule 81 (mul_op -> DIV .)
    TRUE            reduce using rule 81 (mul_op -> DIV .)
    FALSE           reduce using rule 81 (mul_op -> DIV .)


state 160

    (82) mul_op -> MOD .

    INT             reduce using rule 82 (mul_op -> MOD .)
    REAL            reduce using rule 82 (mul_op -> MOD .)
    CHAR            reduce using rule 82 (mul_op -> MOD .)
    STRING          reduce using rule 82 (mul_op -> MOD .)
    ID              reduce using rule 82 (mul_op -> MOD .)
    (               reduce using rule 82 (mul_op -> MOD .)
    NOT             reduce using rule 82 (mul_op -> MOD .)
    TRUE            reduce using rule 82 (mul_op -> MOD .)
    FALSE           reduce using rule 82 (mul_op -> MOD .)


state 161

    (83) mul_op -> AND .

    INT             reduce using rule 83 (mul_op -> AND .)
    REAL            reduce using rule 83 (mul_op -> AND .)
    CHAR            reduce using rule 83 (mul_op -> AND .)
    STRING          reduce using rule 83 (mul_op -> AND .)
    ID              reduce using rule 83 (mul_op -> AND .)
    (               reduce using rule 83 (mul_op -> AND .)
    NOT             reduce using rule 83 (mul_op -> AND .)
    TRUE            reduce using rule 83 (mul_op -> AND .)
    FALSE           reduce using rule 83 (mul_op -> AND .)


state 162

    (71) factor -> ID ( . expr_list )
    (55) expr_list -> . expr
    (56) expr_list -> . expr_list , expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    expr_list                      shift and go to state 190
    expr                           shift and go to state 130
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 163

    (72) factor -> ( expr . )

    )               shift and go to state 191


state 164

    (73) factor -> NOT factor .

    *               reduce using rule 73 (factor -> NOT factor .)
    /               reduce using rule 73 (factor -> NOT factor .)
    DIV             reduce using rule 73 (factor -> NOT factor .)
    MOD             reduce using rule 73 (factor -> NOT factor .)
    AND             reduce using rule 73 (factor -> NOT factor .)
    +               reduce using rule 73 (factor -> NOT factor .)
    -               reduce using rule 73 (factor -> NOT factor .)
    OR              reduce using rule 73 (factor -> NOT factor .)
    =               reduce using rule 73 (factor -> NOT factor .)
    NE              reduce using rule 73 (factor -> NOT factor .)
    LT              reduce using rule 73 (factor -> NOT factor .)
    GT              reduce using rule 73 (factor -> NOT factor .)
    LE              reduce using rule 73 (factor -> NOT factor .)
    GE              reduce using rule 73 (factor -> NOT factor .)
    THEN            reduce using rule 73 (factor -> NOT factor .)
    DO              reduce using rule 73 (factor -> NOT factor .)
    END             reduce using rule 73 (factor -> NOT factor .)
    ;               reduce using rule 73 (factor -> NOT factor .)
    ELSE            reduce using rule 73 (factor -> NOT factor .)
    )               reduce using rule 73 (factor -> NOT factor .)
    ,               reduce using rule 73 (factor -> NOT factor .)
    ]               reduce using rule 73 (factor -> NOT factor .)
    :               reduce using rule 73 (factor -> NOT factor .)
    TO              reduce using rule 73 (factor -> NOT factor .)
    DOWNTO          reduce using rule 73 (factor -> NOT factor .)


state 165

    (122) while_statement -> WHILE expr DO . statement
    (93) statement -> .
    (94) statement -> . assignment_statement
    (95) statement -> . proc_statement
    (96) statement -> . read_statement
    (97) statement -> . write_statement
    (98) statement -> . labeled_statement
    (99) statement -> . compound_statement
    (100) statement -> . if_statement
    (101) statement -> . while_statement
    (102) statement -> . for_statement
    (103) assignment_statement -> . var_access ASSIGN expr
    (104) proc_statement -> . ID
    (105) proc_statement -> . ID ( expr_list )
    (107) read_statement -> . READ ( var_access_list )
    (108) read_statement -> . READLN
    (109) read_statement -> . READLN ( var_access_list )
    (112) write_statement -> . WRITE ( write_list )
    (113) write_statement -> . WRITELN
    (114) write_statement -> . WRITELN ( write_list )
    (106) labeled_statement -> . INT : statement
    (90) compound_statement -> . BEGIN statement_list END
    (120) if_statement -> . IF expr THEN statement
    (121) if_statement -> . IF expr THEN statement ELSE statement
    (122) while_statement -> . WHILE expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (124) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 93 (statement -> .)
    ;               reduce using rule 93 (statement -> .)
    ELSE            reduce using rule 93 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 192
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 166

    (123) for_statement -> FOR ID ASSIGN . expr TO expr DO statement
    (124) for_statement -> FOR ID ASSIGN . expr DOWNTO expr DO statement
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    expr                           shift and go to state 193
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 167

    (31) enumerated_type -> ( id_list . )

    )               shift and go to state 194


state 168

    (32) subrange_type -> constant DOTDOT . constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    ID              shift and go to state 40
    +               shift and go to state 47
    -               shift and go to state 48

    constant                       shift and go to state 195
    sign                           shift and go to state 42

state 169

    (33) array_type -> ARRAY [ . ordinal_type_list ] OF tipo
    (37) ordinal_type_list -> . ordinal_type
    (38) ordinal_type_list -> . ordinal_type_list , ordinal_type
    (34) ordinal_type -> . enumerated_type
    (35) ordinal_type -> . subrange_type
    (36) ordinal_type -> . ID
    (31) enumerated_type -> . ( id_list )
    (32) subrange_type -> . constant DOTDOT constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    ID              shift and go to state 200
    (               shift and go to state 116
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    +               shift and go to state 47
    -               shift and go to state 48

    ordinal_type_list              shift and go to state 196
    ordinal_type                   shift and go to state 197
    enumerated_type                shift and go to state 198
    subrange_type                  shift and go to state 199
    constant                       shift and go to state 117
    sign                           shift and go to state 42

state 170

    (45) proc_heading -> PROCEDURE ID ( param_list ) .

    ;               reduce using rule 45 (proc_heading -> PROCEDURE ID ( param_list ) .)


state 171

    (49) param_list -> param_list ; . param
    (50) param -> . id_list : ID
    (51) param -> . VAR id_list : ID
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    VAR             shift and go to state 124
    ID              shift and go to state 15

    param                          shift and go to state 201
    id_list                        shift and go to state 123

state 172

    (50) param -> id_list : . ID

    ID              shift and go to state 202


state 173

    (51) param -> VAR id_list . : ID

    :               shift and go to state 203


state 174

    (47) func_heading -> FUNCTION ID ( param_list ) . : ID

    :               shift and go to state 204


state 175

    (105) proc_statement -> ID ( expr_list ) .

    END             reduce using rule 105 (proc_statement -> ID ( expr_list ) .)
    ;               reduce using rule 105 (proc_statement -> ID ( expr_list ) .)
    ELSE            reduce using rule 105 (proc_statement -> ID ( expr_list ) .)


state 176

    (56) expr_list -> expr_list , . expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    expr                           shift and go to state 205
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 177

    (54) var_suffix -> [ expr_list ] . var_suffix
    (53) var_suffix -> .
    (54) var_suffix -> . [ expr_list ] var_suffix

    ASSIGN          reduce using rule 53 (var_suffix -> .)
    *               reduce using rule 53 (var_suffix -> .)
    /               reduce using rule 53 (var_suffix -> .)
    DIV             reduce using rule 53 (var_suffix -> .)
    MOD             reduce using rule 53 (var_suffix -> .)
    AND             reduce using rule 53 (var_suffix -> .)
    +               reduce using rule 53 (var_suffix -> .)
    -               reduce using rule 53 (var_suffix -> .)
    OR              reduce using rule 53 (var_suffix -> .)
    =               reduce using rule 53 (var_suffix -> .)
    NE              reduce using rule 53 (var_suffix -> .)
    LT              reduce using rule 53 (var_suffix -> .)
    GT              reduce using rule 53 (var_suffix -> .)
    LE              reduce using rule 53 (var_suffix -> .)
    GE              reduce using rule 53 (var_suffix -> .)
    THEN            reduce using rule 53 (var_suffix -> .)
    DO              reduce using rule 53 (var_suffix -> .)
    END             reduce using rule 53 (var_suffix -> .)
    ;               reduce using rule 53 (var_suffix -> .)
    ELSE            reduce using rule 53 (var_suffix -> .)
    )               reduce using rule 53 (var_suffix -> .)
    ,               reduce using rule 53 (var_suffix -> .)
    ]               reduce using rule 53 (var_suffix -> .)
    :               reduce using rule 53 (var_suffix -> .)
    TO              reduce using rule 53 (var_suffix -> .)
    DOWNTO          reduce using rule 53 (var_suffix -> .)
    [               shift and go to state 86

    var_suffix                     shift and go to state 206

state 178

    (107) read_statement -> READ ( var_access_list ) .

    END             reduce using rule 107 (read_statement -> READ ( var_access_list ) .)
    ;               reduce using rule 107 (read_statement -> READ ( var_access_list ) .)
    ELSE            reduce using rule 107 (read_statement -> READ ( var_access_list ) .)


state 179

    (111) var_access_list -> var_access_list , . var_access
    (52) var_access -> . ID var_suffix

    ID              shift and go to state 134

    var_access                     shift and go to state 207

state 180

    (109) read_statement -> READLN ( var_access_list ) .

    END             reduce using rule 109 (read_statement -> READLN ( var_access_list ) .)
    ;               reduce using rule 109 (read_statement -> READLN ( var_access_list ) .)
    ELSE            reduce using rule 109 (read_statement -> READLN ( var_access_list ) .)


state 181

    (112) write_statement -> WRITE ( write_list ) .

    END             reduce using rule 112 (write_statement -> WRITE ( write_list ) .)
    ;               reduce using rule 112 (write_statement -> WRITE ( write_list ) .)
    ELSE            reduce using rule 112 (write_statement -> WRITE ( write_list ) .)


state 182

    (116) write_list -> write_list , . write_param
    (117) write_param -> . expr
    (118) write_param -> . expr : expr
    (119) write_param -> . expr : expr : expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    write_param                    shift and go to state 208
    expr                           shift and go to state 138
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 183

    (118) write_param -> expr : . expr
    (119) write_param -> expr : . expr : expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    expr                           shift and go to state 209
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 184

    (114) write_statement -> WRITELN ( write_list ) .

    END             reduce using rule 114 (write_statement -> WRITELN ( write_list ) .)
    ;               reduce using rule 114 (write_statement -> WRITELN ( write_list ) .)
    ELSE            reduce using rule 114 (write_statement -> WRITELN ( write_list ) .)


state 185

    (120) if_statement -> IF expr THEN statement .
    (121) if_statement -> IF expr THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    END             reduce using rule 120 (if_statement -> IF expr THEN statement .)
    ;               reduce using rule 120 (if_statement -> IF expr THEN statement .)
    ELSE            shift and go to state 210

  ! ELSE            [ reduce using rule 120 (if_statement -> IF expr THEN statement .) ]


state 186

    (58) expr -> simple_expr relation_op simple_expr .

    THEN            reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    DO              reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    END             reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    ;               reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    ELSE            reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    )               reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    ,               reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    ]               reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    :               reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    TO              reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    DOWNTO          reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)


state 187

    (63) term_sequence -> add_op term . term_sequence
    (62) term_sequence -> .
    (63) term_sequence -> . add_op term term_sequence
    (76) add_op -> . +
    (77) add_op -> . -
    (78) add_op -> . OR

    =               reduce using rule 62 (term_sequence -> .)
    NE              reduce using rule 62 (term_sequence -> .)
    LT              reduce using rule 62 (term_sequence -> .)
    GT              reduce using rule 62 (term_sequence -> .)
    LE              reduce using rule 62 (term_sequence -> .)
    GE              reduce using rule 62 (term_sequence -> .)
    THEN            reduce using rule 62 (term_sequence -> .)
    DO              reduce using rule 62 (term_sequence -> .)
    END             reduce using rule 62 (term_sequence -> .)
    ;               reduce using rule 62 (term_sequence -> .)
    ELSE            reduce using rule 62 (term_sequence -> .)
    )               reduce using rule 62 (term_sequence -> .)
    ,               reduce using rule 62 (term_sequence -> .)
    ]               reduce using rule 62 (term_sequence -> .)
    :               reduce using rule 62 (term_sequence -> .)
    TO              reduce using rule 62 (term_sequence -> .)
    DOWNTO          reduce using rule 62 (term_sequence -> .)
    +               shift and go to state 151
    -               shift and go to state 152
    OR              shift and go to state 153

    add_op                         shift and go to state 150
    term_sequence                  shift and go to state 211

state 188

    (60) simple_expr -> sign term term_sequence .

    =               reduce using rule 60 (simple_expr -> sign term term_sequence .)
    NE              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    LT              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    GT              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    LE              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    GE              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    THEN            reduce using rule 60 (simple_expr -> sign term term_sequence .)
    DO              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    END             reduce using rule 60 (simple_expr -> sign term term_sequence .)
    ;               reduce using rule 60 (simple_expr -> sign term term_sequence .)
    ELSE            reduce using rule 60 (simple_expr -> sign term term_sequence .)
    )               reduce using rule 60 (simple_expr -> sign term term_sequence .)
    ,               reduce using rule 60 (simple_expr -> sign term term_sequence .)
    ]               reduce using rule 60 (simple_expr -> sign term term_sequence .)
    :               reduce using rule 60 (simple_expr -> sign term term_sequence .)
    TO              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    DOWNTO          reduce using rule 60 (simple_expr -> sign term term_sequence .)


state 189

    (65) factor_sequence -> mul_op factor . factor_sequence
    (64) factor_sequence -> .
    (65) factor_sequence -> . mul_op factor factor_sequence
    (79) mul_op -> . *
    (80) mul_op -> . /
    (81) mul_op -> . DIV
    (82) mul_op -> . MOD
    (83) mul_op -> . AND

    +               reduce using rule 64 (factor_sequence -> .)
    -               reduce using rule 64 (factor_sequence -> .)
    OR              reduce using rule 64 (factor_sequence -> .)
    =               reduce using rule 64 (factor_sequence -> .)
    NE              reduce using rule 64 (factor_sequence -> .)
    LT              reduce using rule 64 (factor_sequence -> .)
    GT              reduce using rule 64 (factor_sequence -> .)
    LE              reduce using rule 64 (factor_sequence -> .)
    GE              reduce using rule 64 (factor_sequence -> .)
    THEN            reduce using rule 64 (factor_sequence -> .)
    DO              reduce using rule 64 (factor_sequence -> .)
    END             reduce using rule 64 (factor_sequence -> .)
    ;               reduce using rule 64 (factor_sequence -> .)
    ELSE            reduce using rule 64 (factor_sequence -> .)
    )               reduce using rule 64 (factor_sequence -> .)
    ,               reduce using rule 64 (factor_sequence -> .)
    ]               reduce using rule 64 (factor_sequence -> .)
    :               reduce using rule 64 (factor_sequence -> .)
    TO              reduce using rule 64 (factor_sequence -> .)
    DOWNTO          reduce using rule 64 (factor_sequence -> .)
    *               shift and go to state 157
    /               shift and go to state 158
    DIV             shift and go to state 159
    MOD             shift and go to state 160
    AND             shift and go to state 161

    mul_op                         shift and go to state 156
    factor_sequence                shift and go to state 212

state 190

    (71) factor -> ID ( expr_list . )
    (56) expr_list -> expr_list . , expr

    )               shift and go to state 213
    ,               shift and go to state 176


state 191

    (72) factor -> ( expr ) .

    *               reduce using rule 72 (factor -> ( expr ) .)
    /               reduce using rule 72 (factor -> ( expr ) .)
    DIV             reduce using rule 72 (factor -> ( expr ) .)
    MOD             reduce using rule 72 (factor -> ( expr ) .)
    AND             reduce using rule 72 (factor -> ( expr ) .)
    +               reduce using rule 72 (factor -> ( expr ) .)
    -               reduce using rule 72 (factor -> ( expr ) .)
    OR              reduce using rule 72 (factor -> ( expr ) .)
    =               reduce using rule 72 (factor -> ( expr ) .)
    NE              reduce using rule 72 (factor -> ( expr ) .)
    LT              reduce using rule 72 (factor -> ( expr ) .)
    GT              reduce using rule 72 (factor -> ( expr ) .)
    LE              reduce using rule 72 (factor -> ( expr ) .)
    GE              reduce using rule 72 (factor -> ( expr ) .)
    THEN            reduce using rule 72 (factor -> ( expr ) .)
    DO              reduce using rule 72 (factor -> ( expr ) .)
    END             reduce using rule 72 (factor -> ( expr ) .)
    ;               reduce using rule 72 (factor -> ( expr ) .)
    ELSE            reduce using rule 72 (factor -> ( expr ) .)
    )               reduce using rule 72 (factor -> ( expr ) .)
    ,               reduce using rule 72 (factor -> ( expr ) .)
    ]               reduce using rule 72 (factor -> ( expr ) .)
    :               reduce using rule 72 (factor -> ( expr ) .)
    TO              reduce using rule 72 (factor -> ( expr ) .)
    DOWNTO          reduce using rule 72 (factor -> ( expr ) .)


state 192

    (122) while_statement -> WHILE expr DO statement .

    END             reduce using rule 122 (while_statement -> WHILE expr DO statement .)
    ;               reduce using rule 122 (while_statement -> WHILE expr DO statement .)
    ELSE            reduce using rule 122 (while_statement -> WHILE expr DO statement .)


state 193

    (123) for_statement -> FOR ID ASSIGN expr . TO expr DO statement
    (124) for_statement -> FOR ID ASSIGN expr . DOWNTO expr DO statement

    TO              shift and go to state 214
    DOWNTO          shift and go to state 215


state 194

    (31) enumerated_type -> ( id_list ) .

    ;               reduce using rule 31 (enumerated_type -> ( id_list ) .)
    ]               reduce using rule 31 (enumerated_type -> ( id_list ) .)
    ,               reduce using rule 31 (enumerated_type -> ( id_list ) .)


state 195

    (32) subrange_type -> constant DOTDOT constant .

    ;               reduce using rule 32 (subrange_type -> constant DOTDOT constant .)
    ]               reduce using rule 32 (subrange_type -> constant DOTDOT constant .)
    ,               reduce using rule 32 (subrange_type -> constant DOTDOT constant .)


state 196

    (33) array_type -> ARRAY [ ordinal_type_list . ] OF tipo
    (38) ordinal_type_list -> ordinal_type_list . , ordinal_type

    ]               shift and go to state 216
    ,               shift and go to state 217


state 197

    (37) ordinal_type_list -> ordinal_type .

    ]               reduce using rule 37 (ordinal_type_list -> ordinal_type .)
    ,               reduce using rule 37 (ordinal_type_list -> ordinal_type .)


state 198

    (34) ordinal_type -> enumerated_type .

    ]               reduce using rule 34 (ordinal_type -> enumerated_type .)
    ,               reduce using rule 34 (ordinal_type -> enumerated_type .)


state 199

    (35) ordinal_type -> subrange_type .

    ]               reduce using rule 35 (ordinal_type -> subrange_type .)
    ,               reduce using rule 35 (ordinal_type -> subrange_type .)


state 200

    (36) ordinal_type -> ID .
    (16) constant -> ID .

    ]               reduce using rule 36 (ordinal_type -> ID .)
    ,               reduce using rule 36 (ordinal_type -> ID .)
    DOTDOT          reduce using rule 16 (constant -> ID .)


state 201

    (49) param_list -> param_list ; param .

    )               reduce using rule 49 (param_list -> param_list ; param .)
    ;               reduce using rule 49 (param_list -> param_list ; param .)


state 202

    (50) param -> id_list : ID .

    )               reduce using rule 50 (param -> id_list : ID .)
    ;               reduce using rule 50 (param -> id_list : ID .)


state 203

    (51) param -> VAR id_list : . ID

    ID              shift and go to state 218


state 204

    (47) func_heading -> FUNCTION ID ( param_list ) : . ID

    ID              shift and go to state 219


state 205

    (56) expr_list -> expr_list , expr .

    )               reduce using rule 56 (expr_list -> expr_list , expr .)
    ,               reduce using rule 56 (expr_list -> expr_list , expr .)
    ]               reduce using rule 56 (expr_list -> expr_list , expr .)


state 206

    (54) var_suffix -> [ expr_list ] var_suffix .

    ASSIGN          reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    *               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    /               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    DIV             reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    MOD             reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    AND             reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    +               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    -               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    OR              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    =               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    NE              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    LT              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    GT              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    LE              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    GE              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    THEN            reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    DO              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    END             reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    ;               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    ELSE            reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    )               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    ,               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    ]               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    :               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    TO              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    DOWNTO          reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)


state 207

    (111) var_access_list -> var_access_list , var_access .

    )               reduce using rule 111 (var_access_list -> var_access_list , var_access .)
    ,               reduce using rule 111 (var_access_list -> var_access_list , var_access .)


state 208

    (116) write_list -> write_list , write_param .

    )               reduce using rule 116 (write_list -> write_list , write_param .)
    ,               reduce using rule 116 (write_list -> write_list , write_param .)


state 209

    (118) write_param -> expr : expr .
    (119) write_param -> expr : expr . : expr

    )               reduce using rule 118 (write_param -> expr : expr .)
    ,               reduce using rule 118 (write_param -> expr : expr .)
    :               shift and go to state 220


state 210

    (121) if_statement -> IF expr THEN statement ELSE . statement
    (93) statement -> .
    (94) statement -> . assignment_statement
    (95) statement -> . proc_statement
    (96) statement -> . read_statement
    (97) statement -> . write_statement
    (98) statement -> . labeled_statement
    (99) statement -> . compound_statement
    (100) statement -> . if_statement
    (101) statement -> . while_statement
    (102) statement -> . for_statement
    (103) assignment_statement -> . var_access ASSIGN expr
    (104) proc_statement -> . ID
    (105) proc_statement -> . ID ( expr_list )
    (107) read_statement -> . READ ( var_access_list )
    (108) read_statement -> . READLN
    (109) read_statement -> . READLN ( var_access_list )
    (112) write_statement -> . WRITE ( write_list )
    (113) write_statement -> . WRITELN
    (114) write_statement -> . WRITELN ( write_list )
    (106) labeled_statement -> . INT : statement
    (90) compound_statement -> . BEGIN statement_list END
    (120) if_statement -> . IF expr THEN statement
    (121) if_statement -> . IF expr THEN statement ELSE statement
    (122) while_statement -> . WHILE expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (124) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 93 (statement -> .)
    ;               reduce using rule 93 (statement -> .)
    ELSE            reduce using rule 93 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 221
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 211

    (63) term_sequence -> add_op term term_sequence .

    =               reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    NE              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    LT              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    GT              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    LE              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    GE              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    THEN            reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    DO              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    END             reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    ;               reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    ELSE            reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    )               reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    ,               reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    ]               reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    :               reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    TO              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    DOWNTO          reduce using rule 63 (term_sequence -> add_op term term_sequence .)


state 212

    (65) factor_sequence -> mul_op factor factor_sequence .

    +               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    -               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    OR              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    =               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    NE              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    LT              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    GT              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    LE              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    GE              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    THEN            reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    DO              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    END             reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    ;               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    ELSE            reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    )               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    ,               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    ]               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    :               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    TO              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    DOWNTO          reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)


state 213

    (71) factor -> ID ( expr_list ) .

    *               reduce using rule 71 (factor -> ID ( expr_list ) .)
    /               reduce using rule 71 (factor -> ID ( expr_list ) .)
    DIV             reduce using rule 71 (factor -> ID ( expr_list ) .)
    MOD             reduce using rule 71 (factor -> ID ( expr_list ) .)
    AND             reduce using rule 71 (factor -> ID ( expr_list ) .)
    +               reduce using rule 71 (factor -> ID ( expr_list ) .)
    -               reduce using rule 71 (factor -> ID ( expr_list ) .)
    OR              reduce using rule 71 (factor -> ID ( expr_list ) .)
    =               reduce using rule 71 (factor -> ID ( expr_list ) .)
    NE              reduce using rule 71 (factor -> ID ( expr_list ) .)
    LT              reduce using rule 71 (factor -> ID ( expr_list ) .)
    GT              reduce using rule 71 (factor -> ID ( expr_list ) .)
    LE              reduce using rule 71 (factor -> ID ( expr_list ) .)
    GE              reduce using rule 71 (factor -> ID ( expr_list ) .)
    THEN            reduce using rule 71 (factor -> ID ( expr_list ) .)
    DO              reduce using rule 71 (factor -> ID ( expr_list ) .)
    END             reduce using rule 71 (factor -> ID ( expr_list ) .)
    ;               reduce using rule 71 (factor -> ID ( expr_list ) .)
    ELSE            reduce using rule 71 (factor -> ID ( expr_list ) .)
    )               reduce using rule 71 (factor -> ID ( expr_list ) .)
    ,               reduce using rule 71 (factor -> ID ( expr_list ) .)
    ]               reduce using rule 71 (factor -> ID ( expr_list ) .)
    :               reduce using rule 71 (factor -> ID ( expr_list ) .)
    TO              reduce using rule 71 (factor -> ID ( expr_list ) .)
    DOWNTO          reduce using rule 71 (factor -> ID ( expr_list ) .)


state 214

    (123) for_statement -> FOR ID ASSIGN expr TO . expr DO statement
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    expr                           shift and go to state 222
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 215

    (124) for_statement -> FOR ID ASSIGN expr DOWNTO . expr DO statement
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    expr                           shift and go to state 223
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 216

    (33) array_type -> ARRAY [ ordinal_type_list ] . OF tipo

    OF              shift and go to state 224


state 217

    (38) ordinal_type_list -> ordinal_type_list , . ordinal_type
    (34) ordinal_type -> . enumerated_type
    (35) ordinal_type -> . subrange_type
    (36) ordinal_type -> . ID
    (31) enumerated_type -> . ( id_list )
    (32) subrange_type -> . constant DOTDOT constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    ID              shift and go to state 200
    (               shift and go to state 116
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    +               shift and go to state 47
    -               shift and go to state 48

    ordinal_type                   shift and go to state 225
    enumerated_type                shift and go to state 198
    subrange_type                  shift and go to state 199
    constant                       shift and go to state 117
    sign                           shift and go to state 42

state 218

    (51) param -> VAR id_list : ID .

    )               reduce using rule 51 (param -> VAR id_list : ID .)
    ;               reduce using rule 51 (param -> VAR id_list : ID .)


state 219

    (47) func_heading -> FUNCTION ID ( param_list ) : ID .

    ;               reduce using rule 47 (func_heading -> FUNCTION ID ( param_list ) : ID .)


state 220

    (119) write_param -> expr : expr : . expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (74) factor -> . TRUE
    (75) factor -> . FALSE
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104
    TRUE            shift and go to state 105
    FALSE           shift and go to state 106

    expr                           shift and go to state 226
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 221

    (121) if_statement -> IF expr THEN statement ELSE statement .

    END             reduce using rule 121 (if_statement -> IF expr THEN statement ELSE statement .)
    ;               reduce using rule 121 (if_statement -> IF expr THEN statement ELSE statement .)
    ELSE            reduce using rule 121 (if_statement -> IF expr THEN statement ELSE statement .)


state 222

    (123) for_statement -> FOR ID ASSIGN expr TO expr . DO statement

    DO              shift and go to state 227


state 223

    (124) for_statement -> FOR ID ASSIGN expr DOWNTO expr . DO statement

    DO              shift and go to state 228


state 224

    (33) array_type -> ARRAY [ ordinal_type_list ] OF . tipo
    (26) tipo -> . ID
    (27) tipo -> . new_type
    (28) new_type -> . enumerated_type
    (29) new_type -> . subrange_type
    (30) new_type -> . array_type
    (31) enumerated_type -> . ( id_list )
    (32) subrange_type -> . constant DOTDOT constant
    (33) array_type -> . ARRAY [ ordinal_type_list ] OF tipo
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    ID              shift and go to state 111
    (               shift and go to state 116
    ARRAY           shift and go to state 118
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    +               shift and go to state 47
    -               shift and go to state 48

    tipo                           shift and go to state 229
    new_type                       shift and go to state 112
    enumerated_type                shift and go to state 113
    subrange_type                  shift and go to state 114
    array_type                     shift and go to state 115
    constant                       shift and go to state 117
    sign                           shift and go to state 42

state 225

    (38) ordinal_type_list -> ordinal_type_list , ordinal_type .

    ]               reduce using rule 38 (ordinal_type_list -> ordinal_type_list , ordinal_type .)
    ,               reduce using rule 38 (ordinal_type_list -> ordinal_type_list , ordinal_type .)


state 226

    (119) write_param -> expr : expr : expr .

    )               reduce using rule 119 (write_param -> expr : expr : expr .)
    ,               reduce using rule 119 (write_param -> expr : expr : expr .)


state 227

    (123) for_statement -> FOR ID ASSIGN expr TO expr DO . statement
    (93) statement -> .
    (94) statement -> . assignment_statement
    (95) statement -> . proc_statement
    (96) statement -> . read_statement
    (97) statement -> . write_statement
    (98) statement -> . labeled_statement
    (99) statement -> . compound_statement
    (100) statement -> . if_statement
    (101) statement -> . while_statement
    (102) statement -> . for_statement
    (103) assignment_statement -> . var_access ASSIGN expr
    (104) proc_statement -> . ID
    (105) proc_statement -> . ID ( expr_list )
    (107) read_statement -> . READ ( var_access_list )
    (108) read_statement -> . READLN
    (109) read_statement -> . READLN ( var_access_list )
    (112) write_statement -> . WRITE ( write_list )
    (113) write_statement -> . WRITELN
    (114) write_statement -> . WRITELN ( write_list )
    (106) labeled_statement -> . INT : statement
    (90) compound_statement -> . BEGIN statement_list END
    (120) if_statement -> . IF expr THEN statement
    (121) if_statement -> . IF expr THEN statement ELSE statement
    (122) while_statement -> . WHILE expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (124) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 93 (statement -> .)
    ;               reduce using rule 93 (statement -> .)
    ELSE            reduce using rule 93 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 230
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 228

    (124) for_statement -> FOR ID ASSIGN expr DOWNTO expr DO . statement
    (93) statement -> .
    (94) statement -> . assignment_statement
    (95) statement -> . proc_statement
    (96) statement -> . read_statement
    (97) statement -> . write_statement
    (98) statement -> . labeled_statement
    (99) statement -> . compound_statement
    (100) statement -> . if_statement
    (101) statement -> . while_statement
    (102) statement -> . for_statement
    (103) assignment_statement -> . var_access ASSIGN expr
    (104) proc_statement -> . ID
    (105) proc_statement -> . ID ( expr_list )
    (107) read_statement -> . READ ( var_access_list )
    (108) read_statement -> . READLN
    (109) read_statement -> . READLN ( var_access_list )
    (112) write_statement -> . WRITE ( write_list )
    (113) write_statement -> . WRITELN
    (114) write_statement -> . WRITELN ( write_list )
    (106) labeled_statement -> . INT : statement
    (90) compound_statement -> . BEGIN statement_list END
    (120) if_statement -> . IF expr THEN statement
    (121) if_statement -> . IF expr THEN statement ELSE statement
    (122) while_statement -> . WHILE expr DO statement
    (123) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (124) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 93 (statement -> .)
    ;               reduce using rule 93 (statement -> .)
    ELSE            reduce using rule 93 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 231
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 229

    (33) array_type -> ARRAY [ ordinal_type_list ] OF tipo .

    ;               reduce using rule 33 (array_type -> ARRAY [ ordinal_type_list ] OF tipo .)


state 230

    (123) for_statement -> FOR ID ASSIGN expr TO expr DO statement .

    END             reduce using rule 123 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)
    ;               reduce using rule 123 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)
    ELSE            reduce using rule 123 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)


state 231

    (124) for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .

    END             reduce using rule 124 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)
    ;               reduce using rule 124 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)
    ELSE            reduce using rule 124 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 185 resolved as shift
