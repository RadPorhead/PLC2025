Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program_heading ; block .
Rule 2     program_heading -> PROGRAM ID ( id_list )
Rule 3     program_heading -> PROGRAM ID
Rule 4     block -> const_part procfunc_part var_part compound_statement
Rule 5     const_part -> <empty>
Rule 6     const_part -> CONST const_list
Rule 7     const_list -> const_def ;
Rule 8     const_list -> const_list const_def ;
Rule 9     const_def -> ID = constant
Rule 10    constant -> sign INT
Rule 11    constant -> INT
Rule 12    constant -> sign REAL
Rule 13    constant -> REAL
Rule 14    constant -> CHAR
Rule 15    constant -> STRING
Rule 16    constant -> ID
Rule 17    sign -> +
Rule 18    sign -> -
Rule 19    var_part -> <empty>
Rule 20    var_part -> VAR var_list
Rule 21    var_list -> var_dec ;
Rule 22    var_list -> var_list var_dec ;
Rule 23    var_dec -> id_list : tipo
Rule 24    id_list -> ID
Rule 25    id_list -> ID , id_list
Rule 26    tipo -> ID
Rule 27    tipo -> new_type
Rule 28    new_type -> enumerated_type
Rule 29    new_type -> subrange_type
Rule 30    new_type -> array_type
Rule 31    enumerated_type -> ( id_list )
Rule 32    subrange_type -> constant DOTDOT constant
Rule 33    array_type -> ARRAY [ ordinal_type_list ] OF tipo
Rule 34    ordinal_type -> enumerated_type
Rule 35    ordinal_type -> subrange_type
Rule 36    ordinal_type -> ID
Rule 37    ordinal_type_list -> ordinal_type
Rule 38    ordinal_type_list -> ordinal_type_list , ordinal_type
Rule 39    procfunc_part -> <empty>
Rule 40    procfunc_part -> procfunc_part proc_dec
Rule 41    procfunc_part -> procfunc_part func_dec
Rule 42    proc_dec -> proc_heading ; block ;
Rule 43    func_dec -> func_heading ; block ;
Rule 44    proc_heading -> PROCEDURE ID
Rule 45    proc_heading -> PROCEDURE ID ( param_list )
Rule 46    func_heading -> FUNCTION ID : ID
Rule 47    func_heading -> FUNCTION ID ( param_list ) : ID
Rule 48    param_list -> param
Rule 49    param_list -> param_list ; param
Rule 50    param -> id_list : ID
Rule 51    param -> VAR id_list : ID
Rule 52    var_access -> ID var_suffix
Rule 53    var_suffix -> <empty>
Rule 54    var_suffix -> [ expr_list ] var_suffix
Rule 55    expr_list -> expr
Rule 56    expr_list -> expr_list , expr
Rule 57    expr -> simple_expr
Rule 58    expr -> simple_expr relation_op simple_expr
Rule 59    simple_expr -> term term_sequence
Rule 60    simple_expr -> sign term term_sequence
Rule 61    term -> factor factor_sequence
Rule 62    term_sequence -> <empty>
Rule 63    term_sequence -> add_op term term_sequence
Rule 64    factor_sequence -> <empty>
Rule 65    factor_sequence -> mul_op factor factor_sequence
Rule 66    factor -> var_access
Rule 67    factor -> INT
Rule 68    factor -> REAL
Rule 69    factor -> CHAR
Rule 70    factor -> STRING
Rule 71    factor -> ID ( expr_list )
Rule 72    factor -> ( expr )
Rule 73    factor -> NOT factor
Rule 74    add_op -> +
Rule 75    add_op -> -
Rule 76    add_op -> OR
Rule 77    mul_op -> *
Rule 78    mul_op -> /
Rule 79    mul_op -> DIV
Rule 80    mul_op -> MOD
Rule 81    mul_op -> AND
Rule 82    relation_op -> =
Rule 83    relation_op -> NE
Rule 84    relation_op -> LT
Rule 85    relation_op -> GT
Rule 86    relation_op -> LE
Rule 87    relation_op -> GE
Rule 88    compound_statement -> BEGIN statement_list END
Rule 89    statement_list -> statement
Rule 90    statement_list -> statement_list ; statement
Rule 91    statement -> <empty>
Rule 92    statement -> assignment_statement
Rule 93    statement -> proc_statement
Rule 94    statement -> read_statement
Rule 95    statement -> write_statement
Rule 96    statement -> labeled_statement
Rule 97    statement -> compound_statement
Rule 98    statement -> if_statement
Rule 99    statement -> while_statement
Rule 100   statement -> for_statement
Rule 101   assignment_statement -> var_access ASSIGN expr
Rule 102   proc_statement -> ID
Rule 103   proc_statement -> ID ( expr_list )
Rule 104   labeled_statement -> INT : statement
Rule 105   read_statement -> READ ( var_access_list )
Rule 106   read_statement -> READLN
Rule 107   read_statement -> READLN ( var_access_list )
Rule 108   var_access_list -> var_access
Rule 109   var_access_list -> var_access_list , var_access
Rule 110   write_statement -> WRITE ( write_list )
Rule 111   write_statement -> WRITELN
Rule 112   write_statement -> WRITELN ( write_list )
Rule 113   write_list -> write_param
Rule 114   write_list -> write_list , write_param
Rule 115   write_param -> expr
Rule 116   write_param -> expr : expr
Rule 117   write_param -> expr : expr : expr
Rule 118   if_statement -> IF expr THEN statement
Rule 119   if_statement -> IF expr THEN statement ELSE statement
Rule 120   while_statement -> WHILE expr DO statement
Rule 121   for_statement -> FOR ID ASSIGN expr TO expr DO statement
Rule 122   for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement

Terminals, with rules where they appear

(                    : 2 31 45 47 71 72 103 105 107 110 112
)                    : 2 31 45 47 71 72 103 105 107 110 112
*                    : 77
+                    : 17 74
,                    : 25 38 56 109 114
-                    : 18 75
.                    : 1
/                    : 78
:                    : 23 46 47 50 51 104 116 117 117
;                    : 1 7 8 21 22 42 42 43 43 49 90
=                    : 9 82
AND                  : 81
ARRAY                : 33
ASSIGN               : 101 121 122
BEGIN                : 88
CHAR                 : 14 69
CONST                : 6
DIV                  : 79
DO                   : 120 121 122
DOTDOT               : 32
DOWNTO               : 122
ELSE                 : 119
END                  : 88
FOR                  : 121 122
FUNCTION             : 46 47
GE                   : 87
GT                   : 85
ID                   : 2 3 9 16 24 25 26 36 44 45 46 46 47 47 50 51 52 71 102 103 121 122
IF                   : 118 119
INT                  : 10 11 67 104
LE                   : 86
LT                   : 84
MOD                  : 80
NE                   : 83
NOT                  : 73
OF                   : 33
OR                   : 76
PROCEDURE            : 44 45
PROGRAM              : 2 3
READ                 : 105
READLN               : 106 107
REAL                 : 12 13 68
STRING               : 15 70
THEN                 : 118 119
TO                   : 121
VAR                  : 20 51
WHILE                : 120
WRITE                : 110
WRITELN              : 111 112
[                    : 33 54
]                    : 33 54
error                : 

Nonterminals, with rules where they appear

add_op               : 63
array_type           : 30
assignment_statement : 92
block                : 1 42 43
compound_statement   : 4 97
const_def            : 7 8
const_list           : 6 8
const_part           : 4
constant             : 9 32 32
enumerated_type      : 28 34
expr                 : 55 56 72 101 115 116 116 117 117 117 118 119 120 121 121 122 122
expr_list            : 54 56 71 103
factor               : 61 65 73
factor_sequence      : 61 65
for_statement        : 100
func_dec             : 41
func_heading         : 43
id_list              : 2 23 25 31 50 51
if_statement         : 98
labeled_statement    : 96
mul_op               : 65
new_type             : 27
ordinal_type         : 37 38
ordinal_type_list    : 33 38
param                : 48 49
param_list           : 45 47 49
proc_dec             : 40
proc_heading         : 42
proc_statement       : 93
procfunc_part        : 4 40 41
program              : 0
program_heading      : 1
read_statement       : 94
relation_op          : 58
sign                 : 10 12 60
simple_expr          : 57 58 58
statement            : 89 90 104 118 119 119 120 121 122
statement_list       : 88 90
subrange_type        : 29 35
term                 : 59 60 63
term_sequence        : 59 60 63
tipo                 : 23 33
var_access           : 66 101 108 109
var_access_list      : 105 107 109
var_dec              : 21 22
var_list             : 20 22
var_part             : 4
var_suffix           : 52 54
while_statement      : 99
write_list           : 110 112 114
write_param          : 113 114
write_statement      : 95

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program_heading ; block .
    (2) program_heading -> . PROGRAM ID ( id_list )
    (3) program_heading -> . PROGRAM ID

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    program_heading                shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> program_heading . ; block .

    ;               shift and go to state 4


state 3

    (2) program_heading -> PROGRAM . ID ( id_list )
    (3) program_heading -> PROGRAM . ID

    ID              shift and go to state 5


state 4

    (1) program -> program_heading ; . block .
    (4) block -> . const_part procfunc_part var_part compound_statement
    (5) const_part -> .
    (6) const_part -> . CONST const_list

    VAR             reduce using rule 5 (const_part -> .)
    PROCEDURE       reduce using rule 5 (const_part -> .)
    FUNCTION        reduce using rule 5 (const_part -> .)
    BEGIN           reduce using rule 5 (const_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 6
    const_part                     shift and go to state 7

state 5

    (2) program_heading -> PROGRAM ID . ( id_list )
    (3) program_heading -> PROGRAM ID .

    (               shift and go to state 9
    ;               reduce using rule 3 (program_heading -> PROGRAM ID .)


state 6

    (1) program -> program_heading ; block . .

    .               shift and go to state 10


state 7

    (4) block -> const_part . procfunc_part var_part compound_statement
    (39) procfunc_part -> .
    (40) procfunc_part -> . procfunc_part proc_dec
    (41) procfunc_part -> . procfunc_part func_dec

    VAR             reduce using rule 39 (procfunc_part -> .)
    PROCEDURE       reduce using rule 39 (procfunc_part -> .)
    FUNCTION        reduce using rule 39 (procfunc_part -> .)
    BEGIN           reduce using rule 39 (procfunc_part -> .)

    procfunc_part                  shift and go to state 11

state 8

    (6) const_part -> CONST . const_list
    (7) const_list -> . const_def ;
    (8) const_list -> . const_list const_def ;
    (9) const_def -> . ID = constant

    ID              shift and go to state 14

    const_list                     shift and go to state 12
    const_def                      shift and go to state 13

state 9

    (2) program_heading -> PROGRAM ID ( . id_list )
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 16

state 10

    (1) program -> program_heading ; block . .

    $end            reduce using rule 1 (program -> program_heading ; block . .)


state 11

    (4) block -> const_part procfunc_part . var_part compound_statement
    (40) procfunc_part -> procfunc_part . proc_dec
    (41) procfunc_part -> procfunc_part . func_dec
    (19) var_part -> .
    (20) var_part -> . VAR var_list
    (42) proc_dec -> . proc_heading ; block ;
    (43) func_dec -> . func_heading ; block ;
    (44) proc_heading -> . PROCEDURE ID
    (45) proc_heading -> . PROCEDURE ID ( param_list )
    (46) func_heading -> . FUNCTION ID : ID
    (47) func_heading -> . FUNCTION ID ( param_list ) : ID

    BEGIN           reduce using rule 19 (var_part -> .)
    VAR             shift and go to state 20
    PROCEDURE       shift and go to state 23
    FUNCTION        shift and go to state 24

    var_part                       shift and go to state 17
    proc_dec                       shift and go to state 18
    func_dec                       shift and go to state 19
    proc_heading                   shift and go to state 21
    func_heading                   shift and go to state 22

state 12

    (6) const_part -> CONST const_list .
    (8) const_list -> const_list . const_def ;
    (9) const_def -> . ID = constant

    VAR             reduce using rule 6 (const_part -> CONST const_list .)
    PROCEDURE       reduce using rule 6 (const_part -> CONST const_list .)
    FUNCTION        reduce using rule 6 (const_part -> CONST const_list .)
    BEGIN           reduce using rule 6 (const_part -> CONST const_list .)
    ID              shift and go to state 14

    const_def                      shift and go to state 25

state 13

    (7) const_list -> const_def . ;

    ;               shift and go to state 26


state 14

    (9) const_def -> ID . = constant

    =               shift and go to state 27


state 15

    (24) id_list -> ID .
    (25) id_list -> ID . , id_list

    )               reduce using rule 24 (id_list -> ID .)
    :               reduce using rule 24 (id_list -> ID .)
    ,               shift and go to state 28


state 16

    (2) program_heading -> PROGRAM ID ( id_list . )

    )               shift and go to state 29


state 17

    (4) block -> const_part procfunc_part var_part . compound_statement
    (88) compound_statement -> . BEGIN statement_list END

    BEGIN           shift and go to state 31

    compound_statement             shift and go to state 30

state 18

    (40) procfunc_part -> procfunc_part proc_dec .

    VAR             reduce using rule 40 (procfunc_part -> procfunc_part proc_dec .)
    PROCEDURE       reduce using rule 40 (procfunc_part -> procfunc_part proc_dec .)
    FUNCTION        reduce using rule 40 (procfunc_part -> procfunc_part proc_dec .)
    BEGIN           reduce using rule 40 (procfunc_part -> procfunc_part proc_dec .)


state 19

    (41) procfunc_part -> procfunc_part func_dec .

    VAR             reduce using rule 41 (procfunc_part -> procfunc_part func_dec .)
    PROCEDURE       reduce using rule 41 (procfunc_part -> procfunc_part func_dec .)
    FUNCTION        reduce using rule 41 (procfunc_part -> procfunc_part func_dec .)
    BEGIN           reduce using rule 41 (procfunc_part -> procfunc_part func_dec .)


state 20

    (20) var_part -> VAR . var_list
    (21) var_list -> . var_dec ;
    (22) var_list -> . var_list var_dec ;
    (23) var_dec -> . id_list : tipo
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    var_list                       shift and go to state 32
    var_dec                        shift and go to state 33
    id_list                        shift and go to state 34

state 21

    (42) proc_dec -> proc_heading . ; block ;

    ;               shift and go to state 35


state 22

    (43) func_dec -> func_heading . ; block ;

    ;               shift and go to state 36


state 23

    (44) proc_heading -> PROCEDURE . ID
    (45) proc_heading -> PROCEDURE . ID ( param_list )

    ID              shift and go to state 37


state 24

    (46) func_heading -> FUNCTION . ID : ID
    (47) func_heading -> FUNCTION . ID ( param_list ) : ID

    ID              shift and go to state 38


state 25

    (8) const_list -> const_list const_def . ;

    ;               shift and go to state 39


state 26

    (7) const_list -> const_def ; .

    ID              reduce using rule 7 (const_list -> const_def ; .)
    VAR             reduce using rule 7 (const_list -> const_def ; .)
    PROCEDURE       reduce using rule 7 (const_list -> const_def ; .)
    FUNCTION        reduce using rule 7 (const_list -> const_def ; .)
    BEGIN           reduce using rule 7 (const_list -> const_def ; .)


state 27

    (9) const_def -> ID = . constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    ID              shift and go to state 40
    +               shift and go to state 47
    -               shift and go to state 48

    constant                       shift and go to state 41
    sign                           shift and go to state 42

state 28

    (25) id_list -> ID , . id_list
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 49

state 29

    (2) program_heading -> PROGRAM ID ( id_list ) .

    ;               reduce using rule 2 (program_heading -> PROGRAM ID ( id_list ) .)


state 30

    (4) block -> const_part procfunc_part var_part compound_statement .

    .               reduce using rule 4 (block -> const_part procfunc_part var_part compound_statement .)
    ;               reduce using rule 4 (block -> const_part procfunc_part var_part compound_statement .)


state 31

    (88) compound_statement -> BEGIN . statement_list END
    (89) statement_list -> . statement
    (90) statement_list -> . statement_list ; statement
    (91) statement -> .
    (92) statement -> . assignment_statement
    (93) statement -> . proc_statement
    (94) statement -> . read_statement
    (95) statement -> . write_statement
    (96) statement -> . labeled_statement
    (97) statement -> . compound_statement
    (98) statement -> . if_statement
    (99) statement -> . while_statement
    (100) statement -> . for_statement
    (101) assignment_statement -> . var_access ASSIGN expr
    (102) proc_statement -> . ID
    (103) proc_statement -> . ID ( expr_list )
    (105) read_statement -> . READ ( var_access_list )
    (106) read_statement -> . READLN
    (107) read_statement -> . READLN ( var_access_list )
    (110) write_statement -> . WRITE ( write_list )
    (111) write_statement -> . WRITELN
    (112) write_statement -> . WRITELN ( write_list )
    (104) labeled_statement -> . INT : statement
    (88) compound_statement -> . BEGIN statement_list END
    (118) if_statement -> . IF expr THEN statement
    (119) if_statement -> . IF expr THEN statement ELSE statement
    (120) while_statement -> . WHILE expr DO statement
    (121) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 91 (statement -> .)
    ;               reduce using rule 91 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement_list                 shift and go to state 50
    statement                      shift and go to state 51
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 32

    (20) var_part -> VAR var_list .
    (22) var_list -> var_list . var_dec ;
    (23) var_dec -> . id_list : tipo
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    BEGIN           reduce using rule 20 (var_part -> VAR var_list .)
    ID              shift and go to state 15

    var_dec                        shift and go to state 71
    id_list                        shift and go to state 34

state 33

    (21) var_list -> var_dec . ;

    ;               shift and go to state 72


state 34

    (23) var_dec -> id_list . : tipo

    :               shift and go to state 73


state 35

    (42) proc_dec -> proc_heading ; . block ;
    (4) block -> . const_part procfunc_part var_part compound_statement
    (5) const_part -> .
    (6) const_part -> . CONST const_list

    VAR             reduce using rule 5 (const_part -> .)
    PROCEDURE       reduce using rule 5 (const_part -> .)
    FUNCTION        reduce using rule 5 (const_part -> .)
    BEGIN           reduce using rule 5 (const_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 74
    const_part                     shift and go to state 7

state 36

    (43) func_dec -> func_heading ; . block ;
    (4) block -> . const_part procfunc_part var_part compound_statement
    (5) const_part -> .
    (6) const_part -> . CONST const_list

    VAR             reduce using rule 5 (const_part -> .)
    PROCEDURE       reduce using rule 5 (const_part -> .)
    FUNCTION        reduce using rule 5 (const_part -> .)
    BEGIN           reduce using rule 5 (const_part -> .)
    CONST           shift and go to state 8

    block                          shift and go to state 75
    const_part                     shift and go to state 7

state 37

    (44) proc_heading -> PROCEDURE ID .
    (45) proc_heading -> PROCEDURE ID . ( param_list )

    ;               reduce using rule 44 (proc_heading -> PROCEDURE ID .)
    (               shift and go to state 76


state 38

    (46) func_heading -> FUNCTION ID . : ID
    (47) func_heading -> FUNCTION ID . ( param_list ) : ID

    :               shift and go to state 77
    (               shift and go to state 78


state 39

    (8) const_list -> const_list const_def ; .

    ID              reduce using rule 8 (const_list -> const_list const_def ; .)
    VAR             reduce using rule 8 (const_list -> const_list const_def ; .)
    PROCEDURE       reduce using rule 8 (const_list -> const_list const_def ; .)
    FUNCTION        reduce using rule 8 (const_list -> const_list const_def ; .)
    BEGIN           reduce using rule 8 (const_list -> const_list const_def ; .)


state 40

    (16) constant -> ID .

    ;               reduce using rule 16 (constant -> ID .)
    ]               reduce using rule 16 (constant -> ID .)
    ,               reduce using rule 16 (constant -> ID .)


state 41

    (9) const_def -> ID = constant .

    ;               reduce using rule 9 (const_def -> ID = constant .)


state 42

    (10) constant -> sign . INT
    (12) constant -> sign . REAL

    INT             shift and go to state 79
    REAL            shift and go to state 80


state 43

    (11) constant -> INT .

    ;               reduce using rule 11 (constant -> INT .)
    DOTDOT          reduce using rule 11 (constant -> INT .)
    ]               reduce using rule 11 (constant -> INT .)
    ,               reduce using rule 11 (constant -> INT .)


state 44

    (13) constant -> REAL .

    ;               reduce using rule 13 (constant -> REAL .)
    DOTDOT          reduce using rule 13 (constant -> REAL .)
    ]               reduce using rule 13 (constant -> REAL .)
    ,               reduce using rule 13 (constant -> REAL .)


state 45

    (14) constant -> CHAR .

    ;               reduce using rule 14 (constant -> CHAR .)
    DOTDOT          reduce using rule 14 (constant -> CHAR .)
    ]               reduce using rule 14 (constant -> CHAR .)
    ,               reduce using rule 14 (constant -> CHAR .)


state 46

    (15) constant -> STRING .

    ;               reduce using rule 15 (constant -> STRING .)
    DOTDOT          reduce using rule 15 (constant -> STRING .)
    ]               reduce using rule 15 (constant -> STRING .)
    ,               reduce using rule 15 (constant -> STRING .)


state 47

    (17) sign -> + .

    INT             reduce using rule 17 (sign -> + .)
    REAL            reduce using rule 17 (sign -> + .)
    CHAR            reduce using rule 17 (sign -> + .)
    STRING          reduce using rule 17 (sign -> + .)
    ID              reduce using rule 17 (sign -> + .)
    (               reduce using rule 17 (sign -> + .)
    NOT             reduce using rule 17 (sign -> + .)


state 48

    (18) sign -> - .

    INT             reduce using rule 18 (sign -> - .)
    REAL            reduce using rule 18 (sign -> - .)
    CHAR            reduce using rule 18 (sign -> - .)
    STRING          reduce using rule 18 (sign -> - .)
    ID              reduce using rule 18 (sign -> - .)
    (               reduce using rule 18 (sign -> - .)
    NOT             reduce using rule 18 (sign -> - .)


state 49

    (25) id_list -> ID , id_list .

    )               reduce using rule 25 (id_list -> ID , id_list .)
    :               reduce using rule 25 (id_list -> ID , id_list .)


state 50

    (88) compound_statement -> BEGIN statement_list . END
    (90) statement_list -> statement_list . ; statement

    END             shift and go to state 81
    ;               shift and go to state 82


state 51

    (89) statement_list -> statement .

    END             reduce using rule 89 (statement_list -> statement .)
    ;               reduce using rule 89 (statement_list -> statement .)


state 52

    (92) statement -> assignment_statement .

    END             reduce using rule 92 (statement -> assignment_statement .)
    ;               reduce using rule 92 (statement -> assignment_statement .)
    ELSE            reduce using rule 92 (statement -> assignment_statement .)


state 53

    (93) statement -> proc_statement .

    END             reduce using rule 93 (statement -> proc_statement .)
    ;               reduce using rule 93 (statement -> proc_statement .)
    ELSE            reduce using rule 93 (statement -> proc_statement .)


state 54

    (94) statement -> read_statement .

    END             reduce using rule 94 (statement -> read_statement .)
    ;               reduce using rule 94 (statement -> read_statement .)
    ELSE            reduce using rule 94 (statement -> read_statement .)


state 55

    (95) statement -> write_statement .

    END             reduce using rule 95 (statement -> write_statement .)
    ;               reduce using rule 95 (statement -> write_statement .)
    ELSE            reduce using rule 95 (statement -> write_statement .)


state 56

    (96) statement -> labeled_statement .

    END             reduce using rule 96 (statement -> labeled_statement .)
    ;               reduce using rule 96 (statement -> labeled_statement .)
    ELSE            reduce using rule 96 (statement -> labeled_statement .)


state 57

    (97) statement -> compound_statement .

    END             reduce using rule 97 (statement -> compound_statement .)
    ;               reduce using rule 97 (statement -> compound_statement .)
    ELSE            reduce using rule 97 (statement -> compound_statement .)


state 58

    (98) statement -> if_statement .

    END             reduce using rule 98 (statement -> if_statement .)
    ;               reduce using rule 98 (statement -> if_statement .)
    ELSE            reduce using rule 98 (statement -> if_statement .)


state 59

    (99) statement -> while_statement .

    END             reduce using rule 99 (statement -> while_statement .)
    ;               reduce using rule 99 (statement -> while_statement .)
    ELSE            reduce using rule 99 (statement -> while_statement .)


state 60

    (100) statement -> for_statement .

    END             reduce using rule 100 (statement -> for_statement .)
    ;               reduce using rule 100 (statement -> for_statement .)
    ELSE            reduce using rule 100 (statement -> for_statement .)


state 61

    (101) assignment_statement -> var_access . ASSIGN expr

    ASSIGN          shift and go to state 83


state 62

    (102) proc_statement -> ID .
    (103) proc_statement -> ID . ( expr_list )
    (52) var_access -> ID . var_suffix
    (53) var_suffix -> .
    (54) var_suffix -> . [ expr_list ] var_suffix

    END             reduce using rule 102 (proc_statement -> ID .)
    ;               reduce using rule 102 (proc_statement -> ID .)
    ELSE            reduce using rule 102 (proc_statement -> ID .)
    (               shift and go to state 84
    ASSIGN          reduce using rule 53 (var_suffix -> .)
    [               shift and go to state 86

    var_suffix                     shift and go to state 85

state 63

    (105) read_statement -> READ . ( var_access_list )

    (               shift and go to state 87


state 64

    (106) read_statement -> READLN .
    (107) read_statement -> READLN . ( var_access_list )

    END             reduce using rule 106 (read_statement -> READLN .)
    ;               reduce using rule 106 (read_statement -> READLN .)
    ELSE            reduce using rule 106 (read_statement -> READLN .)
    (               shift and go to state 88


state 65

    (110) write_statement -> WRITE . ( write_list )

    (               shift and go to state 89


state 66

    (111) write_statement -> WRITELN .
    (112) write_statement -> WRITELN . ( write_list )

    END             reduce using rule 111 (write_statement -> WRITELN .)
    ;               reduce using rule 111 (write_statement -> WRITELN .)
    ELSE            reduce using rule 111 (write_statement -> WRITELN .)
    (               shift and go to state 90


state 67

    (104) labeled_statement -> INT . : statement

    :               shift and go to state 91


state 68

    (118) if_statement -> IF . expr THEN statement
    (119) if_statement -> IF . expr THEN statement ELSE statement
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    expr                           shift and go to state 92
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 69

    (120) while_statement -> WHILE . expr DO statement
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    expr                           shift and go to state 105
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 70

    (121) for_statement -> FOR . ID ASSIGN expr TO expr DO statement
    (122) for_statement -> FOR . ID ASSIGN expr DOWNTO expr DO statement

    ID              shift and go to state 106


state 71

    (22) var_list -> var_list var_dec . ;

    ;               shift and go to state 107


state 72

    (21) var_list -> var_dec ; .

    ID              reduce using rule 21 (var_list -> var_dec ; .)
    BEGIN           reduce using rule 21 (var_list -> var_dec ; .)


state 73

    (23) var_dec -> id_list : . tipo
    (26) tipo -> . ID
    (27) tipo -> . new_type
    (28) new_type -> . enumerated_type
    (29) new_type -> . subrange_type
    (30) new_type -> . array_type
    (31) enumerated_type -> . ( id_list )
    (32) subrange_type -> . constant DOTDOT constant
    (33) array_type -> . ARRAY [ ordinal_type_list ] OF tipo
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    ID              shift and go to state 109
    (               shift and go to state 114
    ARRAY           shift and go to state 116
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    +               shift and go to state 47
    -               shift and go to state 48

    tipo                           shift and go to state 108
    new_type                       shift and go to state 110
    enumerated_type                shift and go to state 111
    subrange_type                  shift and go to state 112
    array_type                     shift and go to state 113
    constant                       shift and go to state 115
    sign                           shift and go to state 42

state 74

    (42) proc_dec -> proc_heading ; block . ;

    ;               shift and go to state 117


state 75

    (43) func_dec -> func_heading ; block . ;

    ;               shift and go to state 118


state 76

    (45) proc_heading -> PROCEDURE ID ( . param_list )
    (48) param_list -> . param
    (49) param_list -> . param_list ; param
    (50) param -> . id_list : ID
    (51) param -> . VAR id_list : ID
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    VAR             shift and go to state 122
    ID              shift and go to state 15

    param_list                     shift and go to state 119
    param                          shift and go to state 120
    id_list                        shift and go to state 121

state 77

    (46) func_heading -> FUNCTION ID : . ID

    ID              shift and go to state 123


state 78

    (47) func_heading -> FUNCTION ID ( . param_list ) : ID
    (48) param_list -> . param
    (49) param_list -> . param_list ; param
    (50) param -> . id_list : ID
    (51) param -> . VAR id_list : ID
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    VAR             shift and go to state 122
    ID              shift and go to state 15

    param_list                     shift and go to state 124
    param                          shift and go to state 120
    id_list                        shift and go to state 121

state 79

    (10) constant -> sign INT .

    ;               reduce using rule 10 (constant -> sign INT .)
    DOTDOT          reduce using rule 10 (constant -> sign INT .)
    ]               reduce using rule 10 (constant -> sign INT .)
    ,               reduce using rule 10 (constant -> sign INT .)


state 80

    (12) constant -> sign REAL .

    ;               reduce using rule 12 (constant -> sign REAL .)
    DOTDOT          reduce using rule 12 (constant -> sign REAL .)
    ]               reduce using rule 12 (constant -> sign REAL .)
    ,               reduce using rule 12 (constant -> sign REAL .)


state 81

    (88) compound_statement -> BEGIN statement_list END .

    .               reduce using rule 88 (compound_statement -> BEGIN statement_list END .)
    ;               reduce using rule 88 (compound_statement -> BEGIN statement_list END .)
    END             reduce using rule 88 (compound_statement -> BEGIN statement_list END .)
    ELSE            reduce using rule 88 (compound_statement -> BEGIN statement_list END .)


state 82

    (90) statement_list -> statement_list ; . statement
    (91) statement -> .
    (92) statement -> . assignment_statement
    (93) statement -> . proc_statement
    (94) statement -> . read_statement
    (95) statement -> . write_statement
    (96) statement -> . labeled_statement
    (97) statement -> . compound_statement
    (98) statement -> . if_statement
    (99) statement -> . while_statement
    (100) statement -> . for_statement
    (101) assignment_statement -> . var_access ASSIGN expr
    (102) proc_statement -> . ID
    (103) proc_statement -> . ID ( expr_list )
    (105) read_statement -> . READ ( var_access_list )
    (106) read_statement -> . READLN
    (107) read_statement -> . READLN ( var_access_list )
    (110) write_statement -> . WRITE ( write_list )
    (111) write_statement -> . WRITELN
    (112) write_statement -> . WRITELN ( write_list )
    (104) labeled_statement -> . INT : statement
    (88) compound_statement -> . BEGIN statement_list END
    (118) if_statement -> . IF expr THEN statement
    (119) if_statement -> . IF expr THEN statement ELSE statement
    (120) while_statement -> . WHILE expr DO statement
    (121) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 91 (statement -> .)
    ;               reduce using rule 91 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 125
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 83

    (101) assignment_statement -> var_access ASSIGN . expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    var_access                     shift and go to state 97
    expr                           shift and go to state 126
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96

state 84

    (103) proc_statement -> ID ( . expr_list )
    (55) expr_list -> . expr
    (56) expr_list -> . expr_list , expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    expr_list                      shift and go to state 127
    expr                           shift and go to state 128
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 85

    (52) var_access -> ID var_suffix .

    ASSIGN          reduce using rule 52 (var_access -> ID var_suffix .)
    *               reduce using rule 52 (var_access -> ID var_suffix .)
    /               reduce using rule 52 (var_access -> ID var_suffix .)
    DIV             reduce using rule 52 (var_access -> ID var_suffix .)
    MOD             reduce using rule 52 (var_access -> ID var_suffix .)
    AND             reduce using rule 52 (var_access -> ID var_suffix .)
    +               reduce using rule 52 (var_access -> ID var_suffix .)
    -               reduce using rule 52 (var_access -> ID var_suffix .)
    OR              reduce using rule 52 (var_access -> ID var_suffix .)
    =               reduce using rule 52 (var_access -> ID var_suffix .)
    NE              reduce using rule 52 (var_access -> ID var_suffix .)
    LT              reduce using rule 52 (var_access -> ID var_suffix .)
    GT              reduce using rule 52 (var_access -> ID var_suffix .)
    LE              reduce using rule 52 (var_access -> ID var_suffix .)
    GE              reduce using rule 52 (var_access -> ID var_suffix .)
    THEN            reduce using rule 52 (var_access -> ID var_suffix .)
    DO              reduce using rule 52 (var_access -> ID var_suffix .)
    END             reduce using rule 52 (var_access -> ID var_suffix .)
    ;               reduce using rule 52 (var_access -> ID var_suffix .)
    ELSE            reduce using rule 52 (var_access -> ID var_suffix .)
    )               reduce using rule 52 (var_access -> ID var_suffix .)
    ,               reduce using rule 52 (var_access -> ID var_suffix .)
    ]               reduce using rule 52 (var_access -> ID var_suffix .)
    :               reduce using rule 52 (var_access -> ID var_suffix .)
    TO              reduce using rule 52 (var_access -> ID var_suffix .)
    DOWNTO          reduce using rule 52 (var_access -> ID var_suffix .)


state 86

    (54) var_suffix -> [ . expr_list ] var_suffix
    (55) expr_list -> . expr
    (56) expr_list -> . expr_list , expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    expr_list                      shift and go to state 129
    expr                           shift and go to state 128
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 87

    (105) read_statement -> READ ( . var_access_list )
    (108) var_access_list -> . var_access
    (109) var_access_list -> . var_access_list , var_access
    (52) var_access -> . ID var_suffix

    ID              shift and go to state 132

    var_access_list                shift and go to state 130
    var_access                     shift and go to state 131

state 88

    (107) read_statement -> READLN ( . var_access_list )
    (108) var_access_list -> . var_access
    (109) var_access_list -> . var_access_list , var_access
    (52) var_access -> . ID var_suffix

    ID              shift and go to state 132

    var_access_list                shift and go to state 133
    var_access                     shift and go to state 131

state 89

    (110) write_statement -> WRITE ( . write_list )
    (113) write_list -> . write_param
    (114) write_list -> . write_list , write_param
    (115) write_param -> . expr
    (116) write_param -> . expr : expr
    (117) write_param -> . expr : expr : expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    write_list                     shift and go to state 134
    write_param                    shift and go to state 135
    expr                           shift and go to state 136
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 90

    (112) write_statement -> WRITELN ( . write_list )
    (113) write_list -> . write_param
    (114) write_list -> . write_list , write_param
    (115) write_param -> . expr
    (116) write_param -> . expr : expr
    (117) write_param -> . expr : expr : expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    write_list                     shift and go to state 137
    write_param                    shift and go to state 135
    expr                           shift and go to state 136
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 91

    (104) labeled_statement -> INT : . statement
    (91) statement -> .
    (92) statement -> . assignment_statement
    (93) statement -> . proc_statement
    (94) statement -> . read_statement
    (95) statement -> . write_statement
    (96) statement -> . labeled_statement
    (97) statement -> . compound_statement
    (98) statement -> . if_statement
    (99) statement -> . while_statement
    (100) statement -> . for_statement
    (101) assignment_statement -> . var_access ASSIGN expr
    (102) proc_statement -> . ID
    (103) proc_statement -> . ID ( expr_list )
    (105) read_statement -> . READ ( var_access_list )
    (106) read_statement -> . READLN
    (107) read_statement -> . READLN ( var_access_list )
    (110) write_statement -> . WRITE ( write_list )
    (111) write_statement -> . WRITELN
    (112) write_statement -> . WRITELN ( write_list )
    (104) labeled_statement -> . INT : statement
    (88) compound_statement -> . BEGIN statement_list END
    (118) if_statement -> . IF expr THEN statement
    (119) if_statement -> . IF expr THEN statement ELSE statement
    (120) while_statement -> . WHILE expr DO statement
    (121) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 91 (statement -> .)
    ;               reduce using rule 91 (statement -> .)
    ELSE            reduce using rule 91 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 138
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 92

    (118) if_statement -> IF expr . THEN statement
    (119) if_statement -> IF expr . THEN statement ELSE statement

    THEN            shift and go to state 139


state 93

    (57) expr -> simple_expr .
    (58) expr -> simple_expr . relation_op simple_expr
    (82) relation_op -> . =
    (83) relation_op -> . NE
    (84) relation_op -> . LT
    (85) relation_op -> . GT
    (86) relation_op -> . LE
    (87) relation_op -> . GE

    THEN            reduce using rule 57 (expr -> simple_expr .)
    DO              reduce using rule 57 (expr -> simple_expr .)
    END             reduce using rule 57 (expr -> simple_expr .)
    ;               reduce using rule 57 (expr -> simple_expr .)
    ELSE            reduce using rule 57 (expr -> simple_expr .)
    )               reduce using rule 57 (expr -> simple_expr .)
    ,               reduce using rule 57 (expr -> simple_expr .)
    ]               reduce using rule 57 (expr -> simple_expr .)
    :               reduce using rule 57 (expr -> simple_expr .)
    TO              reduce using rule 57 (expr -> simple_expr .)
    DOWNTO          reduce using rule 57 (expr -> simple_expr .)
    =               shift and go to state 141
    NE              shift and go to state 142
    LT              shift and go to state 143
    GT              shift and go to state 144
    LE              shift and go to state 145
    GE              shift and go to state 146

    relation_op                    shift and go to state 140

state 94

    (59) simple_expr -> term . term_sequence
    (62) term_sequence -> .
    (63) term_sequence -> . add_op term term_sequence
    (74) add_op -> . +
    (75) add_op -> . -
    (76) add_op -> . OR

    =               reduce using rule 62 (term_sequence -> .)
    NE              reduce using rule 62 (term_sequence -> .)
    LT              reduce using rule 62 (term_sequence -> .)
    GT              reduce using rule 62 (term_sequence -> .)
    LE              reduce using rule 62 (term_sequence -> .)
    GE              reduce using rule 62 (term_sequence -> .)
    THEN            reduce using rule 62 (term_sequence -> .)
    DO              reduce using rule 62 (term_sequence -> .)
    END             reduce using rule 62 (term_sequence -> .)
    ;               reduce using rule 62 (term_sequence -> .)
    ELSE            reduce using rule 62 (term_sequence -> .)
    )               reduce using rule 62 (term_sequence -> .)
    ,               reduce using rule 62 (term_sequence -> .)
    ]               reduce using rule 62 (term_sequence -> .)
    :               reduce using rule 62 (term_sequence -> .)
    TO              reduce using rule 62 (term_sequence -> .)
    DOWNTO          reduce using rule 62 (term_sequence -> .)
    +               shift and go to state 149
    -               shift and go to state 150
    OR              shift and go to state 151

    term_sequence                  shift and go to state 147
    add_op                         shift and go to state 148

state 95

    (60) simple_expr -> sign . term term_sequence
    (61) term -> . factor factor_sequence
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    term                           shift and go to state 152
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 96

    (61) term -> factor . factor_sequence
    (64) factor_sequence -> .
    (65) factor_sequence -> . mul_op factor factor_sequence
    (77) mul_op -> . *
    (78) mul_op -> . /
    (79) mul_op -> . DIV
    (80) mul_op -> . MOD
    (81) mul_op -> . AND

    +               reduce using rule 64 (factor_sequence -> .)
    -               reduce using rule 64 (factor_sequence -> .)
    OR              reduce using rule 64 (factor_sequence -> .)
    =               reduce using rule 64 (factor_sequence -> .)
    NE              reduce using rule 64 (factor_sequence -> .)
    LT              reduce using rule 64 (factor_sequence -> .)
    GT              reduce using rule 64 (factor_sequence -> .)
    LE              reduce using rule 64 (factor_sequence -> .)
    GE              reduce using rule 64 (factor_sequence -> .)
    THEN            reduce using rule 64 (factor_sequence -> .)
    DO              reduce using rule 64 (factor_sequence -> .)
    END             reduce using rule 64 (factor_sequence -> .)
    ;               reduce using rule 64 (factor_sequence -> .)
    ELSE            reduce using rule 64 (factor_sequence -> .)
    )               reduce using rule 64 (factor_sequence -> .)
    ,               reduce using rule 64 (factor_sequence -> .)
    ]               reduce using rule 64 (factor_sequence -> .)
    :               reduce using rule 64 (factor_sequence -> .)
    TO              reduce using rule 64 (factor_sequence -> .)
    DOWNTO          reduce using rule 64 (factor_sequence -> .)
    *               shift and go to state 155
    /               shift and go to state 156
    DIV             shift and go to state 157
    MOD             shift and go to state 158
    AND             shift and go to state 159

    factor_sequence                shift and go to state 153
    mul_op                         shift and go to state 154

state 97

    (66) factor -> var_access .

    *               reduce using rule 66 (factor -> var_access .)
    /               reduce using rule 66 (factor -> var_access .)
    DIV             reduce using rule 66 (factor -> var_access .)
    MOD             reduce using rule 66 (factor -> var_access .)
    AND             reduce using rule 66 (factor -> var_access .)
    +               reduce using rule 66 (factor -> var_access .)
    -               reduce using rule 66 (factor -> var_access .)
    OR              reduce using rule 66 (factor -> var_access .)
    =               reduce using rule 66 (factor -> var_access .)
    NE              reduce using rule 66 (factor -> var_access .)
    LT              reduce using rule 66 (factor -> var_access .)
    GT              reduce using rule 66 (factor -> var_access .)
    LE              reduce using rule 66 (factor -> var_access .)
    GE              reduce using rule 66 (factor -> var_access .)
    THEN            reduce using rule 66 (factor -> var_access .)
    DO              reduce using rule 66 (factor -> var_access .)
    END             reduce using rule 66 (factor -> var_access .)
    ;               reduce using rule 66 (factor -> var_access .)
    ELSE            reduce using rule 66 (factor -> var_access .)
    )               reduce using rule 66 (factor -> var_access .)
    ,               reduce using rule 66 (factor -> var_access .)
    ]               reduce using rule 66 (factor -> var_access .)
    :               reduce using rule 66 (factor -> var_access .)
    TO              reduce using rule 66 (factor -> var_access .)
    DOWNTO          reduce using rule 66 (factor -> var_access .)


state 98

    (67) factor -> INT .

    *               reduce using rule 67 (factor -> INT .)
    /               reduce using rule 67 (factor -> INT .)
    DIV             reduce using rule 67 (factor -> INT .)
    MOD             reduce using rule 67 (factor -> INT .)
    AND             reduce using rule 67 (factor -> INT .)
    +               reduce using rule 67 (factor -> INT .)
    -               reduce using rule 67 (factor -> INT .)
    OR              reduce using rule 67 (factor -> INT .)
    =               reduce using rule 67 (factor -> INT .)
    NE              reduce using rule 67 (factor -> INT .)
    LT              reduce using rule 67 (factor -> INT .)
    GT              reduce using rule 67 (factor -> INT .)
    LE              reduce using rule 67 (factor -> INT .)
    GE              reduce using rule 67 (factor -> INT .)
    THEN            reduce using rule 67 (factor -> INT .)
    DO              reduce using rule 67 (factor -> INT .)
    END             reduce using rule 67 (factor -> INT .)
    ;               reduce using rule 67 (factor -> INT .)
    ELSE            reduce using rule 67 (factor -> INT .)
    )               reduce using rule 67 (factor -> INT .)
    ,               reduce using rule 67 (factor -> INT .)
    ]               reduce using rule 67 (factor -> INT .)
    :               reduce using rule 67 (factor -> INT .)
    TO              reduce using rule 67 (factor -> INT .)
    DOWNTO          reduce using rule 67 (factor -> INT .)


state 99

    (68) factor -> REAL .

    *               reduce using rule 68 (factor -> REAL .)
    /               reduce using rule 68 (factor -> REAL .)
    DIV             reduce using rule 68 (factor -> REAL .)
    MOD             reduce using rule 68 (factor -> REAL .)
    AND             reduce using rule 68 (factor -> REAL .)
    +               reduce using rule 68 (factor -> REAL .)
    -               reduce using rule 68 (factor -> REAL .)
    OR              reduce using rule 68 (factor -> REAL .)
    =               reduce using rule 68 (factor -> REAL .)
    NE              reduce using rule 68 (factor -> REAL .)
    LT              reduce using rule 68 (factor -> REAL .)
    GT              reduce using rule 68 (factor -> REAL .)
    LE              reduce using rule 68 (factor -> REAL .)
    GE              reduce using rule 68 (factor -> REAL .)
    THEN            reduce using rule 68 (factor -> REAL .)
    DO              reduce using rule 68 (factor -> REAL .)
    END             reduce using rule 68 (factor -> REAL .)
    ;               reduce using rule 68 (factor -> REAL .)
    ELSE            reduce using rule 68 (factor -> REAL .)
    )               reduce using rule 68 (factor -> REAL .)
    ,               reduce using rule 68 (factor -> REAL .)
    ]               reduce using rule 68 (factor -> REAL .)
    :               reduce using rule 68 (factor -> REAL .)
    TO              reduce using rule 68 (factor -> REAL .)
    DOWNTO          reduce using rule 68 (factor -> REAL .)


state 100

    (69) factor -> CHAR .

    *               reduce using rule 69 (factor -> CHAR .)
    /               reduce using rule 69 (factor -> CHAR .)
    DIV             reduce using rule 69 (factor -> CHAR .)
    MOD             reduce using rule 69 (factor -> CHAR .)
    AND             reduce using rule 69 (factor -> CHAR .)
    +               reduce using rule 69 (factor -> CHAR .)
    -               reduce using rule 69 (factor -> CHAR .)
    OR              reduce using rule 69 (factor -> CHAR .)
    =               reduce using rule 69 (factor -> CHAR .)
    NE              reduce using rule 69 (factor -> CHAR .)
    LT              reduce using rule 69 (factor -> CHAR .)
    GT              reduce using rule 69 (factor -> CHAR .)
    LE              reduce using rule 69 (factor -> CHAR .)
    GE              reduce using rule 69 (factor -> CHAR .)
    THEN            reduce using rule 69 (factor -> CHAR .)
    DO              reduce using rule 69 (factor -> CHAR .)
    END             reduce using rule 69 (factor -> CHAR .)
    ;               reduce using rule 69 (factor -> CHAR .)
    ELSE            reduce using rule 69 (factor -> CHAR .)
    )               reduce using rule 69 (factor -> CHAR .)
    ,               reduce using rule 69 (factor -> CHAR .)
    ]               reduce using rule 69 (factor -> CHAR .)
    :               reduce using rule 69 (factor -> CHAR .)
    TO              reduce using rule 69 (factor -> CHAR .)
    DOWNTO          reduce using rule 69 (factor -> CHAR .)


state 101

    (70) factor -> STRING .

    *               reduce using rule 70 (factor -> STRING .)
    /               reduce using rule 70 (factor -> STRING .)
    DIV             reduce using rule 70 (factor -> STRING .)
    MOD             reduce using rule 70 (factor -> STRING .)
    AND             reduce using rule 70 (factor -> STRING .)
    +               reduce using rule 70 (factor -> STRING .)
    -               reduce using rule 70 (factor -> STRING .)
    OR              reduce using rule 70 (factor -> STRING .)
    =               reduce using rule 70 (factor -> STRING .)
    NE              reduce using rule 70 (factor -> STRING .)
    LT              reduce using rule 70 (factor -> STRING .)
    GT              reduce using rule 70 (factor -> STRING .)
    LE              reduce using rule 70 (factor -> STRING .)
    GE              reduce using rule 70 (factor -> STRING .)
    THEN            reduce using rule 70 (factor -> STRING .)
    DO              reduce using rule 70 (factor -> STRING .)
    END             reduce using rule 70 (factor -> STRING .)
    ;               reduce using rule 70 (factor -> STRING .)
    ELSE            reduce using rule 70 (factor -> STRING .)
    )               reduce using rule 70 (factor -> STRING .)
    ,               reduce using rule 70 (factor -> STRING .)
    ]               reduce using rule 70 (factor -> STRING .)
    :               reduce using rule 70 (factor -> STRING .)
    TO              reduce using rule 70 (factor -> STRING .)
    DOWNTO          reduce using rule 70 (factor -> STRING .)


state 102

    (71) factor -> ID . ( expr_list )
    (52) var_access -> ID . var_suffix
    (53) var_suffix -> .
    (54) var_suffix -> . [ expr_list ] var_suffix

    (               shift and go to state 160
    *               reduce using rule 53 (var_suffix -> .)
    /               reduce using rule 53 (var_suffix -> .)
    DIV             reduce using rule 53 (var_suffix -> .)
    MOD             reduce using rule 53 (var_suffix -> .)
    AND             reduce using rule 53 (var_suffix -> .)
    +               reduce using rule 53 (var_suffix -> .)
    -               reduce using rule 53 (var_suffix -> .)
    OR              reduce using rule 53 (var_suffix -> .)
    =               reduce using rule 53 (var_suffix -> .)
    NE              reduce using rule 53 (var_suffix -> .)
    LT              reduce using rule 53 (var_suffix -> .)
    GT              reduce using rule 53 (var_suffix -> .)
    LE              reduce using rule 53 (var_suffix -> .)
    GE              reduce using rule 53 (var_suffix -> .)
    THEN            reduce using rule 53 (var_suffix -> .)
    DO              reduce using rule 53 (var_suffix -> .)
    END             reduce using rule 53 (var_suffix -> .)
    ;               reduce using rule 53 (var_suffix -> .)
    ELSE            reduce using rule 53 (var_suffix -> .)
    )               reduce using rule 53 (var_suffix -> .)
    ,               reduce using rule 53 (var_suffix -> .)
    ]               reduce using rule 53 (var_suffix -> .)
    :               reduce using rule 53 (var_suffix -> .)
    TO              reduce using rule 53 (var_suffix -> .)
    DOWNTO          reduce using rule 53 (var_suffix -> .)
    [               shift and go to state 86

    var_suffix                     shift and go to state 85

state 103

    (72) factor -> ( . expr )
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    expr                           shift and go to state 161
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 104

    (73) factor -> NOT . factor
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    factor                         shift and go to state 162
    var_access                     shift and go to state 97

state 105

    (120) while_statement -> WHILE expr . DO statement

    DO              shift and go to state 163


state 106

    (121) for_statement -> FOR ID . ASSIGN expr TO expr DO statement
    (122) for_statement -> FOR ID . ASSIGN expr DOWNTO expr DO statement

    ASSIGN          shift and go to state 164


state 107

    (22) var_list -> var_list var_dec ; .

    ID              reduce using rule 22 (var_list -> var_list var_dec ; .)
    BEGIN           reduce using rule 22 (var_list -> var_list var_dec ; .)


state 108

    (23) var_dec -> id_list : tipo .

    ;               reduce using rule 23 (var_dec -> id_list : tipo .)


state 109

    (26) tipo -> ID .
    (16) constant -> ID .

    ;               reduce using rule 26 (tipo -> ID .)
    DOTDOT          reduce using rule 16 (constant -> ID .)


state 110

    (27) tipo -> new_type .

    ;               reduce using rule 27 (tipo -> new_type .)


state 111

    (28) new_type -> enumerated_type .

    ;               reduce using rule 28 (new_type -> enumerated_type .)


state 112

    (29) new_type -> subrange_type .

    ;               reduce using rule 29 (new_type -> subrange_type .)


state 113

    (30) new_type -> array_type .

    ;               reduce using rule 30 (new_type -> array_type .)


state 114

    (31) enumerated_type -> ( . id_list )
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 165

state 115

    (32) subrange_type -> constant . DOTDOT constant

    DOTDOT          shift and go to state 166


state 116

    (33) array_type -> ARRAY . [ ordinal_type_list ] OF tipo

    [               shift and go to state 167


state 117

    (42) proc_dec -> proc_heading ; block ; .

    VAR             reduce using rule 42 (proc_dec -> proc_heading ; block ; .)
    PROCEDURE       reduce using rule 42 (proc_dec -> proc_heading ; block ; .)
    FUNCTION        reduce using rule 42 (proc_dec -> proc_heading ; block ; .)
    BEGIN           reduce using rule 42 (proc_dec -> proc_heading ; block ; .)


state 118

    (43) func_dec -> func_heading ; block ; .

    VAR             reduce using rule 43 (func_dec -> func_heading ; block ; .)
    PROCEDURE       reduce using rule 43 (func_dec -> func_heading ; block ; .)
    FUNCTION        reduce using rule 43 (func_dec -> func_heading ; block ; .)
    BEGIN           reduce using rule 43 (func_dec -> func_heading ; block ; .)


state 119

    (45) proc_heading -> PROCEDURE ID ( param_list . )
    (49) param_list -> param_list . ; param

    )               shift and go to state 168
    ;               shift and go to state 169


state 120

    (48) param_list -> param .

    )               reduce using rule 48 (param_list -> param .)
    ;               reduce using rule 48 (param_list -> param .)


state 121

    (50) param -> id_list . : ID

    :               shift and go to state 170


state 122

    (51) param -> VAR . id_list : ID
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 171

state 123

    (46) func_heading -> FUNCTION ID : ID .

    ;               reduce using rule 46 (func_heading -> FUNCTION ID : ID .)


state 124

    (47) func_heading -> FUNCTION ID ( param_list . ) : ID
    (49) param_list -> param_list . ; param

    )               shift and go to state 172
    ;               shift and go to state 169


state 125

    (90) statement_list -> statement_list ; statement .

    END             reduce using rule 90 (statement_list -> statement_list ; statement .)
    ;               reduce using rule 90 (statement_list -> statement_list ; statement .)


state 126

    (101) assignment_statement -> var_access ASSIGN expr .

    END             reduce using rule 101 (assignment_statement -> var_access ASSIGN expr .)
    ;               reduce using rule 101 (assignment_statement -> var_access ASSIGN expr .)
    ELSE            reduce using rule 101 (assignment_statement -> var_access ASSIGN expr .)


state 127

    (103) proc_statement -> ID ( expr_list . )
    (56) expr_list -> expr_list . , expr

    )               shift and go to state 173
    ,               shift and go to state 174


state 128

    (55) expr_list -> expr .

    )               reduce using rule 55 (expr_list -> expr .)
    ,               reduce using rule 55 (expr_list -> expr .)
    ]               reduce using rule 55 (expr_list -> expr .)


state 129

    (54) var_suffix -> [ expr_list . ] var_suffix
    (56) expr_list -> expr_list . , expr

    ]               shift and go to state 175
    ,               shift and go to state 174


state 130

    (105) read_statement -> READ ( var_access_list . )
    (109) var_access_list -> var_access_list . , var_access

    )               shift and go to state 176
    ,               shift and go to state 177


state 131

    (108) var_access_list -> var_access .

    )               reduce using rule 108 (var_access_list -> var_access .)
    ,               reduce using rule 108 (var_access_list -> var_access .)


state 132

    (52) var_access -> ID . var_suffix
    (53) var_suffix -> .
    (54) var_suffix -> . [ expr_list ] var_suffix

    )               reduce using rule 53 (var_suffix -> .)
    ,               reduce using rule 53 (var_suffix -> .)
    [               shift and go to state 86

    var_suffix                     shift and go to state 85

state 133

    (107) read_statement -> READLN ( var_access_list . )
    (109) var_access_list -> var_access_list . , var_access

    )               shift and go to state 178
    ,               shift and go to state 177


state 134

    (110) write_statement -> WRITE ( write_list . )
    (114) write_list -> write_list . , write_param

    )               shift and go to state 179
    ,               shift and go to state 180


state 135

    (113) write_list -> write_param .

    )               reduce using rule 113 (write_list -> write_param .)
    ,               reduce using rule 113 (write_list -> write_param .)


state 136

    (115) write_param -> expr .
    (116) write_param -> expr . : expr
    (117) write_param -> expr . : expr : expr

    )               reduce using rule 115 (write_param -> expr .)
    ,               reduce using rule 115 (write_param -> expr .)
    :               shift and go to state 181


state 137

    (112) write_statement -> WRITELN ( write_list . )
    (114) write_list -> write_list . , write_param

    )               shift and go to state 182
    ,               shift and go to state 180


state 138

    (104) labeled_statement -> INT : statement .

    END             reduce using rule 104 (labeled_statement -> INT : statement .)
    ;               reduce using rule 104 (labeled_statement -> INT : statement .)
    ELSE            reduce using rule 104 (labeled_statement -> INT : statement .)


state 139

    (118) if_statement -> IF expr THEN . statement
    (119) if_statement -> IF expr THEN . statement ELSE statement
    (91) statement -> .
    (92) statement -> . assignment_statement
    (93) statement -> . proc_statement
    (94) statement -> . read_statement
    (95) statement -> . write_statement
    (96) statement -> . labeled_statement
    (97) statement -> . compound_statement
    (98) statement -> . if_statement
    (99) statement -> . while_statement
    (100) statement -> . for_statement
    (101) assignment_statement -> . var_access ASSIGN expr
    (102) proc_statement -> . ID
    (103) proc_statement -> . ID ( expr_list )
    (105) read_statement -> . READ ( var_access_list )
    (106) read_statement -> . READLN
    (107) read_statement -> . READLN ( var_access_list )
    (110) write_statement -> . WRITE ( write_list )
    (111) write_statement -> . WRITELN
    (112) write_statement -> . WRITELN ( write_list )
    (104) labeled_statement -> . INT : statement
    (88) compound_statement -> . BEGIN statement_list END
    (118) if_statement -> . IF expr THEN statement
    (119) if_statement -> . IF expr THEN statement ELSE statement
    (120) while_statement -> . WHILE expr DO statement
    (121) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 91 (statement -> .)
    ;               reduce using rule 91 (statement -> .)
    ELSE            reduce using rule 91 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 183
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 140

    (58) expr -> simple_expr relation_op . simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    simple_expr                    shift and go to state 184
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 141

    (82) relation_op -> = .

    +               reduce using rule 82 (relation_op -> = .)
    -               reduce using rule 82 (relation_op -> = .)
    INT             reduce using rule 82 (relation_op -> = .)
    REAL            reduce using rule 82 (relation_op -> = .)
    CHAR            reduce using rule 82 (relation_op -> = .)
    STRING          reduce using rule 82 (relation_op -> = .)
    ID              reduce using rule 82 (relation_op -> = .)
    (               reduce using rule 82 (relation_op -> = .)
    NOT             reduce using rule 82 (relation_op -> = .)


state 142

    (83) relation_op -> NE .

    +               reduce using rule 83 (relation_op -> NE .)
    -               reduce using rule 83 (relation_op -> NE .)
    INT             reduce using rule 83 (relation_op -> NE .)
    REAL            reduce using rule 83 (relation_op -> NE .)
    CHAR            reduce using rule 83 (relation_op -> NE .)
    STRING          reduce using rule 83 (relation_op -> NE .)
    ID              reduce using rule 83 (relation_op -> NE .)
    (               reduce using rule 83 (relation_op -> NE .)
    NOT             reduce using rule 83 (relation_op -> NE .)


state 143

    (84) relation_op -> LT .

    +               reduce using rule 84 (relation_op -> LT .)
    -               reduce using rule 84 (relation_op -> LT .)
    INT             reduce using rule 84 (relation_op -> LT .)
    REAL            reduce using rule 84 (relation_op -> LT .)
    CHAR            reduce using rule 84 (relation_op -> LT .)
    STRING          reduce using rule 84 (relation_op -> LT .)
    ID              reduce using rule 84 (relation_op -> LT .)
    (               reduce using rule 84 (relation_op -> LT .)
    NOT             reduce using rule 84 (relation_op -> LT .)


state 144

    (85) relation_op -> GT .

    +               reduce using rule 85 (relation_op -> GT .)
    -               reduce using rule 85 (relation_op -> GT .)
    INT             reduce using rule 85 (relation_op -> GT .)
    REAL            reduce using rule 85 (relation_op -> GT .)
    CHAR            reduce using rule 85 (relation_op -> GT .)
    STRING          reduce using rule 85 (relation_op -> GT .)
    ID              reduce using rule 85 (relation_op -> GT .)
    (               reduce using rule 85 (relation_op -> GT .)
    NOT             reduce using rule 85 (relation_op -> GT .)


state 145

    (86) relation_op -> LE .

    +               reduce using rule 86 (relation_op -> LE .)
    -               reduce using rule 86 (relation_op -> LE .)
    INT             reduce using rule 86 (relation_op -> LE .)
    REAL            reduce using rule 86 (relation_op -> LE .)
    CHAR            reduce using rule 86 (relation_op -> LE .)
    STRING          reduce using rule 86 (relation_op -> LE .)
    ID              reduce using rule 86 (relation_op -> LE .)
    (               reduce using rule 86 (relation_op -> LE .)
    NOT             reduce using rule 86 (relation_op -> LE .)


state 146

    (87) relation_op -> GE .

    +               reduce using rule 87 (relation_op -> GE .)
    -               reduce using rule 87 (relation_op -> GE .)
    INT             reduce using rule 87 (relation_op -> GE .)
    REAL            reduce using rule 87 (relation_op -> GE .)
    CHAR            reduce using rule 87 (relation_op -> GE .)
    STRING          reduce using rule 87 (relation_op -> GE .)
    ID              reduce using rule 87 (relation_op -> GE .)
    (               reduce using rule 87 (relation_op -> GE .)
    NOT             reduce using rule 87 (relation_op -> GE .)


state 147

    (59) simple_expr -> term term_sequence .

    =               reduce using rule 59 (simple_expr -> term term_sequence .)
    NE              reduce using rule 59 (simple_expr -> term term_sequence .)
    LT              reduce using rule 59 (simple_expr -> term term_sequence .)
    GT              reduce using rule 59 (simple_expr -> term term_sequence .)
    LE              reduce using rule 59 (simple_expr -> term term_sequence .)
    GE              reduce using rule 59 (simple_expr -> term term_sequence .)
    THEN            reduce using rule 59 (simple_expr -> term term_sequence .)
    DO              reduce using rule 59 (simple_expr -> term term_sequence .)
    END             reduce using rule 59 (simple_expr -> term term_sequence .)
    ;               reduce using rule 59 (simple_expr -> term term_sequence .)
    ELSE            reduce using rule 59 (simple_expr -> term term_sequence .)
    )               reduce using rule 59 (simple_expr -> term term_sequence .)
    ,               reduce using rule 59 (simple_expr -> term term_sequence .)
    ]               reduce using rule 59 (simple_expr -> term term_sequence .)
    :               reduce using rule 59 (simple_expr -> term term_sequence .)
    TO              reduce using rule 59 (simple_expr -> term term_sequence .)
    DOWNTO          reduce using rule 59 (simple_expr -> term term_sequence .)


state 148

    (63) term_sequence -> add_op . term term_sequence
    (61) term -> . factor factor_sequence
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    term                           shift and go to state 185
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 149

    (74) add_op -> + .

    INT             reduce using rule 74 (add_op -> + .)
    REAL            reduce using rule 74 (add_op -> + .)
    CHAR            reduce using rule 74 (add_op -> + .)
    STRING          reduce using rule 74 (add_op -> + .)
    ID              reduce using rule 74 (add_op -> + .)
    (               reduce using rule 74 (add_op -> + .)
    NOT             reduce using rule 74 (add_op -> + .)


state 150

    (75) add_op -> - .

    INT             reduce using rule 75 (add_op -> - .)
    REAL            reduce using rule 75 (add_op -> - .)
    CHAR            reduce using rule 75 (add_op -> - .)
    STRING          reduce using rule 75 (add_op -> - .)
    ID              reduce using rule 75 (add_op -> - .)
    (               reduce using rule 75 (add_op -> - .)
    NOT             reduce using rule 75 (add_op -> - .)


state 151

    (76) add_op -> OR .

    INT             reduce using rule 76 (add_op -> OR .)
    REAL            reduce using rule 76 (add_op -> OR .)
    CHAR            reduce using rule 76 (add_op -> OR .)
    STRING          reduce using rule 76 (add_op -> OR .)
    ID              reduce using rule 76 (add_op -> OR .)
    (               reduce using rule 76 (add_op -> OR .)
    NOT             reduce using rule 76 (add_op -> OR .)


state 152

    (60) simple_expr -> sign term . term_sequence
    (62) term_sequence -> .
    (63) term_sequence -> . add_op term term_sequence
    (74) add_op -> . +
    (75) add_op -> . -
    (76) add_op -> . OR

    =               reduce using rule 62 (term_sequence -> .)
    NE              reduce using rule 62 (term_sequence -> .)
    LT              reduce using rule 62 (term_sequence -> .)
    GT              reduce using rule 62 (term_sequence -> .)
    LE              reduce using rule 62 (term_sequence -> .)
    GE              reduce using rule 62 (term_sequence -> .)
    THEN            reduce using rule 62 (term_sequence -> .)
    DO              reduce using rule 62 (term_sequence -> .)
    END             reduce using rule 62 (term_sequence -> .)
    ;               reduce using rule 62 (term_sequence -> .)
    ELSE            reduce using rule 62 (term_sequence -> .)
    )               reduce using rule 62 (term_sequence -> .)
    ,               reduce using rule 62 (term_sequence -> .)
    ]               reduce using rule 62 (term_sequence -> .)
    :               reduce using rule 62 (term_sequence -> .)
    TO              reduce using rule 62 (term_sequence -> .)
    DOWNTO          reduce using rule 62 (term_sequence -> .)
    +               shift and go to state 149
    -               shift and go to state 150
    OR              shift and go to state 151

    term_sequence                  shift and go to state 186
    add_op                         shift and go to state 148

state 153

    (61) term -> factor factor_sequence .

    +               reduce using rule 61 (term -> factor factor_sequence .)
    -               reduce using rule 61 (term -> factor factor_sequence .)
    OR              reduce using rule 61 (term -> factor factor_sequence .)
    =               reduce using rule 61 (term -> factor factor_sequence .)
    NE              reduce using rule 61 (term -> factor factor_sequence .)
    LT              reduce using rule 61 (term -> factor factor_sequence .)
    GT              reduce using rule 61 (term -> factor factor_sequence .)
    LE              reduce using rule 61 (term -> factor factor_sequence .)
    GE              reduce using rule 61 (term -> factor factor_sequence .)
    THEN            reduce using rule 61 (term -> factor factor_sequence .)
    DO              reduce using rule 61 (term -> factor factor_sequence .)
    END             reduce using rule 61 (term -> factor factor_sequence .)
    ;               reduce using rule 61 (term -> factor factor_sequence .)
    ELSE            reduce using rule 61 (term -> factor factor_sequence .)
    )               reduce using rule 61 (term -> factor factor_sequence .)
    ,               reduce using rule 61 (term -> factor factor_sequence .)
    ]               reduce using rule 61 (term -> factor factor_sequence .)
    :               reduce using rule 61 (term -> factor factor_sequence .)
    TO              reduce using rule 61 (term -> factor factor_sequence .)
    DOWNTO          reduce using rule 61 (term -> factor factor_sequence .)


state 154

    (65) factor_sequence -> mul_op . factor factor_sequence
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    factor                         shift and go to state 187
    var_access                     shift and go to state 97

state 155

    (77) mul_op -> * .

    INT             reduce using rule 77 (mul_op -> * .)
    REAL            reduce using rule 77 (mul_op -> * .)
    CHAR            reduce using rule 77 (mul_op -> * .)
    STRING          reduce using rule 77 (mul_op -> * .)
    ID              reduce using rule 77 (mul_op -> * .)
    (               reduce using rule 77 (mul_op -> * .)
    NOT             reduce using rule 77 (mul_op -> * .)


state 156

    (78) mul_op -> / .

    INT             reduce using rule 78 (mul_op -> / .)
    REAL            reduce using rule 78 (mul_op -> / .)
    CHAR            reduce using rule 78 (mul_op -> / .)
    STRING          reduce using rule 78 (mul_op -> / .)
    ID              reduce using rule 78 (mul_op -> / .)
    (               reduce using rule 78 (mul_op -> / .)
    NOT             reduce using rule 78 (mul_op -> / .)


state 157

    (79) mul_op -> DIV .

    INT             reduce using rule 79 (mul_op -> DIV .)
    REAL            reduce using rule 79 (mul_op -> DIV .)
    CHAR            reduce using rule 79 (mul_op -> DIV .)
    STRING          reduce using rule 79 (mul_op -> DIV .)
    ID              reduce using rule 79 (mul_op -> DIV .)
    (               reduce using rule 79 (mul_op -> DIV .)
    NOT             reduce using rule 79 (mul_op -> DIV .)


state 158

    (80) mul_op -> MOD .

    INT             reduce using rule 80 (mul_op -> MOD .)
    REAL            reduce using rule 80 (mul_op -> MOD .)
    CHAR            reduce using rule 80 (mul_op -> MOD .)
    STRING          reduce using rule 80 (mul_op -> MOD .)
    ID              reduce using rule 80 (mul_op -> MOD .)
    (               reduce using rule 80 (mul_op -> MOD .)
    NOT             reduce using rule 80 (mul_op -> MOD .)


state 159

    (81) mul_op -> AND .

    INT             reduce using rule 81 (mul_op -> AND .)
    REAL            reduce using rule 81 (mul_op -> AND .)
    CHAR            reduce using rule 81 (mul_op -> AND .)
    STRING          reduce using rule 81 (mul_op -> AND .)
    ID              reduce using rule 81 (mul_op -> AND .)
    (               reduce using rule 81 (mul_op -> AND .)
    NOT             reduce using rule 81 (mul_op -> AND .)


state 160

    (71) factor -> ID ( . expr_list )
    (55) expr_list -> . expr
    (56) expr_list -> . expr_list , expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    expr_list                      shift and go to state 188
    expr                           shift and go to state 128
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 161

    (72) factor -> ( expr . )

    )               shift and go to state 189


state 162

    (73) factor -> NOT factor .

    *               reduce using rule 73 (factor -> NOT factor .)
    /               reduce using rule 73 (factor -> NOT factor .)
    DIV             reduce using rule 73 (factor -> NOT factor .)
    MOD             reduce using rule 73 (factor -> NOT factor .)
    AND             reduce using rule 73 (factor -> NOT factor .)
    +               reduce using rule 73 (factor -> NOT factor .)
    -               reduce using rule 73 (factor -> NOT factor .)
    OR              reduce using rule 73 (factor -> NOT factor .)
    =               reduce using rule 73 (factor -> NOT factor .)
    NE              reduce using rule 73 (factor -> NOT factor .)
    LT              reduce using rule 73 (factor -> NOT factor .)
    GT              reduce using rule 73 (factor -> NOT factor .)
    LE              reduce using rule 73 (factor -> NOT factor .)
    GE              reduce using rule 73 (factor -> NOT factor .)
    THEN            reduce using rule 73 (factor -> NOT factor .)
    DO              reduce using rule 73 (factor -> NOT factor .)
    END             reduce using rule 73 (factor -> NOT factor .)
    ;               reduce using rule 73 (factor -> NOT factor .)
    ELSE            reduce using rule 73 (factor -> NOT factor .)
    )               reduce using rule 73 (factor -> NOT factor .)
    ,               reduce using rule 73 (factor -> NOT factor .)
    ]               reduce using rule 73 (factor -> NOT factor .)
    :               reduce using rule 73 (factor -> NOT factor .)
    TO              reduce using rule 73 (factor -> NOT factor .)
    DOWNTO          reduce using rule 73 (factor -> NOT factor .)


state 163

    (120) while_statement -> WHILE expr DO . statement
    (91) statement -> .
    (92) statement -> . assignment_statement
    (93) statement -> . proc_statement
    (94) statement -> . read_statement
    (95) statement -> . write_statement
    (96) statement -> . labeled_statement
    (97) statement -> . compound_statement
    (98) statement -> . if_statement
    (99) statement -> . while_statement
    (100) statement -> . for_statement
    (101) assignment_statement -> . var_access ASSIGN expr
    (102) proc_statement -> . ID
    (103) proc_statement -> . ID ( expr_list )
    (105) read_statement -> . READ ( var_access_list )
    (106) read_statement -> . READLN
    (107) read_statement -> . READLN ( var_access_list )
    (110) write_statement -> . WRITE ( write_list )
    (111) write_statement -> . WRITELN
    (112) write_statement -> . WRITELN ( write_list )
    (104) labeled_statement -> . INT : statement
    (88) compound_statement -> . BEGIN statement_list END
    (118) if_statement -> . IF expr THEN statement
    (119) if_statement -> . IF expr THEN statement ELSE statement
    (120) while_statement -> . WHILE expr DO statement
    (121) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 91 (statement -> .)
    ;               reduce using rule 91 (statement -> .)
    ELSE            reduce using rule 91 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 190
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 164

    (121) for_statement -> FOR ID ASSIGN . expr TO expr DO statement
    (122) for_statement -> FOR ID ASSIGN . expr DOWNTO expr DO statement
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    expr                           shift and go to state 191
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 165

    (31) enumerated_type -> ( id_list . )

    )               shift and go to state 192


state 166

    (32) subrange_type -> constant DOTDOT . constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    ID              shift and go to state 40
    +               shift and go to state 47
    -               shift and go to state 48

    constant                       shift and go to state 193
    sign                           shift and go to state 42

state 167

    (33) array_type -> ARRAY [ . ordinal_type_list ] OF tipo
    (37) ordinal_type_list -> . ordinal_type
    (38) ordinal_type_list -> . ordinal_type_list , ordinal_type
    (34) ordinal_type -> . enumerated_type
    (35) ordinal_type -> . subrange_type
    (36) ordinal_type -> . ID
    (31) enumerated_type -> . ( id_list )
    (32) subrange_type -> . constant DOTDOT constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    ID              shift and go to state 198
    (               shift and go to state 114
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    +               shift and go to state 47
    -               shift and go to state 48

    ordinal_type_list              shift and go to state 194
    ordinal_type                   shift and go to state 195
    enumerated_type                shift and go to state 196
    subrange_type                  shift and go to state 197
    constant                       shift and go to state 115
    sign                           shift and go to state 42

state 168

    (45) proc_heading -> PROCEDURE ID ( param_list ) .

    ;               reduce using rule 45 (proc_heading -> PROCEDURE ID ( param_list ) .)


state 169

    (49) param_list -> param_list ; . param
    (50) param -> . id_list : ID
    (51) param -> . VAR id_list : ID
    (24) id_list -> . ID
    (25) id_list -> . ID , id_list

    VAR             shift and go to state 122
    ID              shift and go to state 15

    param                          shift and go to state 199
    id_list                        shift and go to state 121

state 170

    (50) param -> id_list : . ID

    ID              shift and go to state 200


state 171

    (51) param -> VAR id_list . : ID

    :               shift and go to state 201


state 172

    (47) func_heading -> FUNCTION ID ( param_list ) . : ID

    :               shift and go to state 202


state 173

    (103) proc_statement -> ID ( expr_list ) .

    END             reduce using rule 103 (proc_statement -> ID ( expr_list ) .)
    ;               reduce using rule 103 (proc_statement -> ID ( expr_list ) .)
    ELSE            reduce using rule 103 (proc_statement -> ID ( expr_list ) .)


state 174

    (56) expr_list -> expr_list , . expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    expr                           shift and go to state 203
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 175

    (54) var_suffix -> [ expr_list ] . var_suffix
    (53) var_suffix -> .
    (54) var_suffix -> . [ expr_list ] var_suffix

    ASSIGN          reduce using rule 53 (var_suffix -> .)
    *               reduce using rule 53 (var_suffix -> .)
    /               reduce using rule 53 (var_suffix -> .)
    DIV             reduce using rule 53 (var_suffix -> .)
    MOD             reduce using rule 53 (var_suffix -> .)
    AND             reduce using rule 53 (var_suffix -> .)
    +               reduce using rule 53 (var_suffix -> .)
    -               reduce using rule 53 (var_suffix -> .)
    OR              reduce using rule 53 (var_suffix -> .)
    =               reduce using rule 53 (var_suffix -> .)
    NE              reduce using rule 53 (var_suffix -> .)
    LT              reduce using rule 53 (var_suffix -> .)
    GT              reduce using rule 53 (var_suffix -> .)
    LE              reduce using rule 53 (var_suffix -> .)
    GE              reduce using rule 53 (var_suffix -> .)
    THEN            reduce using rule 53 (var_suffix -> .)
    DO              reduce using rule 53 (var_suffix -> .)
    END             reduce using rule 53 (var_suffix -> .)
    ;               reduce using rule 53 (var_suffix -> .)
    ELSE            reduce using rule 53 (var_suffix -> .)
    )               reduce using rule 53 (var_suffix -> .)
    ,               reduce using rule 53 (var_suffix -> .)
    ]               reduce using rule 53 (var_suffix -> .)
    :               reduce using rule 53 (var_suffix -> .)
    TO              reduce using rule 53 (var_suffix -> .)
    DOWNTO          reduce using rule 53 (var_suffix -> .)
    [               shift and go to state 86

    var_suffix                     shift and go to state 204

state 176

    (105) read_statement -> READ ( var_access_list ) .

    END             reduce using rule 105 (read_statement -> READ ( var_access_list ) .)
    ;               reduce using rule 105 (read_statement -> READ ( var_access_list ) .)
    ELSE            reduce using rule 105 (read_statement -> READ ( var_access_list ) .)


state 177

    (109) var_access_list -> var_access_list , . var_access
    (52) var_access -> . ID var_suffix

    ID              shift and go to state 132

    var_access                     shift and go to state 205

state 178

    (107) read_statement -> READLN ( var_access_list ) .

    END             reduce using rule 107 (read_statement -> READLN ( var_access_list ) .)
    ;               reduce using rule 107 (read_statement -> READLN ( var_access_list ) .)
    ELSE            reduce using rule 107 (read_statement -> READLN ( var_access_list ) .)


state 179

    (110) write_statement -> WRITE ( write_list ) .

    END             reduce using rule 110 (write_statement -> WRITE ( write_list ) .)
    ;               reduce using rule 110 (write_statement -> WRITE ( write_list ) .)
    ELSE            reduce using rule 110 (write_statement -> WRITE ( write_list ) .)


state 180

    (114) write_list -> write_list , . write_param
    (115) write_param -> . expr
    (116) write_param -> . expr : expr
    (117) write_param -> . expr : expr : expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    write_param                    shift and go to state 206
    expr                           shift and go to state 136
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 181

    (116) write_param -> expr : . expr
    (117) write_param -> expr : . expr : expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    expr                           shift and go to state 207
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 182

    (112) write_statement -> WRITELN ( write_list ) .

    END             reduce using rule 112 (write_statement -> WRITELN ( write_list ) .)
    ;               reduce using rule 112 (write_statement -> WRITELN ( write_list ) .)
    ELSE            reduce using rule 112 (write_statement -> WRITELN ( write_list ) .)


state 183

    (118) if_statement -> IF expr THEN statement .
    (119) if_statement -> IF expr THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    END             reduce using rule 118 (if_statement -> IF expr THEN statement .)
    ;               reduce using rule 118 (if_statement -> IF expr THEN statement .)
    ELSE            shift and go to state 208

  ! ELSE            [ reduce using rule 118 (if_statement -> IF expr THEN statement .) ]


state 184

    (58) expr -> simple_expr relation_op simple_expr .

    THEN            reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    DO              reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    END             reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    ;               reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    ELSE            reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    )               reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    ,               reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    ]               reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    :               reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    TO              reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)
    DOWNTO          reduce using rule 58 (expr -> simple_expr relation_op simple_expr .)


state 185

    (63) term_sequence -> add_op term . term_sequence
    (62) term_sequence -> .
    (63) term_sequence -> . add_op term term_sequence
    (74) add_op -> . +
    (75) add_op -> . -
    (76) add_op -> . OR

    =               reduce using rule 62 (term_sequence -> .)
    NE              reduce using rule 62 (term_sequence -> .)
    LT              reduce using rule 62 (term_sequence -> .)
    GT              reduce using rule 62 (term_sequence -> .)
    LE              reduce using rule 62 (term_sequence -> .)
    GE              reduce using rule 62 (term_sequence -> .)
    THEN            reduce using rule 62 (term_sequence -> .)
    DO              reduce using rule 62 (term_sequence -> .)
    END             reduce using rule 62 (term_sequence -> .)
    ;               reduce using rule 62 (term_sequence -> .)
    ELSE            reduce using rule 62 (term_sequence -> .)
    )               reduce using rule 62 (term_sequence -> .)
    ,               reduce using rule 62 (term_sequence -> .)
    ]               reduce using rule 62 (term_sequence -> .)
    :               reduce using rule 62 (term_sequence -> .)
    TO              reduce using rule 62 (term_sequence -> .)
    DOWNTO          reduce using rule 62 (term_sequence -> .)
    +               shift and go to state 149
    -               shift and go to state 150
    OR              shift and go to state 151

    add_op                         shift and go to state 148
    term_sequence                  shift and go to state 209

state 186

    (60) simple_expr -> sign term term_sequence .

    =               reduce using rule 60 (simple_expr -> sign term term_sequence .)
    NE              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    LT              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    GT              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    LE              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    GE              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    THEN            reduce using rule 60 (simple_expr -> sign term term_sequence .)
    DO              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    END             reduce using rule 60 (simple_expr -> sign term term_sequence .)
    ;               reduce using rule 60 (simple_expr -> sign term term_sequence .)
    ELSE            reduce using rule 60 (simple_expr -> sign term term_sequence .)
    )               reduce using rule 60 (simple_expr -> sign term term_sequence .)
    ,               reduce using rule 60 (simple_expr -> sign term term_sequence .)
    ]               reduce using rule 60 (simple_expr -> sign term term_sequence .)
    :               reduce using rule 60 (simple_expr -> sign term term_sequence .)
    TO              reduce using rule 60 (simple_expr -> sign term term_sequence .)
    DOWNTO          reduce using rule 60 (simple_expr -> sign term term_sequence .)


state 187

    (65) factor_sequence -> mul_op factor . factor_sequence
    (64) factor_sequence -> .
    (65) factor_sequence -> . mul_op factor factor_sequence
    (77) mul_op -> . *
    (78) mul_op -> . /
    (79) mul_op -> . DIV
    (80) mul_op -> . MOD
    (81) mul_op -> . AND

    +               reduce using rule 64 (factor_sequence -> .)
    -               reduce using rule 64 (factor_sequence -> .)
    OR              reduce using rule 64 (factor_sequence -> .)
    =               reduce using rule 64 (factor_sequence -> .)
    NE              reduce using rule 64 (factor_sequence -> .)
    LT              reduce using rule 64 (factor_sequence -> .)
    GT              reduce using rule 64 (factor_sequence -> .)
    LE              reduce using rule 64 (factor_sequence -> .)
    GE              reduce using rule 64 (factor_sequence -> .)
    THEN            reduce using rule 64 (factor_sequence -> .)
    DO              reduce using rule 64 (factor_sequence -> .)
    END             reduce using rule 64 (factor_sequence -> .)
    ;               reduce using rule 64 (factor_sequence -> .)
    ELSE            reduce using rule 64 (factor_sequence -> .)
    )               reduce using rule 64 (factor_sequence -> .)
    ,               reduce using rule 64 (factor_sequence -> .)
    ]               reduce using rule 64 (factor_sequence -> .)
    :               reduce using rule 64 (factor_sequence -> .)
    TO              reduce using rule 64 (factor_sequence -> .)
    DOWNTO          reduce using rule 64 (factor_sequence -> .)
    *               shift and go to state 155
    /               shift and go to state 156
    DIV             shift and go to state 157
    MOD             shift and go to state 158
    AND             shift and go to state 159

    mul_op                         shift and go to state 154
    factor_sequence                shift and go to state 210

state 188

    (71) factor -> ID ( expr_list . )
    (56) expr_list -> expr_list . , expr

    )               shift and go to state 211
    ,               shift and go to state 174


state 189

    (72) factor -> ( expr ) .

    *               reduce using rule 72 (factor -> ( expr ) .)
    /               reduce using rule 72 (factor -> ( expr ) .)
    DIV             reduce using rule 72 (factor -> ( expr ) .)
    MOD             reduce using rule 72 (factor -> ( expr ) .)
    AND             reduce using rule 72 (factor -> ( expr ) .)
    +               reduce using rule 72 (factor -> ( expr ) .)
    -               reduce using rule 72 (factor -> ( expr ) .)
    OR              reduce using rule 72 (factor -> ( expr ) .)
    =               reduce using rule 72 (factor -> ( expr ) .)
    NE              reduce using rule 72 (factor -> ( expr ) .)
    LT              reduce using rule 72 (factor -> ( expr ) .)
    GT              reduce using rule 72 (factor -> ( expr ) .)
    LE              reduce using rule 72 (factor -> ( expr ) .)
    GE              reduce using rule 72 (factor -> ( expr ) .)
    THEN            reduce using rule 72 (factor -> ( expr ) .)
    DO              reduce using rule 72 (factor -> ( expr ) .)
    END             reduce using rule 72 (factor -> ( expr ) .)
    ;               reduce using rule 72 (factor -> ( expr ) .)
    ELSE            reduce using rule 72 (factor -> ( expr ) .)
    )               reduce using rule 72 (factor -> ( expr ) .)
    ,               reduce using rule 72 (factor -> ( expr ) .)
    ]               reduce using rule 72 (factor -> ( expr ) .)
    :               reduce using rule 72 (factor -> ( expr ) .)
    TO              reduce using rule 72 (factor -> ( expr ) .)
    DOWNTO          reduce using rule 72 (factor -> ( expr ) .)


state 190

    (120) while_statement -> WHILE expr DO statement .

    END             reduce using rule 120 (while_statement -> WHILE expr DO statement .)
    ;               reduce using rule 120 (while_statement -> WHILE expr DO statement .)
    ELSE            reduce using rule 120 (while_statement -> WHILE expr DO statement .)


state 191

    (121) for_statement -> FOR ID ASSIGN expr . TO expr DO statement
    (122) for_statement -> FOR ID ASSIGN expr . DOWNTO expr DO statement

    TO              shift and go to state 212
    DOWNTO          shift and go to state 213


state 192

    (31) enumerated_type -> ( id_list ) .

    ;               reduce using rule 31 (enumerated_type -> ( id_list ) .)
    ]               reduce using rule 31 (enumerated_type -> ( id_list ) .)
    ,               reduce using rule 31 (enumerated_type -> ( id_list ) .)


state 193

    (32) subrange_type -> constant DOTDOT constant .

    ;               reduce using rule 32 (subrange_type -> constant DOTDOT constant .)
    ]               reduce using rule 32 (subrange_type -> constant DOTDOT constant .)
    ,               reduce using rule 32 (subrange_type -> constant DOTDOT constant .)


state 194

    (33) array_type -> ARRAY [ ordinal_type_list . ] OF tipo
    (38) ordinal_type_list -> ordinal_type_list . , ordinal_type

    ]               shift and go to state 214
    ,               shift and go to state 215


state 195

    (37) ordinal_type_list -> ordinal_type .

    ]               reduce using rule 37 (ordinal_type_list -> ordinal_type .)
    ,               reduce using rule 37 (ordinal_type_list -> ordinal_type .)


state 196

    (34) ordinal_type -> enumerated_type .

    ]               reduce using rule 34 (ordinal_type -> enumerated_type .)
    ,               reduce using rule 34 (ordinal_type -> enumerated_type .)


state 197

    (35) ordinal_type -> subrange_type .

    ]               reduce using rule 35 (ordinal_type -> subrange_type .)
    ,               reduce using rule 35 (ordinal_type -> subrange_type .)


state 198

    (36) ordinal_type -> ID .
    (16) constant -> ID .

    ]               reduce using rule 36 (ordinal_type -> ID .)
    ,               reduce using rule 36 (ordinal_type -> ID .)
    DOTDOT          reduce using rule 16 (constant -> ID .)


state 199

    (49) param_list -> param_list ; param .

    )               reduce using rule 49 (param_list -> param_list ; param .)
    ;               reduce using rule 49 (param_list -> param_list ; param .)


state 200

    (50) param -> id_list : ID .

    )               reduce using rule 50 (param -> id_list : ID .)
    ;               reduce using rule 50 (param -> id_list : ID .)


state 201

    (51) param -> VAR id_list : . ID

    ID              shift and go to state 216


state 202

    (47) func_heading -> FUNCTION ID ( param_list ) : . ID

    ID              shift and go to state 217


state 203

    (56) expr_list -> expr_list , expr .

    )               reduce using rule 56 (expr_list -> expr_list , expr .)
    ,               reduce using rule 56 (expr_list -> expr_list , expr .)
    ]               reduce using rule 56 (expr_list -> expr_list , expr .)


state 204

    (54) var_suffix -> [ expr_list ] var_suffix .

    ASSIGN          reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    *               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    /               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    DIV             reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    MOD             reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    AND             reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    +               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    -               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    OR              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    =               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    NE              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    LT              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    GT              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    LE              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    GE              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    THEN            reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    DO              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    END             reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    ;               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    ELSE            reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    )               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    ,               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    ]               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    :               reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    TO              reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)
    DOWNTO          reduce using rule 54 (var_suffix -> [ expr_list ] var_suffix .)


state 205

    (109) var_access_list -> var_access_list , var_access .

    )               reduce using rule 109 (var_access_list -> var_access_list , var_access .)
    ,               reduce using rule 109 (var_access_list -> var_access_list , var_access .)


state 206

    (114) write_list -> write_list , write_param .

    )               reduce using rule 114 (write_list -> write_list , write_param .)
    ,               reduce using rule 114 (write_list -> write_list , write_param .)


state 207

    (116) write_param -> expr : expr .
    (117) write_param -> expr : expr . : expr

    )               reduce using rule 116 (write_param -> expr : expr .)
    ,               reduce using rule 116 (write_param -> expr : expr .)
    :               shift and go to state 218


state 208

    (119) if_statement -> IF expr THEN statement ELSE . statement
    (91) statement -> .
    (92) statement -> . assignment_statement
    (93) statement -> . proc_statement
    (94) statement -> . read_statement
    (95) statement -> . write_statement
    (96) statement -> . labeled_statement
    (97) statement -> . compound_statement
    (98) statement -> . if_statement
    (99) statement -> . while_statement
    (100) statement -> . for_statement
    (101) assignment_statement -> . var_access ASSIGN expr
    (102) proc_statement -> . ID
    (103) proc_statement -> . ID ( expr_list )
    (105) read_statement -> . READ ( var_access_list )
    (106) read_statement -> . READLN
    (107) read_statement -> . READLN ( var_access_list )
    (110) write_statement -> . WRITE ( write_list )
    (111) write_statement -> . WRITELN
    (112) write_statement -> . WRITELN ( write_list )
    (104) labeled_statement -> . INT : statement
    (88) compound_statement -> . BEGIN statement_list END
    (118) if_statement -> . IF expr THEN statement
    (119) if_statement -> . IF expr THEN statement ELSE statement
    (120) while_statement -> . WHILE expr DO statement
    (121) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 91 (statement -> .)
    ;               reduce using rule 91 (statement -> .)
    ELSE            reduce using rule 91 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 219
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 209

    (63) term_sequence -> add_op term term_sequence .

    =               reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    NE              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    LT              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    GT              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    LE              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    GE              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    THEN            reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    DO              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    END             reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    ;               reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    ELSE            reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    )               reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    ,               reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    ]               reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    :               reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    TO              reduce using rule 63 (term_sequence -> add_op term term_sequence .)
    DOWNTO          reduce using rule 63 (term_sequence -> add_op term term_sequence .)


state 210

    (65) factor_sequence -> mul_op factor factor_sequence .

    +               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    -               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    OR              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    =               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    NE              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    LT              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    GT              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    LE              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    GE              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    THEN            reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    DO              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    END             reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    ;               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    ELSE            reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    )               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    ,               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    ]               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    :               reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    TO              reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)
    DOWNTO          reduce using rule 65 (factor_sequence -> mul_op factor factor_sequence .)


state 211

    (71) factor -> ID ( expr_list ) .

    *               reduce using rule 71 (factor -> ID ( expr_list ) .)
    /               reduce using rule 71 (factor -> ID ( expr_list ) .)
    DIV             reduce using rule 71 (factor -> ID ( expr_list ) .)
    MOD             reduce using rule 71 (factor -> ID ( expr_list ) .)
    AND             reduce using rule 71 (factor -> ID ( expr_list ) .)
    +               reduce using rule 71 (factor -> ID ( expr_list ) .)
    -               reduce using rule 71 (factor -> ID ( expr_list ) .)
    OR              reduce using rule 71 (factor -> ID ( expr_list ) .)
    =               reduce using rule 71 (factor -> ID ( expr_list ) .)
    NE              reduce using rule 71 (factor -> ID ( expr_list ) .)
    LT              reduce using rule 71 (factor -> ID ( expr_list ) .)
    GT              reduce using rule 71 (factor -> ID ( expr_list ) .)
    LE              reduce using rule 71 (factor -> ID ( expr_list ) .)
    GE              reduce using rule 71 (factor -> ID ( expr_list ) .)
    THEN            reduce using rule 71 (factor -> ID ( expr_list ) .)
    DO              reduce using rule 71 (factor -> ID ( expr_list ) .)
    END             reduce using rule 71 (factor -> ID ( expr_list ) .)
    ;               reduce using rule 71 (factor -> ID ( expr_list ) .)
    ELSE            reduce using rule 71 (factor -> ID ( expr_list ) .)
    )               reduce using rule 71 (factor -> ID ( expr_list ) .)
    ,               reduce using rule 71 (factor -> ID ( expr_list ) .)
    ]               reduce using rule 71 (factor -> ID ( expr_list ) .)
    :               reduce using rule 71 (factor -> ID ( expr_list ) .)
    TO              reduce using rule 71 (factor -> ID ( expr_list ) .)
    DOWNTO          reduce using rule 71 (factor -> ID ( expr_list ) .)


state 212

    (121) for_statement -> FOR ID ASSIGN expr TO . expr DO statement
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    expr                           shift and go to state 220
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 213

    (122) for_statement -> FOR ID ASSIGN expr DOWNTO . expr DO statement
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    expr                           shift and go to state 221
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 214

    (33) array_type -> ARRAY [ ordinal_type_list ] . OF tipo

    OF              shift and go to state 222


state 215

    (38) ordinal_type_list -> ordinal_type_list , . ordinal_type
    (34) ordinal_type -> . enumerated_type
    (35) ordinal_type -> . subrange_type
    (36) ordinal_type -> . ID
    (31) enumerated_type -> . ( id_list )
    (32) subrange_type -> . constant DOTDOT constant
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    ID              shift and go to state 198
    (               shift and go to state 114
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    +               shift and go to state 47
    -               shift and go to state 48

    ordinal_type                   shift and go to state 223
    enumerated_type                shift and go to state 196
    subrange_type                  shift and go to state 197
    constant                       shift and go to state 115
    sign                           shift and go to state 42

state 216

    (51) param -> VAR id_list : ID .

    )               reduce using rule 51 (param -> VAR id_list : ID .)
    ;               reduce using rule 51 (param -> VAR id_list : ID .)


state 217

    (47) func_heading -> FUNCTION ID ( param_list ) : ID .

    ;               reduce using rule 47 (func_heading -> FUNCTION ID ( param_list ) : ID .)


state 218

    (117) write_param -> expr : expr : . expr
    (57) expr -> . simple_expr
    (58) expr -> . simple_expr relation_op simple_expr
    (59) simple_expr -> . term term_sequence
    (60) simple_expr -> . sign term term_sequence
    (61) term -> . factor factor_sequence
    (17) sign -> . +
    (18) sign -> . -
    (66) factor -> . var_access
    (67) factor -> . INT
    (68) factor -> . REAL
    (69) factor -> . CHAR
    (70) factor -> . STRING
    (71) factor -> . ID ( expr_list )
    (72) factor -> . ( expr )
    (73) factor -> . NOT factor
    (52) var_access -> . ID var_suffix

    +               shift and go to state 47
    -               shift and go to state 48
    INT             shift and go to state 98
    REAL            shift and go to state 99
    CHAR            shift and go to state 100
    STRING          shift and go to state 101
    ID              shift and go to state 102
    (               shift and go to state 103
    NOT             shift and go to state 104

    expr                           shift and go to state 224
    simple_expr                    shift and go to state 93
    term                           shift and go to state 94
    sign                           shift and go to state 95
    factor                         shift and go to state 96
    var_access                     shift and go to state 97

state 219

    (119) if_statement -> IF expr THEN statement ELSE statement .

    END             reduce using rule 119 (if_statement -> IF expr THEN statement ELSE statement .)
    ;               reduce using rule 119 (if_statement -> IF expr THEN statement ELSE statement .)
    ELSE            reduce using rule 119 (if_statement -> IF expr THEN statement ELSE statement .)


state 220

    (121) for_statement -> FOR ID ASSIGN expr TO expr . DO statement

    DO              shift and go to state 225


state 221

    (122) for_statement -> FOR ID ASSIGN expr DOWNTO expr . DO statement

    DO              shift and go to state 226


state 222

    (33) array_type -> ARRAY [ ordinal_type_list ] OF . tipo
    (26) tipo -> . ID
    (27) tipo -> . new_type
    (28) new_type -> . enumerated_type
    (29) new_type -> . subrange_type
    (30) new_type -> . array_type
    (31) enumerated_type -> . ( id_list )
    (32) subrange_type -> . constant DOTDOT constant
    (33) array_type -> . ARRAY [ ordinal_type_list ] OF tipo
    (10) constant -> . sign INT
    (11) constant -> . INT
    (12) constant -> . sign REAL
    (13) constant -> . REAL
    (14) constant -> . CHAR
    (15) constant -> . STRING
    (16) constant -> . ID
    (17) sign -> . +
    (18) sign -> . -

    ID              shift and go to state 109
    (               shift and go to state 114
    ARRAY           shift and go to state 116
    INT             shift and go to state 43
    REAL            shift and go to state 44
    CHAR            shift and go to state 45
    STRING          shift and go to state 46
    +               shift and go to state 47
    -               shift and go to state 48

    tipo                           shift and go to state 227
    new_type                       shift and go to state 110
    enumerated_type                shift and go to state 111
    subrange_type                  shift and go to state 112
    array_type                     shift and go to state 113
    constant                       shift and go to state 115
    sign                           shift and go to state 42

state 223

    (38) ordinal_type_list -> ordinal_type_list , ordinal_type .

    ]               reduce using rule 38 (ordinal_type_list -> ordinal_type_list , ordinal_type .)
    ,               reduce using rule 38 (ordinal_type_list -> ordinal_type_list , ordinal_type .)


state 224

    (117) write_param -> expr : expr : expr .

    )               reduce using rule 117 (write_param -> expr : expr : expr .)
    ,               reduce using rule 117 (write_param -> expr : expr : expr .)


state 225

    (121) for_statement -> FOR ID ASSIGN expr TO expr DO . statement
    (91) statement -> .
    (92) statement -> . assignment_statement
    (93) statement -> . proc_statement
    (94) statement -> . read_statement
    (95) statement -> . write_statement
    (96) statement -> . labeled_statement
    (97) statement -> . compound_statement
    (98) statement -> . if_statement
    (99) statement -> . while_statement
    (100) statement -> . for_statement
    (101) assignment_statement -> . var_access ASSIGN expr
    (102) proc_statement -> . ID
    (103) proc_statement -> . ID ( expr_list )
    (105) read_statement -> . READ ( var_access_list )
    (106) read_statement -> . READLN
    (107) read_statement -> . READLN ( var_access_list )
    (110) write_statement -> . WRITE ( write_list )
    (111) write_statement -> . WRITELN
    (112) write_statement -> . WRITELN ( write_list )
    (104) labeled_statement -> . INT : statement
    (88) compound_statement -> . BEGIN statement_list END
    (118) if_statement -> . IF expr THEN statement
    (119) if_statement -> . IF expr THEN statement ELSE statement
    (120) while_statement -> . WHILE expr DO statement
    (121) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 91 (statement -> .)
    ;               reduce using rule 91 (statement -> .)
    ELSE            reduce using rule 91 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 228
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 226

    (122) for_statement -> FOR ID ASSIGN expr DOWNTO expr DO . statement
    (91) statement -> .
    (92) statement -> . assignment_statement
    (93) statement -> . proc_statement
    (94) statement -> . read_statement
    (95) statement -> . write_statement
    (96) statement -> . labeled_statement
    (97) statement -> . compound_statement
    (98) statement -> . if_statement
    (99) statement -> . while_statement
    (100) statement -> . for_statement
    (101) assignment_statement -> . var_access ASSIGN expr
    (102) proc_statement -> . ID
    (103) proc_statement -> . ID ( expr_list )
    (105) read_statement -> . READ ( var_access_list )
    (106) read_statement -> . READLN
    (107) read_statement -> . READLN ( var_access_list )
    (110) write_statement -> . WRITE ( write_list )
    (111) write_statement -> . WRITELN
    (112) write_statement -> . WRITELN ( write_list )
    (104) labeled_statement -> . INT : statement
    (88) compound_statement -> . BEGIN statement_list END
    (118) if_statement -> . IF expr THEN statement
    (119) if_statement -> . IF expr THEN statement ELSE statement
    (120) while_statement -> . WHILE expr DO statement
    (121) for_statement -> . FOR ID ASSIGN expr TO expr DO statement
    (122) for_statement -> . FOR ID ASSIGN expr DOWNTO expr DO statement
    (52) var_access -> . ID var_suffix

    END             reduce using rule 91 (statement -> .)
    ;               reduce using rule 91 (statement -> .)
    ELSE            reduce using rule 91 (statement -> .)
    ID              shift and go to state 62
    READ            shift and go to state 63
    READLN          shift and go to state 64
    WRITE           shift and go to state 65
    WRITELN         shift and go to state 66
    INT             shift and go to state 67
    BEGIN           shift and go to state 31
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70

    statement                      shift and go to state 229
    assignment_statement           shift and go to state 52
    proc_statement                 shift and go to state 53
    read_statement                 shift and go to state 54
    write_statement                shift and go to state 55
    labeled_statement              shift and go to state 56
    compound_statement             shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    var_access                     shift and go to state 61

state 227

    (33) array_type -> ARRAY [ ordinal_type_list ] OF tipo .

    ;               reduce using rule 33 (array_type -> ARRAY [ ordinal_type_list ] OF tipo .)


state 228

    (121) for_statement -> FOR ID ASSIGN expr TO expr DO statement .

    END             reduce using rule 121 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)
    ;               reduce using rule 121 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)
    ELSE            reduce using rule 121 (for_statement -> FOR ID ASSIGN expr TO expr DO statement .)


state 229

    (122) for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .

    END             reduce using rule 122 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)
    ;               reduce using rule 122 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)
    ELSE            reduce using rule 122 (for_statement -> FOR ID ASSIGN expr DOWNTO expr DO statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 183 resolved as shift
